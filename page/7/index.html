<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="南峰子的技术博客">
<meta property="og:url" content="http://southpeak.github.io/page/7/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南峰子的技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/page/7/"/>

  <title> 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/08/02/reactivecocoa-tutorial-the-definitive-introduction-2/" itemprop="url">
                  ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-02T23:20:48+08:00" content="2014-08-02">
              2014-08-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文由<code>Colin Eberhardt</code>发表于<code>raywenderlich</code>，<a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a></p>
<p><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/">第一部分</a>我们学习了<code>ReactiveCocoa</code>处理信号的基本流程，如何发送流事件，以及分割及组合信号。在这一部分中，我们将继续学习<code>ReactiveCocoa</code>更多的特性，包括：</p>
<ol>
<li><code>error</code>和<code>completed</code>事件类型</li>
<li>节流(<code>Throttling</code>)</li>
<li>线程</li>
<li>扩展</li>
</ol>
<h2 id="Twitter-Instant"><a href="#Twitter-Instant" class="headerlink" title="Twitter Instant"></a>Twitter Instant</h2><p>本部分我们将要开发的是一个称为<code>Twitter Instant</code>的程序，这是一个<code>Twitter</code>搜索应用，用于裡更新搜索结果。可以在<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TwitterInstant-Starter2.zip" target="_blank" rel="external">这里</a>下载初始程序，同时我们需要通过<code>Cocoapods</code>来下载依赖库，这个过程与第一部分相同。完成之后，运行程序，将得到下面的界面：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/TwitterInstantStarter.png" alt="image"></p>
<p>我们花点时间熟悉一下。这个程序很简单。左侧控制面板是<code>RWSearchFormViewController</code>，有一个搜索框。右侧是<code>RWSearchResultsViewController</code>。如果我们打开<code>RWSearchFormViewController.m</code>，我们可以看到<code>viewDidLoad</code>方法中指定了<code>resultsViewController</code>属性，这个程序的主要逻辑是在<code>RWSearchFormViewController</code>中，这个属性将搜索结果提供给<code>RWSearchResultsViewController</code>。</p>
<h2 id="验证搜索框"><a href="#验证搜索框" class="headerlink" title="验证搜索框"></a>验证搜索框</h2><p>首先我们来校验输入框的字符长度是否大于<code>2</code>。我们在<code>RWSearchFormViewController.m</code>的<code>viewDidLoad</code>方法下面添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isValidSearchText:(<span class="built_in">NSString</span> *)text</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> text.length &gt; <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，我们在<code>RWSearchFormViewController.m</code>中导入<code>ReactiveCocoa</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>同时在viewDidLoad方法最后加上以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[<span class="keyword">self</span>.searchText.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">    <span class="keyword">self</span>.searchText.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这段代码通过信号来检测输入是否有效，并设置相应的输入框背影颜色值。运行后，可以看到如下效果：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/ValidatedTextField.png" alt="image"></p>
<p>其管道流程图如下所示：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TextValidationPipeline.png" alt="image"></p>
<p><code>rac_textSignal</code>在每次输入时发出<code>next</code>事件，并包含当前输入框的文本。然后<code>map</code>操作将其转换为颜色值，最后<code>subscribeNext:</code>获取这个颜色值并用它来设置输入框的背景颜色。</p>
<p>在添加Twitter查找逻辑之前，我们先看看一些有趣的东西。</p>
<h2 id="格式化管道代码"><a href="#格式化管道代码" class="headerlink" title="格式化管道代码"></a>格式化管道代码</h2><p>在调用信号的方法时，我们建议每个操作都新起一行，并排列所有的步骤。如下图所示，一个复杂的管道通过分行，看起来会更加清晰</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/PipelineFormatting.png" alt="image"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>考虑下我们添加到<code>TwitterInstant</code>程序中的代码，想知道我们创建的管道是如何被保存的么？当然，因为它没有被指定给变量或属性，所以它没有增加引用计数，因此注定被销毁？<code>ReactiveCocoa</code>设计的目的之一是允许这样一种编程样式，即管道可以匿名创建。到目前为止，我们的管道都是这么处理的。为了支持这种模式，<code>ReactiveCocoa</code>维护了一个全局的信号集合。如果信号有一个或多个订阅者，它就是可用的。如果所有订阅者都被移除了，信号就被释放了。</p>
<p>剩下最后一个问题：如何取消对信号的订阅？在一个<code>completed</code>事件或<code>error</code>事件后，一个订阅者会自动将自己移除。手动移除可能通过<strong>RACDisposable</strong>来完成。<code>RACSignal</code>的所有订阅方法都返回一个<code>RACDisposable</code>实例，我们可以调用它的<code>dispose</code>方法来手动移除订阅者。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">RACSignal *backgroundColorSignal =</div><div class="line">    [<span class="keyword">self</span>.searchText.rac_textSignal</div><div class="line">     map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">         <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">     &#125;];</div><div class="line"></div><div class="line">RACDisposable *subscripion =</div><div class="line">    [backgroundColorSignal subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">        <span class="keyword">self</span>.searchText.backgroundColor = color;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line"><span class="comment">// 在某个位置调用</span></div><div class="line">[subscripion dispose];</div></pre></td></tr></table></figure>
<p>当然实际上我们不需要这样来写，只需要知道是这么回事就行。</p>
<p><em>注意：如果我们创建了一个管道，但不去订阅它，则管理永远不会执行，包括任何如doNext:块这样的附加操作。</em></p>
<h2 id="避免循环引用"><a href="#避免循环引用" class="headerlink" title="避免循环引用"></a>避免循环引用</h2><p><code>ReactiveCocoa</code>在幕后做了许多事情，让我们不需要担心信号的内存管理问题，但有一点关于内存管理的问题需要特别注意。我们先来看看下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[<span class="keyword">self</span>.searchText.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">    <span class="keyword">self</span>.searchText.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>subscribeNext:</code>块使用了<code>self</code>，以获取文本输入域。<code>Block</code>会捕获并保留闭包中的值，因此如果在<code>self</code>与信号之间有一个强引用，则会导致循环引用问题。这是不是问题取决于<code>self</code>对象的生命周期。如果<code>self</code>的生命周期是整个程序生存期，则没问题，好好用吧。但在大多数情况下，它确实是一个问题。</p>
<p>为了避循环引用，根据苹果的文档中推荐的捕获<code>self</code>的一个弱引用。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">typeof</span>(<span class="keyword">self</span>) __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">[[<span class="keyword">self</span>.searchText.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> [weakSelf isValidSearchText:text] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">    weakSelf.searchText.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>在上面的代码中<code>weakSelf</code>是<code>self</code>对象的一个弱引用。现在<code>subscribeNext:</code>中使用了这个变量。不过<code>ReactiveCocoa</code>框架给我们提供了一个更好的选择。首先导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;RACEXTScope.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>然后使用以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>)</div><div class="line"></div><div class="line">[[<span class="keyword">self</span>.searchText.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">self</span>.searchText.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>宏<code>@weakify</code>与<code>@strongify</code>在<a href="https://github.com/jspahrsummers/libextobjc" target="_blank" rel="external">Extendedobjc</a>库中引用，它们包含在<code>ReactiveCocoa</code>框架中。<code>@weakify</code>允许我们创建一些影子变量，它是都是弱引用(可以同时创建多个)，<code>@strongify</code>允许创建变量的强引用，这些变量是先前传递给<code>@weakify</code>的。</p>
<p>最后需要注意的是，当在<code>block</code>中使用实例变量时，<code>block</code>同样会捕获<code>self</code>的一个强引用。我们可以打开编译器警告，来提示我们这种情况。如下所求来处理</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/AvoidRetainSelf.png" alt="image"></p>
<p>OK，内存问题说得差不多了，现在我们回到正题。</p>
<h2 id="请求访问Twitter"><a href="#请求访问Twitter" class="headerlink" title="请求访问Twitter"></a>请求访问Twitter</h2><p>我们将使用<code>Social Framework</code>以允许<code>TwitterInstant</code>程序搜索<code>Tweets</code>，同时使用<code>Accounts Framework</code>来获取对<code>Twitter</code>的访问。</p>
<p>在添加代码前，我们需要先登录<code>Twitter</code>。可以在系统的设置中登录，如下图所示：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/TwitterCredentials.png" alt="image"></p>
<p>我们的工程已经添加了所需要的框架，所以只需要在<code>RWSearchFormViewController.m</code>导入头文件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Accounts/Accounts.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Social/Social.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>然后在下面添加枚举及常量用于标识错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTwitterInstantError) &#123;</div><div class="line">    RWTwitterInstantErrorAccessDenied,</div><div class="line">    RWTwitterInstantErrorNoTwitterAccounts,</div><div class="line">    RWTwitterInstantErrorInvalidResponse</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTwitterInstantDomain = <span class="string">@"TwitterInstant"</span>;</div></pre></td></tr></table></figure>
<p>然后我们<code>RWSearchFormViewController()</code>分类中添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ACAccountStore *accountStore;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ACAccountType *twitterAccountType;</div></pre></td></tr></table></figure>
<p><code>ACAccountsStore</code>类提供了我们的设备可连接的多种社交账号，<code>ACAccountType</code>类表示账号的指定类型。</p>
<p>我们在<code>viewDidLoad</code>的结尾处添加以下代码，来创建账户存储及<code>Twitter</code>账户标识：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.accountStore = [[ACAccountStore alloc] init];</div><div class="line"><span class="keyword">self</span>.twitterAccountType = [<span class="keyword">self</span>.accountStore accountTypeWithAccountTypeIdentifier:ACAccountTypeIdentifierTwitter];</div></pre></td></tr></table></figure>
<p>当账户请求社账号时，用户可以看到一个弹出框。这是一个异步操作，所以将其包装到一个信号中是很好的选择。</p>
<p>仍然在这个文件中，添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)requestAccessToTwitterSignal</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 定义一个错误，如果用户拒绝访问则发送</span></div><div class="line">    <span class="built_in">NSError</span> *accessError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorAccessDenied userInfo:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 创建并返回信号</span></div><div class="line">    @weakify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 请求访问twitter</span></div><div class="line">        @strongify(<span class="keyword">self</span>)</div><div class="line">        [<span class="keyword">self</span>.accountStore requestAccessToAccountsWithType:<span class="keyword">self</span>.twitterAccountType</div><div class="line">                                                   options:<span class="literal">nil</span></div><div class="line">                                                completion:^(<span class="built_in">BOOL</span> granted, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                                                    <span class="comment">// 处理响应</span></div><div class="line">                                                    <span class="keyword">if</span> (!granted)</div><div class="line">                                                    &#123;</div><div class="line">                                                        [subscriber sendError:accessError];</div><div class="line">                                                    &#125;</div><div class="line">                                                    <span class="keyword">else</span></div><div class="line">                                                    &#123;</div><div class="line">                                                        [subscriber sendNext:<span class="literal">nil</span>];</div><div class="line">                                                        [subscriber sendCompleted];</div><div class="line">                                                    &#125;</div><div class="line">                                                &#125;];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个信号可以发送三种事件类型：<code>next</code>, <code>completed</code>, <code>error</code>。</p>
<p>在信号的整个生命周期中，都可能不会发送事件，或者发送一个或多个<code>next</code>事件，其后跟着<code>completed</code>或<code>error</code>事件。</p>
<p>最后，为了使用这个信号，在<code>viewDidLoad</code>中添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Access granted"</span>);</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>运行程序，可以看到下面的提示</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/RequestAccessToTwitter.png" alt="image"></p>
<p>如果点击OK，<code>subscribeNext:</code>块中的日志会打印出来。如果点击<code>Don&#39;t allow</code>，则会执行错误块并打印期望的信息。</p>
<h2 id="链接信号"><a href="#链接信号" class="headerlink" title="链接信号"></a>链接信号</h2><p>一旦用户获取了<code>Twitter</code>账户的访问权限，程序需要继续监听搜索框的输入，以查询<code>twitter</code>。程序需要等待请求访问<code>Twitter</code>的信号来发出完成事件，然后订阅广西输入框的信号。不同信号的顺序链接是一个问题，但<code>ReactiveCocoa</code>已经做了很好的处理。</p>
<p>在<code>viewDidLoad</code>中用下面代码来替换当前的管道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line"> then:^RACSignal *&#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p><code>then</code>方法会等到<code>completed</code>事件发出后调用，然后订阅由<code>block</code>参数返回的信号。这有效地将控制从一个信号传递给下一个信号。运行程序，获取访问，然后在输入框输入，会在控制台看到以下输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">11.444</span> TwitterInstant[<span class="number">39118</span>:a0b] m</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.276</span> TwitterInstant[<span class="number">39118</span>:a0b] ma</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.413</span> TwitterInstant[<span class="number">39118</span>:a0b] mag</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.548</span> TwitterInstant[<span class="number">39118</span>:a0b] magi</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.628</span> TwitterInstant[<span class="number">39118</span>:a0b] magic</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">13.172</span> TwitterInstant[<span class="number">39118</span>:a0b] magic!</div></pre></td></tr></table></figure>
<p>下一步，我们添加一个<code>filter</code>操作到管道，以移除无效的搜索字符串。在这个实例中，是要求输入长度不小于<code>3</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line"> then:^RACSignal *&#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line"> &#125;]</div><div class="line"> filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>运行后的输出是</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.548</span> TwitterInstant[<span class="number">39118</span>:a0b] magi</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">12.628</span> TwitterInstant[<span class="number">39118</span>:a0b] magic</div><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">16</span>:<span class="number">13.172</span> TwitterInstant[<span class="number">39118</span>:a0b] magic!</div></pre></td></tr></table></figure>
<p>当前管道如下图所示：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/PipelineWithThen.png" alt="image"></p>
<p>现在我们有一个发送搜索文本的信号了，是时候用它来搜索<code>Twitter</code>了。接下来才是正题。</p>
<h2 id="搜索Twitter"><a href="#搜索Twitter" class="headerlink" title="搜索Twitter"></a>搜索Twitter</h2><p><code>Social Framework</code>是访问<code>Twitter</code>搜索<code>API</code>的一个选择。但是<code>Social Framework</code>不是响应式的。接下来是封装所需要的<code>API</code>方法到信号中。现在，我们需要挂起这个过程。</p>
<p>在<code>RWSearchFormViewController.m</code>中，添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (SLRequest *)requestforTwitterSearchWithText:(<span class="built_in">NSString</span> *)text</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://api.twitter.com/1.1/search/tweets.json"</span>];</div><div class="line">    <span class="built_in">NSDictionary</span> *params = @&#123;<span class="string">@"q"</span>: text&#125;;</div><div class="line">    </div><div class="line">    SLRequest *request = [SLRequest requestForServiceType:SLServiceTypeTwitter</div><div class="line">                                            requestMethod:SLRequestMethodGET</div><div class="line">                                                      URL:url</div><div class="line">                                               parameters:params];</div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法通过<a href="https://dev.twitter.com/docs/api/1.1" target="_blank" rel="external">v1.1 REST API</a>创建了一个搜索<code>Twitter</code>的请求。关于这个<code>API</code>，可以在<a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets" target="_blank" rel="external">Twitter API docs</a>中查看更多信息。</p>
<p>接下来创建一个基于请求的信号。在同一文件中，添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)signalForSearchWithText:(<span class="built_in">NSString</span> *)text &#123;</div><div class="line">    <span class="comment">// 定义错误</span></div><div class="line">    <span class="built_in">NSError</span> *noAccountError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorNoTwitterAccounts userInfo:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSError</span> *invalidResponseError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorInvalidResponse userInfo:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 创建信号block</span></div><div class="line">    @weakify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>)</div><div class="line">        </div><div class="line">        <span class="comment">// 创建请求</span></div><div class="line">        SLRequest *request = [<span class="keyword">self</span> requestforTwitterSearchWithText:text];</div><div class="line">        </div><div class="line">        <span class="comment">// 提供Twitter账户</span></div><div class="line">        <span class="built_in">NSArray</span> *twitterAccounts = [<span class="keyword">self</span>.accountStore accountsWithAccountType:<span class="keyword">self</span>.twitterAccountType];</div><div class="line">        <span class="keyword">if</span> (twitterAccounts.count == <span class="number">0</span>) &#123;</div><div class="line">            [subscriber sendError:noAccountError];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [request setAccount:[twitterAccounts lastObject]];</div><div class="line">            </div><div class="line">            <span class="comment">// 执行请求</span></div><div class="line">            [request performRequestWithHandler:^(<span class="built_in">NSData</span> *responseData, <span class="built_in">NSHTTPURLResponse</span> *urlResponse, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                <span class="keyword">if</span> (urlResponse.statusCode == <span class="number">200</span>) &#123;</div><div class="line">                    <span class="comment">// 成功，解析响应</span></div><div class="line">                    <span class="built_in">NSDictionary</span> *timelineData = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:responseData options:<span class="built_in">NSJSONReadingAllowFragments</span> error:<span class="literal">nil</span>];</div><div class="line">                    [subscriber sendNext:timelineData];</div><div class="line">                    [subscriber sendCompleted];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 失败，发送一个错误</span></div><div class="line">                    [subscriber sendError:invalidResponseError];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们来使用这个新信号。</p>
<p>在第一部分中我们学习了如何使用<code>flattenMap</code>来将每个<code>next</code>事件映射到一个新的被订阅的信号。这里我们再次使用它们。在<code>viewDidLoad</code>的最后用如下代码更新：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line"> then:^RACSignal *&#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line"> &#125;]</div><div class="line"> filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line"> &#125;]</div><div class="line"> flattenMap:^RACStream *(<span class="built_in">NSString</span> *text ) &#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> signalForSearchWithText:text];</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>运行并在搜索框中输入一些文本。一旦文本字符串长度大于<code>3</code>后，我们可以在控制台查看搜索的结果。如下显示了返回数据的一个片断：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-01</span><span class="number">-05</span> <span class="number">07</span>:<span class="number">42</span>:<span class="number">27.697</span> TwitterInstant[<span class="number">40308</span>:<span class="number">5403</span>] &#123;</div><div class="line">    <span class="string">"search_metadata"</span> =     &#123;</div><div class="line">        <span class="string">"completed_in"</span> = <span class="string">"0.019"</span>;</div><div class="line">        count = <span class="number">15</span>;</div><div class="line">        <span class="string">"max_id"</span> = <span class="number">419735546840117248</span>;</div><div class="line">        <span class="string">"max_id_str"</span> = <span class="number">419735546840117248</span>;</div><div class="line">        <span class="string">"next_results"</span> = <span class="string">"?max_id=419734921599787007&amp;q=asd&amp;include_entities=1"</span>;</div><div class="line">        query = asd;</div><div class="line">        <span class="string">"refresh_url"</span> = <span class="string">"?since_id=419735546840117248&amp;q=asd&amp;include_entities=1"</span>;</div><div class="line">        <span class="string">"since_id"</span> = <span class="number">0</span>;</div><div class="line">        <span class="string">"since_id_str"</span> = <span class="number">0</span>;</div><div class="line">    &#125;;</div><div class="line">    statuses =     (</div><div class="line">                &#123;</div><div class="line">            contributors = <span class="string">"&lt;null&gt;"</span>;</div><div class="line">            coordinates = <span class="string">"&lt;null&gt;"</span>;</div><div class="line">            <span class="string">"created_at"</span> = <span class="string">"Sun Jan 05 07:42:07 +0000 2014"</span>;</div><div class="line">            entities =             &#123;</div><div class="line">                hashtags = ...</div></pre></td></tr></table></figure>
<p><code>signalForSearchText:</code>方法同样发出了一个<code>error</code>事件，其由<code>subscribeNext:error:</code>块来处理。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>现在一定想把返回的<code>JSON</code>数据显示到<code>UI</code>上了吧，不过，在此之前我们还有一件事情需要处理。要了解这是什么，我们还需要探索一下。</p>
<p>在下图的<code>subscribeNext:error:</code>中打个断点：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/BreakpointLocation.png" alt="image"></p>
<p>重新运行程序，如果需要则再次输入<code>Twitter</code>账号密码，在搜索框中输入一些文本。当程序运行到断点位置时可以看到类似于下图的场景：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/BreakpointResult.png" alt="image"></p>
<p>注意，从左侧的线程列表中我们可以看到<code>debugger</code>到的代码并没有运行在主线程，即线程<code>Thread 1</code>。记住，更新<code>UI</code>的操作一定得在主线程中操作；因此，如果要在<code>UI</code>上显示<code>tweet</code>列表，则必须切换线程。</p>
<p>这说明了<code>ReactiveCocoa</code>框架的一个重要点。上面显示的操作是在信号初始发出事件时的那个线程执行。尝试在管道的其它步骤添加断点，我们会很惊奇的发现它们会运行在多个不同的线程上。</p>
<p>因此，我们应该如何来更新UI呢？当然<code>ReactiveCocoa</code>也为我们解决了这个问题。我们只需要在<code>flattenMap:</code>后面添加<code>deliverOn:</code>操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[[[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line"> then:^RACSignal *&#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line"> &#125;]</div><div class="line"> filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line"> &#125;] flattenMap:^RACStream *(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">     @strongify(<span class="keyword">self</span>)</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> signalForSearchWithText:text];</div><div class="line"> &#125;]</div><div class="line"> deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>现在重新运行，此时我们可以看到<code>subscribeNext:error:</code>是运行在主线程了。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/BreakpointNowOnUIThread.png" alt="image"></p>
<p>这样我们就可以安全地更新我们的UI了。</p>
<h2 id="更新UI"><a href="#更新UI" class="headerlink" title="更新UI"></a>更新UI</h2><p>打开<code>RWSearchResultsViewController.h</code>文件，我们可以看到<code>displayTweets:</code>方法，这个方法会让右侧的<code>ViewController</code>来渲染<code>tweet</code>数组。实现非常简单，它只是一个标准<code>UITableView</code>数据源。<code>displayTweets:</code>只需要一个包含<code>RWTweet</code>实例的数组作为参数。我们同样发现<code>RWTweet</code>实例是作为初始工程的一部分提供的。</p>
<p>在<code>subscibeNext:error:</code>步骤中获取到的数据现在是一个<code>NSDictionary</code>，它是在<code>signalForSearchWithText:</code>解析<code>JSON</code>数据时构造的。那么，我们如何处理这个字典的内容呢？</p>
<p>如果看一看<a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets" target="_blank" rel="external">Twitter API documentation</a>，我们可以发现一个示例响应。在<code>NSDictionary</code>反映了这种结构，所以我们需要找到一个键名为<code>statues</code>的字典，其值为一个<code>tweets</code>数组。具体如何解析我们就不在此说明。这里给个更好的实现方式。</p>
<p>我们现在讲的是<code>ReactiveCocoa</code>及函数式编程。当我们使用函数式<code>API</code>时，数据从一种格式转换到另一种格式会变得更优雅。我们可以使用<a href="https://github.com/ColinEberhardt/LinqToObjectiveC" target="_blank" rel="external">LinqToObjectiveC</a>来执行这个任务。</p>
<p>我们需要使用<code>Cocoapods</code>来导入<code>LinqToObjectiveC</code>。在配置文件中加入以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod 'LinqToObjectiveC', '2.0.0'</div></pre></td></tr></table></figure>
<p>关闭工程，在终端执行<code>pod update</code>命令，完成后在我们的<code>Pods</code>工程中就可以看到<code>LinqToObjectiveC</code>了。</p>
<p>打开<code>RWSearchFormViewController.m</code>并导入以下文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWTweet.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"NSArray+LinqExtensions.h"</span></span></div></pre></td></tr></table></figure>
<p><code>NSArray+LinqExtensions.h</code>头文件来自于<code>LinqToObjectiveC</code>，并为<code>NSArray</code>添加了许多方法以允许我们使用一个流畅的<code>API</code>来转换、排序、分组及过滤数组的数据。</p>
<p>现在我们使用这些<code>API</code>来更新当前管道操作，在<code>viewDidLoad</code>代码中做如下修改：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">[[[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line">     then:^RACSignal *&#123;</div><div class="line">         @strongify(<span class="keyword">self</span>)</div><div class="line">         <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line">     &#125;]</div><div class="line">    filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>)</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line">    &#125;]</div><div class="line">   flattenMap:^RACStream *(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">       @strongify(<span class="keyword">self</span>)</div><div class="line">       <span class="keyword">return</span> [<span class="keyword">self</span> signalForSearchWithText:text];</div><div class="line">   &#125;]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line"> subscribeNext:^(<span class="built_in">NSDictionary</span> *jsonSearchResult) &#123;</div><div class="line">     <span class="built_in">NSArray</span> *statuses = jsonSearchResult[<span class="string">@"statuses"</span>];</div><div class="line">     <span class="built_in">NSArray</span> *tweets = [statuses linq_select:^<span class="keyword">id</span>(<span class="keyword">id</span> tweet) &#123;</div><div class="line">         <span class="keyword">return</span> [RWTweet tweetWithStatus:tweet];</div><div class="line">     &#125;];</div><div class="line">     [<span class="keyword">self</span>.resultsViewController displayTweets:tweets];</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>如上所看到的，<code>subscribeNext:</code>块首先获取<code>tweets</code>的<code>NSArray</code>对象。<code>linq_select</code>方法通过执行应用于每个数组元素的<code>block</code>来转换<code>NSDictionary</code>字典的数组，并生成一个<code>RWTweet</code>实例的数组。</p>
<p>一旦转换完成，<code>tweets</code>将结果发送给<code>ViewController</code>。</p>
<p>运行程序后我们可以看到以下<code>UI</code>：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/FinallyWeSeeTweets.png" alt="image"></p>
<h2 id="异步加载图片"><a href="#异步加载图片" class="headerlink" title="异步加载图片"></a>异步加载图片</h2><p>在上图中，我们可以看到每行数据前面有一片空白，这是用来显示用户头像的。<code>RWTweet</code>类已经有一个<code>profileImageUrl</code>属性，它是一个图片的<code>URL</code>地址。为了让<code>UITableTable</code>滑动得更平滑，我们需要让获取指定<code>URL</code>的图片的操作不运行在主线程中。这可以使用<code>GCD</code>或者是<code>NSOperationQueue</code>。不过，<code>ReactiveCocoa</code>同样为我们提供了解决方案。</p>
<p>打开<code>RWSearchResultsViewController.m</code>，添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-(RACSignal *)signalForLoadingImage:(<span class="built_in">NSString</span> *)imageUrl &#123;</div><div class="line">    </div><div class="line">    RACScheduler *scheduler = [RACScheduler</div><div class="line">                               schedulerWithPriority:RACSchedulerPriorityBackground];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:imageUrl]];</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">        [subscriber sendNext:image];</div><div class="line">        [subscriber sendCompleted];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;] subscribeOn:scheduler];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们应该熟悉这种模式了。以上的方法首先获取一个后台<code>scheduler</code>作为信号执行的线程，而不是主线程。接下来，创建一个下载图片数据的信号并在其有订阅者时创建一个<code>UIImage</code>。最后我们调用<code>subscribeOn:</code>，以确保信号在给定的<code>scheduler</code>上执行。</p>
<p>现在，我们可以更新<code>tableView:cellForRowAtIndex:</code>，在<code>return</code>之前添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cell.twitterAvatarView.image = <span class="literal">nil</span>;</div><div class="line"> </div><div class="line">[[[<span class="keyword">self</span> signalForLoadingImage:tweet.profileImageUrl]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line">  subscribeNext:^(<span class="built_in">UIImage</span> *image) &#123;</div><div class="line">   cell.twitterAvatarView.image = image;</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>上面的代码首先重新设置图片，因为重用的单元格可能包含之前的数据。然后创建一个请求信号去获取数据，在<code>deliverOn:</code>中我们将后面的<code>next</code>事件运行在主线程，这样<code>subscribeNext:</code>可以安全运行。</p>
<p>运行后得到如下结果：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/AvatarsAtAlast.png" alt="image"></p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>你可能已经发现每次我们输入一个新的字符时，搜索操作都会立即执行。如果我们快速输入，可能会导致程序在一秒钟内执行了多次搜索操作。这当然是不好的，因为：</p>
<ol>
<li>我们多次调用了<code>Twitter</code>搜索<code>API</code>，同时扔掉了大部分结果。</li>
<li>我们不断更新结果会分散用户的注意力。</li>
</ol>
<p>一个更好的方案是如果搜索文本在一个较短时间内没有改变时我们再去执行搜索操作，如<code>500</code>毫秒。<code>ReactiveCocoa</code>框架让这一任务变得相当简单。</p>
<p>打开<code>RWSearchFormViewController.m</code>并更新管道操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[[[[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line">      then:^RACSignal *&#123;</div><div class="line">          @strongify(<span class="keyword">self</span>)</div><div class="line">          <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line">      &#125;]</div><div class="line">     filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">         @strongify(<span class="keyword">self</span>)</div><div class="line">         <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line">     &#125;]</div><div class="line">    throttle:<span class="number">0.5</span>]</div><div class="line">   flattenMap:^RACStream *(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">       @strongify(<span class="keyword">self</span>)</div><div class="line">       <span class="keyword">return</span> [<span class="keyword">self</span> signalForSearchWithText:text];</div><div class="line">   &#125;]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line"> subscribeNext:^(<span class="built_in">NSDictionary</span> *jsonSearchResult) &#123;</div><div class="line">     <span class="built_in">NSArray</span> *statuses = jsonSearchResult[<span class="string">@"statuses"</span>];</div><div class="line">     <span class="built_in">NSArray</span> *tweets = [statuses linq_select:^<span class="keyword">id</span>(<span class="keyword">id</span> tweet) &#123;</div><div class="line">         <span class="keyword">return</span> [RWTweet tweetWithStatus:tweet];</div><div class="line">     &#125;];</div><div class="line">     [<span class="keyword">self</span>.resultsViewController displayTweets:tweets];</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p><code>throttle</code>操作只有在两次<code>next</code>事件间隔指定的时间时才会发送第二个<code>next</code>事件。相当简单吧。运行程序看看效果吧。    </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在庆祝胜利前，看看程序最终的管道是值得的。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/CompletePipeline.png" alt="image"></p>
<p>这是一个相当复杂的数据流，但可以作为一个响应管道简洁地表示出来。看起来不错吧。如果使用非响应式技术，你会觉得这会有多复杂呢？在这样一个程序中，数据流的流动又会是多难以理解呢？听起来很麻烦吧。但有了<code>ReactiveCocoa</code>，我们不必再考虑这些了。现在我们知道<code>ReactiveCocoa</code>有多棒了吧。</p>
<p>最后，<code>ReactiveCocoa</code>让使用<code>Model View ViewModel(MVVM)</code>设计模式变成可能。如果有兴趣研究<code>MVVM</code>，可以去网上搜索相关的文章。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/08/02/reactivecocoa-tutorial-the-definitive-introduction-1/" itemprop="url">
                  ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-02T23:03:12+08:00" content="2014-08-02">
              2014-08-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文由<code>Colin Eberhardt</code>发表于<code>raywenderlich</code>，<a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2</a></p>
<p>在编写<code>iOS</code>代码时，我们的大部分代码都是在响应一些事件：按钮点击、接收网络消息、属性变化等等。但是这些事件在代码中的表现形式却不一样：如<code>target-action</code>、代理方法、<code>KVO</code>、回调或其它。<code>ReactiveCocoa</code>的目的就是定义一个统一的事件处理接口，这样它们可以非常简单地进行链接、过滤和组合。</p>
<p><code>ReactiveCocoa</code>结合了一些编程模式：</p>
<ol>
<li>函数式编程：利用高阶函数，即将函数作为其它函数的参数。</li>
<li>响应式编程：关注于数据流及变化的传播。</li>
</ol>
<p>基于以上两点，<code>ReactiveCocoa</code>被当成是函数响应编程(<code>Functional Reactive Programming, FRP</code>)框架。我们将在下面以实例来看看<code>ReactiveCocoa</code>的实用价值。</p>
<h2 id="Reactive-Playground实例"><a href="#Reactive-Playground实例" class="headerlink" title="Reactive Playground实例"></a>Reactive Playground实例</h2><p>虽然这是一篇指南性质的文章，但我们将以一个简单的实例来介绍<code>ReactiveCocoa</code>。可以在<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlayground-Starter.zip" target="_blank" rel="external">这里</a>下载源代码，然后编译并运行以确保程序可以运行。</p>
<p><code>ReactivePlayground</code>是个非常简单的应用，只有一个用户登录界面。只需要提供正确的用户名及密码，就可以显示一幅可爱的小猫的图片。如下图所示：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlaygroundStarter.jpg" alt="image"></p>
<p>这个工程很简单，所以花几分钟来熟悉一下这个工程。打开<code>RWViewController.m</code>，可以快速查找一下如何设置<code>Sign in</code>按钮可用的代码，以及显示/隐藏<code>signInFailure Label</code>的规则。在简单的实现中，我们能快速定位这些问题，但如果实现很复杂，那可能需要花一些时间来分析代码。</p>
<p>现在，我们有了<code>ReactiveCocoa</code>，它能让代码变得更清晰。来看看它是怎么做到的吧。</p>
<h2 id="添加ReactiveCocoa框架"><a href="#添加ReactiveCocoa框架" class="headerlink" title="添加ReactiveCocoa框架"></a>添加ReactiveCocoa框架</h2><p>添加<code>ReactiveCocoa</code>框架到我们工程的最简单的方法是使用<code>Cocoapods</code>。我们先关闭<code>ReactivePlayground</code>工程。<code>Cocoapods</code>会创建一个<code>Xcode workspace</code>，它会替代我们的原始工程文件。</p>
<p>首先创建一个名为<code>Podfile</code>的空文件，打开并添加如下信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">platform :ios, '6.0'</div><div class="line">inhibit_all_warnings!</div><div class="line">xcodeproj 'RWReactivePlayground'</div><div class="line"></div><div class="line">target :RWReactivePlayground do</div><div class="line">    pod 'ReactiveCocoa', '~&gt; 2.3.1'</div><div class="line">end</div><div class="line"></div><div class="line">post_install do |installer|</div><div class="line">installer.project.targets.each do |target|</div><div class="line">puts "#&#123;target.name&#125;"</div><div class="line">end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>配置完成后保存文件，打开终端并转到工程所在目录，然后输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod install</div></pre></td></tr></table></figure>
<p>然后终端会有如下输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Analyzing dependencies</div><div class="line">Downloading dependencies</div><div class="line">Installing ReactiveCocoa (2.3.1)</div><div class="line">Generating Pods project</div><div class="line">Pods-RWReactivePlayground-ReactiveCocoa</div><div class="line">Pods-RWReactivePlayground</div><div class="line">Integrating client project</div><div class="line"></div><div class="line">[!] From now on use `RWReactivePlayground.xcworkspace`.</div></pre></td></tr></table></figure>
<p>这表示已经下载了<code>ReactiveCocoa</code>框架，同时<code>Cocoapods</code>创建了一个<code>Xcode workspace</code>，同时将框架整合到了我们的工程中。打开新生成的<code>workspace</code>文件(<code>RWReactivePlayground.xcworkspace</code>)，将看到如下的工程结构：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/AddedCocoaPods.png" alt="image"></p>
<p>我们看到有一个命名为<code>ReactivePlayground</code>的工程，这实际上是我们的初始工程，它依赖于<code>Pods</code>工程。做完这一切后，我们就可以开始玩了，哈哈。</p>
<h2 id="Time-to-Play"><a href="#Time-to-Play" class="headerlink" title="Time to Play"></a>Time to Play</h2><p>如上所述，<code>ReactiveCocoa</code>提供了一个标准的接口来处理不同的事件流。在<code>ReactiveCocoa</code>中，这些被统一称为信号，由<code>RACSignal</code>类表示。</p>
<p>打开程序的初始视图控制器<code>RWViewController.m</code>文件，在文件头部导入以下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>我们暂时先不替换原来的代码，先看看如何使用<code>ReactiveCocoa</code>。在<code>viewDidLoad</code>方法中加入如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.usernameTextField.rac_textSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>运行程序并在用户名输入框中键入”<code>reactive cocoa</code>“，我们可以看到控制台会有如下输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">30.890</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] r</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">32.007</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] re</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">32.289</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] rea</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">33.990</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reac</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">34.889</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] react</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">35.557</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reacti</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">36.022</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactiv</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">36.505</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">42.328</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive </div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">47.223</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive c</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">47.794</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive co</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">48.191</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive coc</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">48.657</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive coco</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">49.141</span> RWReactivePlayground[<span class="number">9191</span>:<span class="number">60</span>b] reactive cocoa</div></pre></td></tr></table></figure>
<p>我们可以看到，每次在<code>text field</code>中输入时，都会执行<code>block</code>中的代码。没有<code>target-action</code>，没有代理，只有信号与<code>block</code>。是不是很棒？</p>
<p><code>ReactiveCocoa</code>信号发送一个事件流到它们的订阅者中。我们需要知道三种类型的事件：<code>next</code>, <code>error</code>和<code>completed</code>。一个信号可能由于<code>error</code>事件或<code>completed</code>事件而终止，在此之前它会发送很多个<code>next</code>事件。在这一部分中，我们将重点关注<code>next</code>事件。在学习关于<code>error</code>和<code>completed</code>事件前，请仔细阅读第二部分。</p>
<p><code>RACSignal</code>有许多方法用于订阅这些不同的事件类型。每个方法会有一个或多个<code>block</code>，每个<code>block</code>执行不同的逻辑处理。在上面这个例子中，我们看到<code>subscribeNext:</code>方法提供了一个响应<code>next</code>事件的<code>block</code>。</p>
<p><code>ReactiveCocoa</code>框架通过类别来为大部分标准<code>UIKit</code>控件添加信号，以便这些控件可以添加其相应事件的订阅，如上面的<code>UITextField</code>包含了<code>rac_textSignal</code>属性。</p>
<p>理论讲得差不多了，我们继续吧！！！</p>
<p><code>ReactiveCocoa</code>有大量的操作右用于处理事件流。例如，如果我们只对长度大于<code>3</code>的用户名感兴趣，则我们可以使用<code>filter</code>操作。在<code>viewDidLoad</code>中更新我们的代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[<span class="keyword">self</span>.usernameTextField.rac_textSignal filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="built_in">NSString</span> *text = value;</div><div class="line">    <span class="keyword">return</span> text.length &gt; <span class="number">3</span>;</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>运行并在用户名输入框中输入<code>&quot;reactive cocoa&quot;</code>，我们可以看到控制台会有如下输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">13.558</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reac</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">15.960</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] react</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">16.589</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reacti</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">17.158</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactiv</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">17.807</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">18.674</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive </div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">19.176</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive c</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">19.710</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive co</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">20.057</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive coc</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">20.530</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive coco</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">15</span>:<span class="number">52</span>:<span class="number">20.978</span> RWReactivePlayground[<span class="number">9249</span>:<span class="number">60</span>b] reactive cocoa</div></pre></td></tr></table></figure>
<p>可以看到当长度小于<code>3</code>时，并不执行后续的操作。通过这种方式，我们创建了一个简单的管道。这就是响应式编程的实质，我们将我们程序的功能表示为数据流的形式。我们可以将上述调用表示为以下图例：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/FilterPipeline.png" alt="image"></p>
<p>从上图中我们可以看到<code>rac_textSignal</code>是事件的初始源头。通过<code>filter</code>的数据流只有在其长度大于3时，才会被传递到下一处理流程中。管道的最后一步是<code>subscribeNext:</code>，在这个<code>block</code>中，我们记录日志。</p>
<p>在这里需要注意的是<code>filter</code>操作的输出仍然是一个<code>RACSignal</code>对象。我们可以将上面这段管道处理拆分成如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">RACSignal *usernameSourceSignal = <span class="keyword">self</span>.usernameTextField.rac_textSignal;</div><div class="line"></div><div class="line">RACSignal *filteredUsername = [usernameSourceSignal filter:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> value) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *text = value;</div><div class="line">    <span class="keyword">return</span> text.length &gt; <span class="number">3</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[filteredUsername subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>因为<code>RACSignal</code>对象的每个操作都返回一个<code>RACSignal</code>对象，所以我们不需要使用变量就可以构建一个管道。</p>
<h2 id="事件是什么"><a href="#事件是什么" class="headerlink" title="事件是什么"></a>事件是什么</h2><p>目前为止，我们已经描述了<code>3</code>种不同的事件类型，但还没有深入这些事件的结构。有趣的是，事件可以包含任何东西。为了证明这一点，我们在上面的管道中加入另一个操作。更新我们的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.usernameTextField.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> @(text.length);</div><div class="line"> &#125;]</div><div class="line"> filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span> *length) &#123;</div><div class="line">     <span class="keyword">return</span> [length intValue] &gt; <span class="number">3</span>;</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>编译并运行，我们会发现控制台输出如下信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">47.652</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">4</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">47.819</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">5</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">47.985</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">6</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.134</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">7</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.284</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">8</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.417</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">9</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.583</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">10</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.734</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">11</span></div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">48.883</span> RWReactivePlayground[<span class="number">9321</span>:<span class="number">60</span>b] <span class="number">12</span></div></pre></td></tr></table></figure>
<p>新添加的<code>map</code>操作使用提供的<code>block</code>来转换事件数据。对于收到的每一个<code>next</code>事件，都会运行给定的<code>block</code>，并将返回值作为<code>next</code>事件发送。在上面的代码中，<code>map</code>操作获取一个<code>NSString</code>输入，并将其映射为一个<code>NSNumber</code>对象，并返回。下图演示了这个管道处理：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/FilterAndMapPipeline.png" alt="image"></p>
<p>我们可以看到，<code>map</code>操作后的每一步接收的都是一个<code>NSNumber</code>对象。我们可以使用<code>map</code>操作来转换我们想要的数据，只需要它是一个对象。</p>
<p>OK，是时候修改<code>ReactivePlayground</code>应用的代码了。</p>
<h2 id="创建有效的状态信号"><a href="#创建有效的状态信号" class="headerlink" title="创建有效的状态信号"></a>创建有效的状态信号</h2><p>我们要做的第一件事就是创建一对信号来校验用户名与密码的输入是否有效。添加如下代码到<code>RWViewController.m</code>的<code>viewDidLoad</code>中。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RACSignal *validUsernameSignal = [<span class="keyword">self</span>.usernameTextField.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> @([<span class="keyword">self</span> isValidUsername:text]);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *validPasswordSignal = [<span class="keyword">self</span>.passwordTextField.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> @([<span class="keyword">self</span> isValidPassword:text]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>我们使用将<code>map</code>操作应用于文本输入框的<code>rac_textSignal</code>，输出是一个<code>NSNumber</code>对象。接着将转换这些信号，以便其可以为文本输入框提供一个合适的背影颜色。我们可以订阅这个信号并使用其结果来更新文本输入框的颜色。可以如下操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[validPasswordSignal map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *passwordValid) &#123;</div><div class="line">    <span class="keyword">return</span> [passwordValid boolValue] ? [<span class="built_in">UIColor</span> clearColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">UIColor</span> *color) &#123;</div><div class="line">    <span class="keyword">self</span>.passwordTextField.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>从概念上讲，我们将信号的输出值赋值给文本输入框的<code>backgroundColor</code>属性。但是这段代码有点糟糕。我们可以以另外一种方式来做相同的处理。这得益于<code>ReactiveCocoa</code>定义的一些宏。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RAC(<span class="keyword">self</span>.passwordTextField, backgroundColor) = [validPasswordSignal map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *passwordValid) &#123;</div><div class="line">    <span class="keyword">return</span> [passwordValid boolValue] ? [<span class="built_in">UIColor</span> clearColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RAC(<span class="keyword">self</span>.usernameTextField, backgroundColor) = [validUsernameSignal map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *passwordValid) &#123;</div><div class="line">    <span class="keyword">return</span> [passwordValid boolValue] ? [<span class="built_in">UIColor</span> clearColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>RAC</code>宏我们将信号的输入值指派给对象的属性。它带有两个参数，第一个参数是对象，第二个参数是对象的属性名。每次信号发送下一个事件时，其输出值都会指派给给定的属性。这是个非常优雅的解决方案，对吧？</p>
<p>在运行前，我们先找到<code>updateUIState</code>方法，并注释掉下面两行代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.usernameTextField.backgroundColor = <span class="keyword">self</span>.usernameIsValid ? [<span class="built_in">UIColor</span> clearColor] : [<span class="built_in">UIColor</span> yellowColor];</div><div class="line"><span class="keyword">self</span>.passwordTextField.backgroundColor = <span class="keyword">self</span>.passwordIsValid ? [<span class="built_in">UIColor</span> clearColor] : [<span class="built_in">UIColor</span> yellowColor];</div></pre></td></tr></table></figure>
<p>运行程序，我们可以看到当输入无效时文本输入框是高亮的，有效时则清除高亮。在这里，我们可以看到两条带有文本信号的简单的管道，都是将它们映射到标明是否有效的布尔对象，然后再映射到<code>UIColor</code>对象。如下图所示：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TextFieldValidPipeline.png" alt="image"></p>
<h2 id="组合信号"><a href="#组合信号" class="headerlink" title="组合信号"></a>组合信号</h2><p>在当前的程序中，<code>Sign in</code>按钮只有在两个输入框都有效时才可点击。是时候处理这个响应了。</p>
<p>当前代码有两个信号来标识用户名和密码是否有效：<code>validUsernameSignal</code>和<code>validPasswordSignal</code>。我们的任务是要组合这两个信号，来确定按钮是否可用。</p>
<p>在<code>viewDidLoad</code>中添加下面的代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RACSignal *signUpActiveSignal = [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]</div><div class="line">                                                  reduce:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *usernameValid, <span class="built_in">NSNumber</span> *passwordValid)&#123;</div><div class="line"></div><div class="line">                                                      <span class="keyword">return</span> @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);</div><div class="line">                                                  &#125;];</div></pre></td></tr></table></figure>
<p>上面的代码使用了<code>combineLatest:reduce:</code>方法来组合<code>validUsernameSignal</code>与<code>validPasswordSignal</code>最后输出的值，并生成一个新的信号。每次两个源信号中的一个输出新值时，<code>reduce</code>块都会被执行，而返回的值会作为组合信号的下一个值。</p>
<p><em>注意：<code>RACSignal</code>组合方法可以组合任何数量的信号，而<code>reduce</code>块的参数会对应每一个信号。</em></p>
<p>现在我们已以有了一个合适的信号，接着在<code>viewDidLoad</code>结尾中添加以下代码，这将信号连接到按钮的<code>enabled</code>属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[signUpActiveSignal subscribeNext:^(<span class="built_in">NSNumber</span> *signupActive) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.signInButton.enabled = [signupActive boolValue];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>同样，在运行前移除以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> passwordIsValid;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> usernameIsValid;</div></pre></td></tr></table></figure>
<p>同时移除<code>viewDidLoad</code>中以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.usernameTextField addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(usernameTextFieldChanged) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</div><div class="line">[<span class="keyword">self</span>.passwordTextField addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(passwordTextFieldChanged) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</div></pre></td></tr></table></figure>
<p>当然我们还需要移除<code>updateUIState</code>, <code>usernameTextFieldChanged</code>和<code>passwordTextFieldChanged</code>方法及相关的调用。瞧，我们已经删除了不少代码了。感谢自己吧！</p>
<p>运行，并检查<code>Sign in</code>按钮。如同之前一下，如果用户名和密码都有效，则按钮是可用的。</p>
<p>更新后程序的逻辑如下图所示：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/CombinePipeline.png" alt="image"></p>
<p>上面我们已经用<code>ReactiveCocoa</code>实现了一些非常棒的功能，它包含了两个重要的概念：</p>
<ol>
<li><code>Spliting</code>: 信号可以有多个订阅者，且作为资源服务于序列化管道的多个步骤。</li>
<li><code>Combining</code>: 多个信号可以组合起来创建新的信号。</li>
</ol>
<p>在上面的程序中，这些改变让程序不再需要私有属性，来标明两个输入域的有效状态。这是使用响应式编程的关键区别–我们不需要使用实例变量来跟踪短暂的状态。</p>
<h2 id="响应Sign-in"><a href="#响应Sign-in" class="headerlink" title="响应Sign-in"></a>响应Sign-in</h2><p>程序目前使用了响应式管道来管理输入框与按钮的状态。按钮的点击操作仍然使用<code>target-action</code>。所以，这是我们下一步的目标。</p>
<p>Sign-in按钮的<code>Touch Up Inside</code>事件通过<code>storyboard action</code>连接到<code>RWViewController.m</code>的<code>signInButtonTouched</code>方法中。我们现在使用响应式方法来替换它，所以第一步我们需要解除当前<code>storyboard action</code>的连接。这个自己处理吧。</p>
<p>为了处理按钮事件，我们需要使用<code>ReactiveCocoa</code>添加到<code>UIKit</code>的另一个方法：<code>rac_signalForControlEvents</code>。我们在<code>viewDidLoad</code>结尾加入以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Button clicked"</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>上面的代码从按钮的<code>UIControlEventTouchUpInside</code>事件中创建一个信号，并添加订阅以在每次事件发生时添加日志。</p>
<p>运行程序，当按钮可点时点击按钮，会记录以下日志：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">43.660</span> RWReactivePlayground[<span class="number">9617</span>:<span class="number">60</span>b] Button clicked</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">44.493</span> RWReactivePlayground[<span class="number">9617</span>:<span class="number">60</span>b] Button clicked</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">44.660</span> RWReactivePlayground[<span class="number">9617</span>:<span class="number">60</span>b] Button clicked</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">44.810</span> RWReactivePlayground[<span class="number">9617</span>:<span class="number">60</span>b] Button clicked</div><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">44.944</span> RWReactivePlayground[<span class="number">9617</span>:<span class="number">60</span>b] Button clicked</div></pre></td></tr></table></figure>
<p>现在点击事件有一个信号了，接下来将信号与登录处理连接起来。打开<code>RWDummySignInService.h</code>文件，我们会看到下面的接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^RWSignInResponse)(<span class="built_in">BOOL</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWDummySignInService</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)signInWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password complete:(RWSignInResponse)completeBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个方法带有一个用户名、密码和一个完成<code>block</code>。<code>block</code>会在登录成功或失败时调用。我们可以在<code>subscribeNext:</code>块中直接调用这个方法，但为什么不呢？因为这是一个异步操作，小心了。</p>
<h2 id="创建信号"><a href="#创建信号" class="headerlink" title="创建信号"></a>创建信号</h2><p>幸运的是，将一个已存在的异步<code>API</code>表示为一个信号相当简单。我们来看看。</p>
<p>首先，从<code>RWViewController.m</code>移除当前的<code>signInButtonTouched:</code>方法。我们通过响应式编程来取代它。</p>
<p>在<code>RWViewController.m</code>中添加以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)signInSignal</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">        [<span class="keyword">self</span>.signInService signInWithUsername:<span class="keyword">self</span>.usernameTextField.text</div><div class="line">                                      password:<span class="keyword">self</span>.passwordTextField.text</div><div class="line">                                      complete:^(<span class="built_in">BOOL</span> success) &#123;</div><div class="line">                                          [subscriber sendNext:@(success)];</div><div class="line">                                          [subscriber sendCompleted];</div><div class="line">                                      &#125;];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码创建了一个使用当前用户名与密码登录的信号。现在我们来分解一下这个方法。<code>createSignal:</code>方法用于创建一个信号。描述信号的<code>block</code>是一个信号参数，当信号有一个订阅者时，<code>block</code>中的代码会被执行。</p>
<p><code>block</code>传递一个实现<code>RACSubscriber</code>协议的<code>subscriber</code>(订阅者)，这个订阅者包含我们调用的用于发送事件的方法；我们也可以发送多个<code>next</code>事件，这些事件由一个<code>error</code>事件或<code>complete</code>事件结束。在上面这种情况下，它发送一个<code>next</code>事件来表示登录是否成功，后续是一个<code>complete</code>事件。</p>
<p>这个<code>block</code>的返回类型是一个<code>RACDisposable</code>对象，它允许我们执行一些清理任务，这些操作可能发生在订阅取消或丢弃时。上面这个这个信号没有任何清理需求，所以返回<code>nil</code>。</p>
<p>可以看到，我们就这样在信号中封装了一个异步<code>API</code>。现在，我们可以使用这个新的信号了，更新<code>viewDidLoad</code>中我们的代码吧：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> signInButton];</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sign in result: %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>上面的代码使用<code>map</code>方法将按钮点击信号转换为登录信号。订阅者简单输出了结果。</p>
<p>运行程序，点击按钮，可以看到以下输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">18</span>:<span class="number">29</span>:<span class="number">27.134</span> RWReactivePlayground[<span class="number">9749</span>:<span class="number">60</span>b] Sign <span class="keyword">in</span> result: &lt;<span class="built_in">UIButton</span>: <span class="number">0x13651ed40</span>; frame = (<span class="number">192</span> <span class="number">201</span>; <span class="number">76</span> <span class="number">30</span>); opaque = <span class="literal">NO</span>; autoresize = RM+BM; layer = &lt;<span class="built_in">CALayer</span>: <span class="number">0x178224c00</span>&gt;&gt;</div></pre></td></tr></table></figure>
<p>可以看到<code>subscribeNext:</code>块传递了一个正确的信号，但结果不是登录信号。我们用图来展示这个管道操作：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/SignalOfSignals.png" alt="image"></p>
<p>当点击按钮时<code>rac_signalForControlEvents</code>发出了一个<code>next</code>事件。<code>map</code>这一步创建并返回一个登录信号，意味着接下来的管理接收一个<code>RACSignal</code>。这是我们在<code>subscribeNext:</code>中观察到的对象。</p>
<p>上面这个方案有时候称为信号的信号(<code>signal of signals</code>)，换句话说，就是一个外部信号包含一个内部信号。可以在输出信号的<code>subscribeNext:</code>块中订阅内部信号。但这会引起嵌套的麻烦。幸运的是，这是个普遍的问题，而<code>ReactiveCocoa</code>已经提供了解决方案。</p>
<h2 id="Signal-of-Signals"><a href="#Signal-of-Signals" class="headerlink" title="Signal of Signals"></a>Signal of Signals</h2><p>这个问题有解决方案是直观的，只需要使用<code>flattenMap</code>来替换<code>map</code>。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> signInSignal];</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sign in result: %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这将按钮点击事件映射到一个登录信号，但同时通过将事件从内部信号发送到外部信号，使这个过程变得扁平化。再次运行程序，我们将得到以下的输出</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-07</span><span class="number">-31</span> <span class="number">18</span>:<span class="number">46</span>:<span class="number">19.535</span> RWReactivePlayground[<span class="number">9785</span>:<span class="number">60</span>b] Sign <span class="keyword">in</span> result: <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这回对了。</p>
<p>现在管道处理得到了我们想要的结果，最后我们在<code>subscriptNext</code>中添加登录处理逻辑。使用以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> signInSignal];</div><div class="line">&#125;] subscribeNext:^(<span class="built_in">NSNumber</span> *signedIn) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">BOOL</span> success = [signedIn boolValue];</div><div class="line">    <span class="keyword">self</span>.signInFailureText.hidden = success;</div><div class="line">    <span class="keyword">if</span> (success)</div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@"signInSuccess"</span> sender:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>运行程序，我们就可以得到下面的结果了：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlaygroundStarter.jpg" alt="image"></p>
<p>不知道你是否注意到一个细节问题。当点击登录进行验证时，我们应该置灰登录按钮。这样可以阻止用户在验证的过程中再次去点击登录。那么这个逻辑添加在哪呢？改变按钮的可用状态不是个转换、过滤或其它的信号。这就是下一步要讲的。</p>
<h2 id="添加附加操作-side-effects"><a href="#添加附加操作-side-effects" class="headerlink" title="添加附加操作(side-effects)"></a>添加附加操作(side-effects)</h2><p>使用下面的代码替换当前管道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>]</div><div class="line"> doNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="keyword">self</span>.signInButton.enabled = <span class="literal">NO</span>;</div><div class="line">     <span class="keyword">self</span>.signInFailureText.hidden = <span class="literal">YES</span>;</div><div class="line"> &#125;]</div><div class="line"> flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> signInSignal];</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="built_in">NSNumber</span> *signedIn) &#123;</div><div class="line">     <span class="keyword">self</span>.signInButton.enabled = <span class="literal">YES</span>;</div><div class="line">     <span class="built_in">BOOL</span> success = [signedIn boolValue];</div><div class="line">     <span class="keyword">self</span>.signInFailureText.hidden = success;</div><div class="line">     <span class="keyword">if</span> (success) &#123;</div><div class="line">         [<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@"signInSuccess"</span> sender:<span class="keyword">self</span>];</div><div class="line">     &#125;</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>我们可以看到在按钮点击事件后添加了<code>doNext:</code>步骤。注意<code>doNext:</code>并不返回一个值，因为它是附加操作。它完成时不改变事件。下图展示了这个过程：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/SideEffects.png" alt="image"></p>
<p>运行程序看看效果。如何？</p>
<p>注意：在执行异步方法时禁用按钮是个普遍的问题，<code>ReactiveCocoa</code>同样解决了这个问题。<strong>RACCommand</strong>类封装了这个概念，同时有一个<code>enabled</code>信号以允许我们将一个按钮的<code>enabled</code>属性连接到信号。可以试试。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>ReactiveCocoa</code>的核心是信号，它是一个事件流。使用<code>ReactiveCocoa</code>时，对于同一个问题，可能会有多种不同的方法来解决。<code>ReactiveCocoa</code>的目的就是为了简化我们的代码并更容易理解。如果使用一个清晰的管道，我们可以很容易理解问题的处理过程。在下一部分，我们将会讨论错误事件的处理及完成事件的处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/08/01/core-bluetooth-programming-guide-3/" itemprop="url">
                  Core Bluetooth框架之三：最佳实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-01T23:03:22+08:00" content="2014-08-01">
              2014-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在iOS设备中使用BLE时，无论是将其作为central端还是peripheral端，其在通信时都会使用设备自身的无线电来发送信号。考虑到其它形式的无线通信也需要使用无线电，因此开发程序时应该尽量少使用无线电。另外，这对于设备电池的寿命及程序的性能也有所帮助。以此为出发点，我们将介绍一些使用BLE时的最佳实践，希望有所帮助。</p>
<h2 id="与Peripheral设备交互的最佳实践"><a href="#与Peripheral设备交互的最佳实践" class="headerlink" title="与Peripheral设备交互的最佳实践"></a>与Peripheral设备交互的最佳实践</h2><p>Core Bluetooth框架让程序的大部分Central端交互变得透明。即程序能够控制且有责任实现大部分Central端的操作，如设备搜索及连接，解析并与远程peripheral数据交互。下面我们将介绍一些Central端的最佳实践。</p>
<h3 id="留意无线电的使用及电量消耗"><a href="#留意无线电的使用及电量消耗" class="headerlink" title="留意无线电的使用及电量消耗"></a>留意无线电的使用及电量消耗</h3><h4 id="只有当需要时才扫描设备"><a href="#只有当需要时才扫描设备" class="headerlink" title="只有当需要时才扫描设备"></a>只有当需要时才扫描设备</h4><p>当调用CBCentralManager类的scanForPeripheralsWithServices:options:方法来搜索正在广告服务的peripheral设备时，central设备使用无线电来监听广告的设备，直到我们显示停止它。除非需要搜索更多的设备，否则当发现想要连接的设备时就停止扫描操作。此时可以调用CBCentralManager实例的stopScan方法来处理。</p>
<h4 id="只有当需要时才指定CBCentralManagerScanOptionAllowDuplicatesKey选项"><a href="#只有当需要时才指定CBCentralManagerScanOptionAllowDuplicatesKey选项" class="headerlink" title="只有当需要时才指定CBCentralManagerScanOptionAllowDuplicatesKey选项"></a>只有当需要时才指定CBCentralManagerScanOptionAllowDuplicatesKey选项</h4><p>远程peripheral设备可能每秒发送多个广告包来声明它们的存在。当我们使用scanForPeripheralsWithServices:options:方法扫描设备时，该方法的默认行为是将多个搜索到的广告peripheral事件归集为一个事件–即central管理器在只有在每次发现新的peripheral时都调用其代理对象的centralManager:didDiscoverPeripheral:advertisementData:RSSI:，而不管它收到多少个广告包。central管理器在已发现的peripheral改变广告的数据时也会调用这个代理方法。</p>
<p>如果想要改变默认行为，可以指定CBCentralManagerScanOptionAllowDuplicatesKey作为扫描选项。此时，central管理器会在每次收到peripheral端的广告包时都触发一个事件。在某些情况下关闭默认行为很有用处，但记住指定CBCentralManagerScanOptionAllowDuplicatesKey扫描选项不利于电池的寿命及程序性能。因此，只在需要的时候使用这个选项以完成特定的任务。</p>
<h4 id="解析peripheral数据"><a href="#解析peripheral数据" class="headerlink" title="解析peripheral数据"></a>解析peripheral数据</h4><p>一个peripheral设备可能有多个服务和特性，但在我们的应用中，可能只对其中一些感兴趣。搜索peripheral设备的所有服务和特性可能不利于电池的寿命及程序性能。因此，我们只去搜索那些与我们的的应用相关的服务和特性。</p>
<p>例如，假设我们正在连接一个有很多可用服务的peripheral设备，但是我们的程序只需要访问其中两个。我们可以只查找这两个服务，即在调用CBPeripheral对象的discoverServices:方法时传入感兴趣服务的UUID的数组即可。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[peripheral discoverServices:@[firstServiceUUID, secondServiceUUID]];</div></pre></td></tr></table></figure>
<p>在搜索到这两个感兴趣的服务后，我们可以用类似的方法去搜索我们感兴趣的服务中的特性。此时调用CBPeripheral实例的discoverCharacteristics:forService:方法并传入特性UUID的数组。</p>
<h4 id="订阅经常改变的特性值"><a href="#订阅经常改变的特性值" class="headerlink" title="订阅经常改变的特性值"></a>订阅经常改变的特性值</h4><p>我们可以通过两种方式获取特性的值：</p>
<ol>
<li>在我们每次需要值时调用readValueForCharacteristic:方法来显示的轮循特性的值</li>
<li>调用setNotifyValue:forCharacteristic:方法来订阅特性的值，这样当值改变时我们可以收到来自于peripheral的通知。</li>
</ol>
<p>通常最好是去订阅特性的值，特别是特性值经常改变时。</p>
<h4 id="当获取到所有需要的数据时断开到设备的连接"><a href="#当获取到所有需要的数据时断开到设备的连接" class="headerlink" title="当获取到所有需要的数据时断开到设备的连接"></a>当获取到所有需要的数据时断开到设备的连接</h4><p>当连接不再需要时，我们可以断开连接，以减少无线电的使用。在下面两种情况下，我们应该断开连接：</p>
<ol>
<li>所有订阅的特性值已经停止发送通知(我们可以访问特性的isNotifying属性来查看属性值是否正在被通知)</li>
<li>我们已以获取来来自peripheral设备的全部值。</li>
</ol>
<p>两种情况下，取自我们有的所有订阅并断开连接。我们通过调用setNotifyValue:forCharacteristic:方法并设置第一个参数为NO来取消订阅。同时调用CBCentralManager实例的cancelPeripheralConnection:方法来断开连接。注意这个cancelPeripheralConnection:方法是非阻塞的，如果我们尝试断开连接的peripheral设备仍然挂起，则CBPeripheral实例的命令可能完成执行，也可能没有。因为其它程序可能也连接着那个peripheral设备。取消一个本地连接不能保证底层物理链接会立即断开。</p>
<h3 id="重新链接Peripheral"><a href="#重新链接Peripheral" class="headerlink" title="重新链接Peripheral"></a>重新链接Peripheral</h3><p>使用Core Bluetooth框架，有三种方式来重新连接peripheral设备：</p>
<ol>
<li>使用retrievePeripheralsWithIdentifiers:方法获取已知peripheral设备的列表，这些设备是我们已经搜索并连接过的设备。如果我们查找的peripheral在列表中，则尝试重新连接。</li>
<li>使用retrieveConnectedPeripheralsWithServices:方法获取当前连接到系统的peripheral设备的列表。如果我们查找的peripheral设备在列表中，则连接它。</li>
<li>使用scanForPeripheralsWithServices:options:方法扫描并搜索peripheral设备。如果找到，则连接它。</li>
</ol>
<p>根据使用的场景，我们可能不希望每次重新连接设备时，都去扫描并搜索设备。相反，我们可能想首先使用其它方式来重新连接。如下图所示，一个可能的重新连接操作流是按照上面列出来的方式去重新连接：</p>
<h4 id="获取已知peripheral设备的列表"><a href="#获取已知peripheral设备的列表" class="headerlink" title="获取已知peripheral设备的列表"></a>获取已知peripheral设备的列表</h4><p>我们第一次发现一个peripheral设备时，系统生成一个标识符(NSUUID对象)来标识peripheral设备。我们可以存储这些设备，后续我们可以使用CBCentralManager实例的retrievePeripheralsWithIdentifiers:方法来重新连接这个peripheral设备。</p>
<p>当我们启动程序时，调用retrievePeripheralsWithIdentifiers:方法，传递一个我们先前搜索并连接过的peripheral设备的标识符的数组，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">knownPeripherals = [myCentralManager retrievePeripheralsWithIdentifiers:savedIdentifiers];</div></pre></td></tr></table></figure>
<p>central管理器尝试在这个列表中匹配我们提供的标识符，并返回一个CBPeripheral对象的数组。如果没找到，则返回的数组为空，那么我们需要尝试另外两种方法。如果返回的数组不为空，则让用户选择连接哪一个peripheral设备。当用户选择后，调用CBCentralManager实例的connectPeripheral:options:方法来尝试连接。如果peripheral设备仍然可以连接，则central管理器调用代理对象的centralManager:didConnectPeripheral:方法，且成功连接上peripheral设备。</p>
<h4 id="获取已连接peripheral设备的列表"><a href="#获取已连接peripheral设备的列表" class="headerlink" title="获取已连接peripheral设备的列表"></a>获取已连接peripheral设备的列表</h4><p>另一种重新连接peripheral设备的方法是查看我们正在查找的设备是否正由系统连接着(如被其它程序连接着)。我们可以调用CBCentralManager实例的retrieveConnectedPeripheralsWithServices:方法，它返回一个表示当前系统正在连接着的peripheral设备的CBPeripheral对象的数组。</p>
<p>因为可以有多于一个peripheral设备正在连接着系统，我们可以传递一个CBUUID对象的数组来获取只包含指定UUID所标识服务的设备。如果当前系统没有连接任何peripheral设备，则返回数组为空，我们应该尝试其它两种方法。如果返回数组不为空，则让用户选择连接哪个设备。</p>
<p>假设用户找到并选择了需要的peripheral设备，则调用CBCentralManager实例的connectPeripheral:options:方法来连接它(即使系统已经连接了它，我们的程序仍然需要连接它以开始解析并交互数据)。当连接建立后，central管理器调用代理对象的centralManager:didConnectPeripheral:方法，然后成功连接peripheral设备。</p>
<h2 id="将本地设备设置为peripheral设备的最佳实践"><a href="#将本地设备设置为peripheral设备的最佳实践" class="headerlink" title="将本地设备设置为peripheral设备的最佳实践"></a>将本地设备设置为peripheral设备的最佳实践</h2><h3 id="广告注意事项"><a href="#广告注意事项" class="headerlink" title="广告注意事项"></a>广告注意事项</h3><p>在设置本地设备作为peripheral端时，广告peripheral数据是非常重要的一部分。我们下面将介绍一下如何以适当的方式来实现这一功能。</p>
<p>我们广告peripheral数据时，是将其放在一个字典中传递给CBPeripheralManager对象的startAdvertising:方法中。当创建一个广告字典时，需要知道我们可以广告什么及能广告多少数据。</p>
<p>虽然广告数据包通常可以放置关于peripheral设备的多种信息，但建议只放置设备的本地名及我们需要广告的服务的UUID。即，当创建广告字典时，可能只指定下面两个键：CBAdvertisementDataLocalNameKey和CBAdvertisementDataServiceUUIDsKey。如果指定其它键，则会收到一个错误。</p>
<p>同样，广告数据时也限定了可以使用多少空间。当程序在前台时，可广告的数据对于上述两个key值的任意组合来说，初始值不能超过28个字节。如果这个空间用完了，在扫描响应时可以有额外的10个字节的空间，但这只能用于本地名。任何超出的数据都会被放到一个指定的“溢出”区域；它们只能被显示扫描它们的iOS设备发现。当程序在后台时，本地名不能被广告，且所有的服务UUID都被放在溢出区域。</p>
<p>为了符合这此限制条件，我们需要将广告的服务UUID限制在主要服务的标识上。</p>
<p>另外，因为广告peripheral数据使用本地设备的无线电，所以只在需要其它设备连接的时候广告数据。一旦连接后，这些设备可以直接解析并交互数据，而不需要任何广告包。因此，为了减少无线电的使用、提高程序的性能及节省电量，当不再需要任何试图进行BLE交易时可以停止广告。为了停止本地peripheral，可以调用CBPeripheralManager对象的stopAdvertising方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[myPeripheralManager stopAdvertising];</div></pre></td></tr></table></figure>
<p>通常，只有用户才知道什么时候广告数据。例如，当我们知道没有任何BLE设备在附近时，在我们的设备上广告服务没有任何意义。因为我们的程序通常不知道是否有其它设备在附近，所以提供一个界面让用户来决定什么时候广告数据。</p>
<h3 id="配置特性"><a href="#配置特性" class="headerlink" title="配置特性"></a>配置特性</h3><p>当创建一个可变的特性时，我们设置它的属性、值和权限。这些设置决定了如何连接central访问及交互特性值。虽然我们可能基于程序的需求来配置特性的属性和权限，但当执行下面两种任务时，我们还是有章可循的</p>
<ol>
<li>允许连接的central订阅属性</li>
<li>保护敏感特性值，不让其被未配对的central访问</li>
</ol>
<p>对于这两种情况，首先我们配置特性以支持通知。通常建议central去订阅那些经常改变的特性值。当我们创建一个可变特性时，可以通过使用CBCharacteristicPropertyNotify常量来设置特性属性以支持订阅，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myCharacteristic = [[CBMutableCharacteristic alloc] initWithType:myCharacteristicUUID properties:CBCharacteristicPropertyRead | CBCharacteristicPropertyNotify value:<span class="literal">nil</span> permissions:CBAttributePermissionsReadable];</div></pre></td></tr></table></figure>
<p>在这个例子中，特性值是可读的，且可以被连接的central端订阅。</p>
<p>其它，要求配对的连接才能访问敏感数据。根据场景的不同，我们可能想要提供一个服务，这个服务有一个或多个需要加密值的特性。例如，假设我们想要提供一个社交媒体配置文件服务。这个服务有一些特性，它们的值表示成员的配置信息，如姓名、电子邮件地址。更可能的是，我们只允许受信任的设备来获取成员的电子邮件地址。</p>
<p>我们可以设置合适的特性属性及权限来确保只有受信任的设备可以访问敏感的特性值。继续上面的例子，为了只允许受信任的设备来获取成员的邮箱地址，可以如下设置合适的特性属性与权限：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emailCharacteristic = [[CBMutableCharacteristic alloc] initWithType:emailCharacteristicUUID properties:CBCharacteristicPropertyRead | CBCharacteristicPropertyNotifyEncryptionRequired value:<span class="literal">nil</span> permissions:CBAttributePermissionsReadEncryptionRequired];</div></pre></td></tr></table></figure>
<p>在这个例子中，特性配置为只有受信任的设备才可以读取或订阅它的值。当一个连接的central尝试读取或订阅特性值时，Core Bluetooth尝试配对本地peripheral和central端来创建安全连接。</p>
<p>例如，如果central和peripheral都是iOS设备，两端都接收一个提示显示对方想要配对。central设备上的提示包含包含一个确认码，这个确认码必须在peripheral设备提示框的输入域中输入，来完成配对操作。</p>
<p>在配对成功后，peripheral认为配对的central是一个受信任的设备且允许central访问它的加密特性值。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在使用BLE时，基于以下几点，程序开发过程中我们合理地使用蓝牙</p>
<ol>
<li>程序性能</li>
<li>电池电量消耗</li>
<li>与其它通信方法争抢无线电资源</li>
</ol>
<p>通常我们只在需要时才使用BLE，尽量减少设备扫描搜索操作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html" target="_blank" rel="external">Core Bluetooth Programming Guide</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/31/core-bluetooth-programming-guide-2/" itemprop="url">
                  Core Bluetooth框架之二：后台处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-31T23:28:24+08:00" content="2014-07-31">
              2014-07-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在开发BLE相关应用时，由于应用在后台时会有诸多资源限制，需要考虑应用的后台处理问题。默认情况下，当程序位于后台或挂起时，大多数普通的Core Bluetooth任务都无法使用，不管是Central端还是Peripheral端。但我们可以声明我们的应用支持Core Bluetooth后台执行模式，以允许程序从挂起状态中被唤醒以处理蓝牙相关的事件。</p>
<p>然而，即使我们的应用支持两端的Core Bluetooth后台执行模式，它也不能一直运行。在某些情况下，系统可能会关闭我们的应用来释放内存，以为当前前台的应用提供更多的内存空间。在iOS7及后续版本中，Core Bluetooth支持保存Central及Peripheral管理器对象的状态信息，并在程序启动时恢复这些信息。我们可以使用这个特性来支持与蓝牙设备相关的长时间任务。</p>
<p>下面我们将详细讨论下这些问题。</p>
<h2 id="只支持前台操作-Foreground-Only-的应用"><a href="#只支持前台操作-Foreground-Only-的应用" class="headerlink" title="只支持前台操作(Foreground-Only)的应用"></a>只支持前台操作(Foreground-Only)的应用</h2><p>大多数应用在进入到后台后都会在短时间内进入挂起状态，除非我们请求执行一些特定的后台任务。当处理挂起状态时，我们的应用无法继续执行蓝牙相关的任务。</p>
<p>在Central端，Foreground-Only应用在进入后台或挂起时，无法继续扫描并发现下在广告的Peripheral设备。而在Peripheral端，无法广告自身，同时Central端对其的任何访问操作都会返回一个错误。</p>
<p>Foreground-Only应用挂起时，所有蓝牙相关的事件都会被系统放入一个队列，当应用进入前台后，系统会将这些事件发送给我们的应用。也就是说，当某些事件发生时，Core Bluetooth提供了一种方法来提示用户。用户可以使用这些提示来决定是否将应用放到前台。在《Core Bluetooth框架之一：Central与Peripheral》中我们介绍了connectPeripheral:options:方法，在调用这个方法时，我们可以设备options参数来设置这些提示：</p>
<ol>
<li>CBConnectPeripheralOptionNotifyOnConnectionKey：当应用挂起时，如果有一个连接成功时，如果我们想要系统为指定的peripheral显示一个提示时，就使用这个key值。</li>
<li>CBConnectPeripheralOptionNotifyOnDisconnectionKey：当应用挂起时，如果连接断开时，如果我们想要系统为指定的peripheral显示一个断开连接的提示时，就使用这个key值。</li>
<li>CBConnectPeripheralOptionNotifyOnNotificationKey：当应用挂起时，使用该key值表示只要接收到给定peripheral端的通知就显示一个提示。</li>
</ol>
<h2 id="Core-Bluetooth后台执行模式"><a href="#Core-Bluetooth后台执行模式" class="headerlink" title="Core Bluetooth后台执行模式"></a>Core Bluetooth后台执行模式</h2><p>我们可以在Info.plist文件中设置Core Bluetooth后台执行模式，以让应用支持在后台执行一些蓝牙相关的任务。当应用声明了这一功能时，系统会将应用唤醒以允许它处理蓝牙相关的任务。这个特性对于与那种定时发送数据的BLE交互的应用非常有用。</p>
<p>有两种Core Bluetooth后台执行模式，一种用于实现Central端操作，一种用于实现Peripheral端操作。如果我们的应用同时实现了这两端的功能，则需要声明同时支持两种模式。我们需要在Info.plist文件添加UIBackgroundModes键，同时添加以下两个值或其中之一：</p>
<ol>
<li>bluetooth-central(App communicates using CoreBluetooth)</li>
<li>bluetooth-peripheral(App shares data using CoreBluetooth)</li>
</ol>
<h3 id="bluetooth-central模式"><a href="#bluetooth-central模式" class="headerlink" title="bluetooth-central模式"></a>bluetooth-central模式</h3><p>如果设置了bluetooth-central值，则我们的应用在后台时，仍然可以查找并连接到Peripheral设备，以及查找相应数据。另外，系统会在CBCentralManagerDelegate或CBPeripheralDelegate代理方法被调用时唤醒我们的应用，允许应用处理事件，如建立连接或断开连接等等。</p>
<p>虽然应用在后台时，我们可以执行很多蓝牙相关任务，但需要记住应用在前后台扫描Peripheral设备时还是不一样的。当我们的应用在后台扫描Peripheral设备时，</p>
<ol>
<li>CBCentralManagerScanOptionAllowDuplicatesKey扫描选项会被忽略，同一个Peripheral端的多个发现事件会被聚合成一个发现事件。</li>
<li>如果扫描Peripheral设备的多个应用都在后台，则Central设备扫描广告数据的时间间隔会增加。结果是发现一个广告的Peripheral设备可能需要很长时间。</li>
</ol>
<p>这些处理在iOS设备中最小化无线电的使用及改善电池的使用寿命非常有用。</p>
<h3 id="bluetooth-peripheral模式"><a href="#bluetooth-peripheral模式" class="headerlink" title="bluetooth-peripheral模式"></a>bluetooth-peripheral模式</h3><p>如果设置了bluetooth-peripheral值，则我们的应用在后台时，应用会被唤醒以处理来自于连接的Central端的读、写及订阅请求，Core Bluetooth还允许我们在后台进行广告。与Central端类似，也需要注意前后台的操作区别。特别是在广告时，有以下几点区别：</p>
<ol>
<li>CBAdvertisementDataLocalNameKey广告key值会被忽略，Peripheral端的本地名不会被广告</li>
<li>CBAdvertisementDataServiceUUIDsKey键的所有服务的UUID都被放在一个”overflow”区域中，它们只能被那些显示要扫描它们的网络设备发现。</li>
<li>如果多个应用在后台广告，则Peripheral设备发送广告包的时间间隔会变长。</li>
</ol>
<h2 id="在后台执行长-Long-Term-任务"><a href="#在后台执行长-Long-Term-任务" class="headerlink" title="在后台执行长(Long-Term)任务"></a>在后台执行长(Long-Term)任务</h2><p>虽然建议尽快完成后台任务，但有些应该仍然需要使用Core Bluetooth来执行一个长任务。这时就涉及到状态的保存与恢复操作。</p>
<h3 id="状态保存与恢复"><a href="#状态保存与恢复" class="headerlink" title="状态保存与恢复"></a>状态保存与恢复</h3><p>因为状态保存与恢复是内置于Core Bluetooth的，我们的程序可以选择这个特性，让系统保存Central和Peripheral管理器的状态并继续执行一些蓝牙相关的任务，即使此时程序不再运行。当这些任务中的一个完成时，系统会在后台重启程序，程序可以恢复先前的状态以处理事件。Core Bluetooth支持Central端、Peripheral端的状态保存与恢复，也可以同时支持两者。</p>
<p>在Central端，系统会在关闭程序释放内存时保存Central管理器对象的状态(如果有多个Central管理器，我们可以选择系统跟踪哪个管理器)。对于给定的CBCentralManager对象，系统会跟踪如下信息：</p>
<ol>
<li>Central管理器扫描的服务</li>
<li>Central管理器尝试或已经连接的Peripheral</li>
<li>Central管理器订阅的特性</li>
</ol>
<p>在Peripheral端，对于给定的CBPeripheralManager对象，系统会跟踪以下信息：</p>
<ol>
<li>Peripheral管理器广告的数据</li>
<li>Peripheral管理器发布到设备数据库的服务和特性</li>
<li>订阅Peripheral管理器的特性值的Central端</li>
</ol>
<p>当系统将程序重启到后台后，我们可以重新重新初始化我们程序的Central和Peripheral管理器并恢复状态。我们接下来将详细介绍一下如何使用状态保存与恢复。</p>
<h3 id="添加状态保存和恢复支持"><a href="#添加状态保存和恢复支持" class="headerlink" title="添加状态保存和恢复支持"></a>添加状态保存和恢复支持</h3><p>Core Bluetooth中的状态保存与恢复是可选的特性，需要程序的支持才能工作。我们可以按照以下步骤来添加这一特性的支持：</p>
<ol>
<li>(必要步骤)当分配及初始化Central或Peripheral管理器对象时，选择性加入状态保存与恢复。</li>
<li>(必要步骤)在系统重启程序时，重新初始化Central或Peripheral管理器对象</li>
<li>(必要步骤)实现适当的恢复代理方法</li>
<li>(可选步骤)更新Central或Peripheral管理器初始化过程</li>
</ol>
<h4 id="选择性加入状态保存与恢复"><a href="#选择性加入状态保存与恢复" class="headerlink" title="选择性加入状态保存与恢复"></a>选择性加入状态保存与恢复</h4><p>为了选择性加入状态保存与恢复特性，在分配及初始化Central或Peripheral管理器时提供一个一个唯一恢复标识。<strong>恢复标识</strong>是一个字条串，用来让Core Bluetooth和程序标识Central或Peripheral管理器。字符串的值只在自己的代码中有意义，但这个字符串告诉Core Bluetooth我们需要保存对象的状态。Core Bluetooth只保存那些有恢复标识的对象。</p>
<p>例如，在实现Central端时，为了选择性加入状态保存与恢复特性，在初始化CBCentralManager对象时，可以指定初始化选项CBCentralManagerOptionRestoreIdentifierKey，并提供一个恢复标识，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">centralManager = [[CBCentralManager alloc] initWithDelegate:<span class="keyword">self</span> queue:<span class="literal">nil</span> options:@&#123;CBCentralManagerOptionRestoreIdentifierKey: <span class="string">@"restoreIdentifier"</span>&#125;];</div></pre></td></tr></table></figure>
<p>实现Peripheral端时的操作也类似，只不过我们使用选项CBPeripheralManagerOptionRestoreIdentifierKey键。</p>
<p>因为程序可以有多个Central或Peripheral管理器，所以需要确保恢复标识是唯一的，这样系统可以区分这些管理器对象。</p>
<h4 id="重新初始化Central或Peripheral管理器对象"><a href="#重新初始化Central或Peripheral管理器对象" class="headerlink" title="重新初始化Central或Peripheral管理器对象"></a>重新初始化Central或Peripheral管理器对象</h4><p>当系统重启程序到后台后，我们所需要做的第一件事就是使用恢复标识来重新初始化这些对象。如果我们的应用只有一个Central管理器或Peripheral管理器，且管理器在程序的整个生命周期都存在，则后续我们便不需要再做更多的处理。但如果我们有多个管理器，或者管理器不是存在于程序的整个生命周期，则系统重启应用时，我们需要知道重新初始化哪一个管理器。我们可以通过在程序代理对象的application:didFinishLaunchingWithOptions:方法中，使用合适的启动选项键来访问管理器对象的列表(这个列表是程序关闭是系统为程序保存的)。</p>
<p>下面代码展示了程序重新启动时，我们获取所有Central管理器对象的恢复标识:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Override point for customization after application launch.</span></div><div class="line">    </div><div class="line">    <span class="built_in">NSArray</span> *centralManagerIdentifiers = launchOptions[<span class="built_in">UIApplicationLaunchOptionsBluetoothCentralsKey</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> ...</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了这个恢复标识的列表后，我们就可以重新初始化我们所需要的管理器对象了。</p>
<h4 id="实现适当的恢复代理方法"><a href="#实现适当的恢复代理方法" class="headerlink" title="实现适当的恢复代理方法"></a>实现适当的恢复代理方法</h4><p>重新初始化Central或Peripheral管理器对象后，我们通过使用蓝牙系统的状态同步这些对象的状态来恢复它们。此时，我们需要实现一些恢复代理方法。对于Central管理器，我们实现centralManager:willRestoreState:代理方法；对于Peripheral管理器管理器，我们实现peripheralManager:willRestoreState:代理方法。</p>
<p><em>对于选择性加入保存与恢复特性的应用来说，这些方法是程序启动到后台以完成一些蓝牙相关任务所调用的第一个方法。而对于非选择性加入特性的应用来说，会首先调用centralManagerDidUpdateState:和peripheralManagerDidUpdateState:代理方法。</em></p>
<p>在上述两个代理方法中，最后一个参数是一个字典，包含程序关闭时保存的关于管理器的信息。如下代码所示，我们可以使用CBCentralManagerRestoredStatePeripheralsKey键来获取Central管理器已连接的或尝试连接的所有Peripheral设备的列表:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central willRestoreState:(<span class="built_in">NSDictionary</span> *)state</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span> *peripherals = state[CBCentralManagerRestoredStatePeripheralsKey];</div><div class="line">    </div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取到这个列表后，我们便可以根据需要来做处理。</p>
<h4 id="更新初始化过程"><a href="#更新初始化过程" class="headerlink" title="更新初始化过程"></a>更新初始化过程</h4><p>在实现了前面的三个步骤后，我们可能想更新我们的管理器的初始化过程。虽然这一步是可选的，但如果要确认任务是否运行正常时，非常有用。例如，我们的程序可能在解析所连接的Peripheral设备的数据的过程中被关闭。当程序使用这个Peripheral设备作恢复操作时，无法知道数据处理到哪了。我们需要确保程序从数据操作停止的位置继续开始操作。</p>
<p>又如下面的代码展示了在centralManagerDidUpdateState:代理方法中初始化程序操作时，我们可以找出是否成功发现了被恢复的Peripheral设备的指定服务：</p>
<pre><code class="objc"><span class="built_in">NSUInteger</span> serviceUUIDIndex = [peripheral.services indexOfObjectPassingTest:^<span class="built_in">BOOL</span>(CBService *obj, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) {
        <span class="keyword">return</span> [obj.UUID isEqual:myServiceUUIDString];
    }];


    <span class="keyword">if</span> (serviceUUIDIndex == <span class="built_in">NSNotFound</span>) {
        [peripheral discoverServices:@[myServiceUUIDString]];
        ...
}
</code></pre>
<p>如上例所述，如果系统在程序完成搜索服务时关闭了应用，则通过调用discoverServices:方法在关闭的那个点开始解析恢复的Peripheral数据。如果程序成功搜索到服务，我们可以确认是否搜索到正确的特性。通过更新初始化过程，我们可以确保在正确的时间调用正确的方法。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然我们可能需要声明应用支持Core Bluetooth后台执行模式，以完成特定的任务，但总是应该慎重考虑执行后台操作。因为执行太多的蓝牙相关任务需要使用iOS设备的内置无线电，而无线电的使用会影响到电池的寿命，所以尽量减少在后台执行的任务。任何会被蓝牙相关任务唤醒的应用应该尽快处理任务并在完成时重新挂起。</p>
<p>下面是一些基础的准则：</p>
<ol>
<li>应用应该是基于会话的，并提供接口以允许用户决定什么时候开始及结束蓝牙相关事件的分发。</li>
<li>一旦被唤醒，一个应用大概有10s的时间来完成任务。理想情况下，应用应该尽快完成任务并重新挂起。系统可以对执行时间太长的后台任务进行限流甚至杀死。</li>
<li>应用被唤醒时，不应该执行一些无关紧要的操作。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html" target="_blank" rel="external">Core Bluetooth Programming Guide</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/29/core-bluetooth-programming-guide-1/" itemprop="url">
                  Core Bluetooth框架之一：Central与Peripheral
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-29T21:52:48+08:00" content="2014-07-29">
              2014-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS和Mac应用使用Core Bluetooth framework来与BLE(低功耗蓝牙)设备通信。我们的程序可以发现、搜索并与低功耗外围(Peripheral)蓝牙设备通信，如心跳监听器、数字温控器、甚至是其它iOS设备。这个框架抽象了支持蓝牙4.0标准低功耗设备的基本操作，隐藏了4.0标准的底层实现细节，让我们可以方便的使用BLE设备。</p>
<h2 id="蓝牙通信中的角色"><a href="#蓝牙通信中的角色" class="headerlink" title="蓝牙通信中的角色"></a>蓝牙通信中的角色</h2><p>在BLE通信中，主要有两个角色：Central和Peripheral。类似于传统的客户端-服务端架构，一个Peripheral端是提供数据的一方(相当于服务端)；而Central是使用Peripheral端提供的数据完成特定任务的一方(相当于客户端)。下图以心跳监听器为例展示了这样一个架构：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBDevices1_2x.png" alt="image"></p>
<p>Peripheral端以广告包的形式来广播一些数据。一个广告包(advertising packet)是一小束相关数据，可能包含Peripheral提供的有用的信息，如Peripheral名或主要功能。在BLE下，广告是Peripheral设备表现的主要形式。</p>
<p>Central端可以扫描并监听其感兴趣的任何广播信息的Peripheral设备。</p>
<p>数据的广播及接收需要以一定的数据结构来表示。而服务就是这样一种数据结构。Peripheral端可能包含一个或多个服务或提供关于连接信号强度的有用信息。一个服务是一个设备的数据的集合及数据相关的操作。</p>
<p>而服务本身又是由特性或所包含的服务组成的。一个特性提供了关于服务的更详细的信息。下图展示了心率监听器中的各种数据结构</p>
<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBPeripheralData_Example_2x.png" alt="image"></p>
<p>在一个Central端与Peripheral端成功建立连接后，Central可以发现Peripheral端提供的完整的服务及特性的集合。一个Central也可以读写Peripheral端的服务特性的值。我们将会在下面详细介绍。</p>
<h2 id="Central、Peripherals及Peripheral数据的表示"><a href="#Central、Peripherals及Peripheral数据的表示" class="headerlink" title="Central、Peripherals及Peripheral数据的表示"></a>Central、Peripherals及Peripheral数据的表示</h2><p>当我们使用本地Central与Peripheral端交互时，我们会在BLE通信的Central端执行操作。除非我们设置了一个本地Peripheral设备，否则大部分蓝牙交互都是在Central端进行的。(下文也会讲Peripheral端的基本操作)</p>
<p>在Central端，本地Central设备由CBCentralManager对象表示。这个对象用于管理发现与连接Peripheral设备(CBPeripheral对象)的操作，包括扫描、查找和连接。下图本地Central端与peripheral对象</p>
<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBObjects_CentralSide_2x.png" alt="image"></p>
<p>当与peripheral设备交互时，我们主要是在处理它的服务及特性。在Core Bluetooth框架中，服务是一个CBService对象，特性是一个CBCharacteristic对象，下图演示了Central端的服务与特性的基本结构：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/TreeOfServicesAndCharacteristics_Remote_2x.png" alt="image"></p>
<p>苹果在OS X 10.9和iOS 6版本后，提供了BLE外设(Peripheral)功能，可以将设备作为Peripheral来处理。在Peripheral端，本地Peripheral设备表示为一个CBPeripheralManager对象。这些对象用于管理将服务及特性发布到本地Peripheral设备数据库，并广告这些服务给Central设备。Peripheral管理器也用于响应来自Central端的读写请求。如下图展示了一个Peripheral端角色：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBObjects_PeripheralSide_2x.png" alt="image"></p>
<p>当在本地Peripheral设备上设置数据时，我们实际上处理的是服务与特性的可变版本。在Core Bluetooth框架中，本地Peripheral服务由CBMutableService对象表示，而特性由CBMutableCharacteristic对象表示，下图展示了本地Peripheral端服务与特性的基本结构：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/TreeOfServicesAndCharacteristics_Local_2x.png" alt="image"></p>
<h2 id="Peripheral-Server-端操作"><a href="#Peripheral-Server-端操作" class="headerlink" title="Peripheral(Server)端操作"></a>Peripheral(Server)端操作</h2><p>一个Peripheral端操作主要有以下步骤：</p>
<ol>
<li>启动一个Peripheral管理对象</li>
<li>在本地Peripheral中设置服务及特性</li>
<li>将服务及特性发布给设备的本地数据库</li>
<li>广告我们的服务</li>
<li>针对连接的Central端的读写请求作出响应</li>
<li>发送更新的特性值到订阅Central端</li>
</ol>
<p>我们将在下面结合代码对每一步分别进行讲解</p>
<h3 id="启动一个Peripheral管理器"><a href="#启动一个Peripheral管理器" class="headerlink" title="启动一个Peripheral管理器"></a>启动一个Peripheral管理器</h3><p>要在本地设备上实现一个Peripheral端，我们需要分配并初始化一个Peripheral管理器实例，如下代码所示</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个Peripheral管理器</span></div><div class="line"><span class="comment">// 我们将当前类作为peripheralManager，因此必须实现CBPeripheralManagerDelegate</span></div><div class="line"><span class="comment">// 第二个参数如果指定为nil，则默认使用主队列</span></div><div class="line">peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:<span class="keyword">self</span> queue:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>创建Peripheral管理器后，Peripheral管理器会调用代理对象的peripheralManagerDidUpdateState:方法。我们需要实现这个方法来确保本地设备支持BLE。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Peripheral Manager Did Update State"</span>);</div><div class="line">    <span class="keyword">switch</span> (peripheral.state) &#123;</div><div class="line">        <span class="keyword">case</span> CBPeripheralManagerStatePoweredOn:</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"CBPeripheralManagerStatePoweredOn"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> CBPeripheralManagerStatePoweredOff:</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"CBPeripheralManagerStatePoweredOff"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> CBPeripheralManagerStateUnsupported:</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"CBPeripheralManagerStateUnsupported"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="设置服务及特性"><a href="#设置服务及特性" class="headerlink" title="设置服务及特性"></a>设置服务及特性</h3><p>一个本地Peripheral数据库以类似树的结构来组织服务及特性。所以，在设置服务及特性时，我们将其组织成树结构。</p>
<p>一个Peripheral的服务和特性通过128位的蓝牙指定的UUID来标识，该标识是一个CBUUID对象。虽然SIG组织没的预先定义所有的服务与特性的UUID，但是SIG已经定义并发布了一些通过的UUID，这些UUID被简化成16位以方便使用。例如，SIG定义了一个16位的UUID作为心跳服务的标识(180D)。</p>
<p>CBUUID类提供了方法，以从字符串中生成一个CBUUID对象。当字条串使用的是预定义的16位UUID时，Core Bluetooth使用它时会预先自动补全成128位的标识。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CBUUID *heartRateServiceUUID = [CBUUID UUIDWithString:<span class="string">@"180D"</span>];</div></pre></td></tr></table></figure>
<p>当然我们也可以自己生成一个128位的UUID来标识我们的服务与特性。在命令行中使用uuidgen命令会生成一个128位的UUID字符串，然后我们可以使用它来生成一个CBUUID对象。</p>
<p>生成UUID对象后，我们就可以用这个对象来创建我们的服务及特性，然后再将它们组织成树状结构。</p>
<p>创建特性的代码如下所示</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CBUUID *characteristicUUID1 = [CBUUID UUIDWithString:<span class="string">@"C22D1ECA-0F78-463B-8C21-688A517D7D2B"</span>];</div><div class="line">CBUUID *characteristicUUID2 = [CBUUID UUIDWithString:<span class="string">@"632FB3C9-2078-419B-83AA-DBC64B5B685A"</span>];</div><div class="line">    </div><div class="line">CBMutableCharacteristic *character1 = [[CBMutableCharacteristic alloc] initWithType:characteristicUUID1 properties:CBCharacteristicPropertyRead value:<span class="literal">nil</span> permissions:CBAttributePermissionsReadable];</div><div class="line">    </div><div class="line">CBMutableCharacteristic *character2 = [[CBMutableCharacteristic alloc] initWithType:characteristicUUID2 properties:CBCharacteristicPropertyNotify value:<span class="literal">nil</span> permissions:CBAttributePermissionsWriteable];</div></pre></td></tr></table></figure>
<p>我们需要设置特性的属性、值及权限。属性及权限值确定了属性值是可读的还是可写的，及连接的Central端是否可以订阅特性的值。另外，如果我们指定了特性的值，则这个值会被缓存且其属性及权限被设置成可读的。如果我们要让特性的值是可写的，或者期望属性所属的服务的生命周期里这个值可以被修改，则必须指定值为nil。</p>
<p>创建的特性之后，我们便可以创建一个与特性相关的服务，然后将特性关联到服务上，如下代码所示:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CBUUID *serviceUUID = [CBUUID UUIDWithString:<span class="string">@"3655296F-96CE-44D4-912D-CD83F06E7E7E"</span>];</div><div class="line">CBMutableService *service = [[CBMutableService alloc] initWithType:serviceUUID primary:<span class="literal">YES</span>];</div><div class="line">service.characteristics = @[character1, character2];    <span class="comment">// 组织成树状结构</span></div></pre></td></tr></table></figure>
<p>上例中primary参数传递的是YES，表示这是一个主服务，即描述了一个设备的主要功能且能被其它服务引用。与之相对的是次要服务(secondary service)，其只在引用它的另一个服务的上下文中描述一个服务。</p>
<h3 id="发布服务及特性"><a href="#发布服务及特性" class="headerlink" title="发布服务及特性"></a>发布服务及特性</h3><p>创建服务及特性后交将其组织成树状结构后，我们需要将这些服务发布到设备的本地数据库上。我们可以使用CBPeripheralManager的addService:方法来完成此工作。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[peripheralManager addService:service];</div></pre></td></tr></table></figure>
<p>在调用些方法发布服务时，CBPeripheralManager对象会调用它的代理的peripheralManager:didAddService:error:方法。如果发布过程中出现错误导致无法以布，则可以实现该代理方法来处理错误，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(<span class="built_in">NSError</span> *)error</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Add Service"</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (error)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error publishing service: %@"</span>, [error localizedDescription]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在将服务与特性发布到设备数据库后，服务将会被缓存，且我们不能再修改这个服务。</p>
<h3 id="广告服务"><a href="#广告服务" class="headerlink" title="广告服务"></a>广告服务</h3><p>处理完以上步骤，我们便可以将这些服务广告给对服务感兴趣的Central端。我们可以通过调用CBPeripheralManager实例的startAdvertising:方法来完成这一操作，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[peripheralManager startAdvertising:@&#123;CBAdvertisementDataServiceUUIDsKey: @[service.UUID]&#125;];</div></pre></td></tr></table></figure>
<p>startAdvertising:的参数是一个字典，Peripheral管理器支持且仅支持两个key值：CBAdvertisementDataLocalNameKey与CBAdvertisementDataServiceUUIDsKey。这两个值描述了数据的详情。key值所对应的value期望是一个表示多个服务的数组。</p>
<p>当广告服务时，CBPeripheralManager对象会调用代码对象的peripheralManagerDidStartAdvertising:error:方法，我们可以在此做相应的处理，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(<span class="built_in">NSError</span> *)error</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Start Advertising"</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (error)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error advertising: %@"</span>, [error localizedDescription]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>广告服务之后，Central端便可以发现设备并初始化一个连接。</p>
<h3 id="对Central端的读写请求作出响应"><a href="#对Central端的读写请求作出响应" class="headerlink" title="对Central端的读写请求作出响应"></a>对Central端的读写请求作出响应</h3><p>在与Central端进行连接后，可能需要从其接收读写请求，我们需要以适当的方式作出响应。</p>
<p>当连接的Central端请求读取特性的值时，CBPeripheralManager对象会调用代理对象的peripheralManager:didReceiveReadRequest:方法，代理方法提供一个CBATTRequest对象以表示Central端的请求，我们可以使用它的属性来填充请求。下面代码简单展示了这样一个过程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 查看请求的特性是否是指定的特性</span></div><div class="line">    <span class="keyword">if</span> ([request.characteristic.UUID isEqual:cha1.UUID])</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Request character 1"</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 确保读请求所请求的偏移量没有超出我们的特性的值的长度范围</span></div><div class="line">        <span class="comment">// offset属性指定的请求所要读取值的偏移位置</span></div><div class="line">        <span class="keyword">if</span> (request.offset &gt; cha1.value.length)</div><div class="line">        &#123;</div><div class="line">            [peripheralManager respondToRequest:request withResult:CBATTErrorInvalidOffset];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 如果读取位置未越界，则将特性中的值的指定范围赋给请求的value属性。</span></div><div class="line">        request.value = [cha1.value subdataWithRange:(<span class="built_in">NSRange</span>)&#123;request.offset, cha1.value.length - request.offset&#125;];</div><div class="line">        </div><div class="line">        <span class="comment">// 对请求作出成功响应</span></div><div class="line">        [peripheralManager respondToRequest:request withResult:CBATTErrorSuccess];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在每次调用代理对象的peripheralManager:didReceiveReadRequest:时调用respondToRequest:withResult:方法以对请求做出响应。</p>
<p>处理写请求类似于上述过程，此时会调用代理对象的peripheralManager:didReceiveWriteRequests:方法。不同的是代理方法会给我们一个包含一个或多个CBATTRequest对象的数组，每一个都表示一个写请求。我们可以使用请求对象的value属性来给我们的特性属性赋值，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(<span class="built_in">NSArray</span> *)requests</div><div class="line">&#123;</div><div class="line">	 CBATTRequest *request = requests[<span class="number">0</span>];</div><div class="line">  	    </div><div class="line">	 cha1.value = request.value;</div><div class="line">	    </div><div class="line">	 [peripheralManager respondToRequest:request withResult:CBATTErrorSuccess];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>响应处理与请求类似。</p>
<h3 id="发送更新的特性值给订阅的Central端"><a href="#发送更新的特性值给订阅的Central端" class="headerlink" title="发送更新的特性值给订阅的Central端"></a>发送更新的特性值给订阅的Central端</h3><p>如果有一个或多个Central端订阅了我们的服务的特性时，当特性发生变化时，我们需要通知这些Central端。为此，代理对象需要实现peripheralManager:central:didSubscribeToCharacteristic:方法。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Central subscribed to characteristic %@"</span>, characteristic);</div><div class="line">    </div><div class="line">    <span class="built_in">NSData</span> *updatedData = characteristic.value;</div><div class="line">    </div><div class="line">    <span class="comment">// 获取属性更新的值并调用以下方法将其发送到Central端</span></div><div class="line">    <span class="comment">// 最后一个参数指定我们想将修改发送给哪个Central端，如果传nil，则会发送给所有连接的Central</span></div><div class="line">    <span class="comment">// 将方法返回一个BOOL值，表示修改是否被成功发送，如果用于传送更新值的队列被填充满，则方法返回NO</span></div><div class="line">    <span class="built_in">BOOL</span> didSendValue = [peripheralManager updateValue:updatedData forCharacteristic:(CBMutableCharacteristic *)characteristic onSubscribedCentrals:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Send Success ? %@"</span>, (didSendValue ? <span class="string">@"YES"</span> : <span class="string">@"NO"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述代码中，当传输队列有可用的空间时，CBPeripheralManager对象会调用代码对象的peripheralManagerIsReadyToUpdateSubscribers:方法。我们可以在这个方法中调用updateValue:forCharacteristic:onSubscribedCentrals:来重新发送值。</p>
<p>我们使用通知来将单个数据包发送给订阅的Central。当我们更新订阅的Central时，我们应该通过调用一次updateValue:forCharacteristic:onSubscribedCentrals:方法将整个更新的值放在一个通知中。</p>
<p>由于特性的值大小不一，所以不是所有值都会被通知传输。如果发生这种情况，需要在Central端调用CBPeripheral实例的readValueForCharacteristic:方法来处理，该方法可以获取整个值。</p>
<h2 id="Central-Client-端操作"><a href="#Central-Client-端操作" class="headerlink" title="Central(Client)端操作"></a>Central(Client)端操作</h2><p>一个Central端主要包含以下操作：</p>
<ol>
<li>启动一个Central端管理器对象</li>
<li>搜索并连接正在广告的Peripheral设备</li>
<li>在连接到Peripheral端后查询数据</li>
<li>发送一个对特性值的读写请求到Peripheral端</li>
<li>当Peripheral端特性值改变时接收通知</li>
</ol>
<p>我们将在下面结合代码对每一步分别进行讲解</p>
<h3 id="启动一个Central管理器"><a href="#启动一个Central管理器" class="headerlink" title="启动一个Central管理器"></a>启动一个Central管理器</h3><p>CBCentralManager对象在Core Bluetooth中表示一个本地Central设备，我们在执行任何BLE交互时必须分配并初始化一个Central管理器对象。创建代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 指定当前类为代理对象，所以其需要实现CBCentralManagerDelegate协议</span></div><div class="line"><span class="comment">// 如果queue为nil，则Central管理器使用主队列来发送事件</span></div><div class="line">centralManager = [[CBCentralManager alloc] initWithDelegate:<span class="keyword">self</span> queue:<span class="literal">nil</span> options:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>创建Central管理器时，管理器对象会调用代理对象的centralManagerDidUpdateState:方法。我们需要实现这个方法来确保本地设备支持BLE。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)centralManagerDidUpdateState:(CBCentralManager *)central</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Central Update State"</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">switch</span> (central.state) &#123;</div><div class="line">        <span class="keyword">case</span> CBCentralManagerStatePoweredOn:</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"CBCentralManagerStatePoweredOn"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> CBCentralManagerStatePoweredOff:</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"CBCentralManagerStatePoweredOff"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> CBCentralManagerStateUnsupported:</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"CBCentralManagerStateUnsupported"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="发现正在广告的Peripheral设备"><a href="#发现正在广告的Peripheral设备" class="headerlink" title="发现正在广告的Peripheral设备"></a>发现正在广告的Peripheral设备</h3><p>Central端的首要任务是发现正在广告的Peripheral设备，以备后续连接。我们可以调用CBCentralManager实例的scanForPeripheralsWithServices:options:方法来发现正在广告的Peripheral设备。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查找Peripheral设备</span></div><div class="line"><span class="comment">// 如果第一个参数传递nil，则管理器会返回所有发现的Peripheral设备。</span></div><div class="line"><span class="comment">// 通常我们会指定一个UUID对象的数组，来查找特定的设备</span></div><div class="line">[centralManager scanForPeripheralsWithServices:<span class="literal">nil</span> options:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>在调用上述方法后，CBCentralManager对象在每次发现设备时会调用代理对象的centralManager:didDiscoverPeripheral:advertisementData:RSSI:方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(<span class="built_in">NSDictionary</span> *)advertisementData RSSI:(<span class="built_in">NSNumber</span> *)RSSI</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Discover name : %@"</span>, peripheral.name);</div><div class="line">    </div><div class="line">    <span class="comment">// 当我们查找到Peripheral端时，我们可以停止查找其它设备，以节省电量</span></div><div class="line">    [centralManager stopScan];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Scanning stop"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="连接Peripheral设备"><a href="#连接Peripheral设备" class="headerlink" title="连接Peripheral设备"></a>连接Peripheral设备</h3><p>在查找到Peripheral设备后，我们可以调用CBCentralManager实例的connectPeripheral:options:方法来连接Peripheral设备。如下代码所示</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[centralManager connectPeripheral:peripheral options:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>如果连接成功，则会调用代码对象的centralManager:didConnectPeripheral:方法，我们可以实现该方法以做相应处理。另外，在开始与Peripheral设备交互之前，我们需要设置peripheral对象的代理，以确保接收到合适的回调。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Peripheral Connected"</span>);</div><div class="line">    </div><div class="line">    peripheral.delegate = <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查找所连接Peripheral设备的服务"><a href="#查找所连接Peripheral设备的服务" class="headerlink" title="查找所连接Peripheral设备的服务"></a>查找所连接Peripheral设备的服务</h3><p>建立到Peripheral设备的连接后，我们就可以开始查询数据了。首先我们需要查找Peripheral设备中可用的服务。由于Peripheral设备可以广告的数据有限，所以Peripheral设备实际的服务可能比它广告的服务要多。我们可以调用peripheral对象的discoverServices:方法来查找所有的服务。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[peripheral discoverServices:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>参数传递nil可以查找所有的服务，但一般情况下我们会指定感兴趣的服务。</p>
<p>当调用上述方法时，peripheral会调用代理对象的peripheral:didDiscoverServices:方法。Core Bluetooth创建一个CBService对象的数组，数组中的元素是peripheral中找到的服务。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(<span class="built_in">NSError</span> *)error</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Discover Service"</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (CBService *service <span class="keyword">in</span> peripheral.services)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Discovered service %@"</span>, service);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查找服务中的特性"><a href="#查找服务中的特性" class="headerlink" title="查找服务中的特性"></a>查找服务中的特性</h3><p>假设我们已经找到感兴趣的服务，接下来就是查询服务中的特性了。为了查找服务中的特性，我们只需要调用CBPeripheral类的discoverCharacteristics:forService:方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Discovering characteristics for service %@"</span>, service);</div><div class="line">[peripheral discoverCharacteristics:<span class="literal">nil</span> forService:service];</div></pre></td></tr></table></figure>
<p>当发现特定服务的特性时，peripheral对象会调用代理对象的peripheral:didDiscoverCharacteristicsForService:error:方法。在这个方法中，Core Bluetooth会创建一个CBCharacteristic对象的数组，每个元素表示一个查找到的特性对象。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(<span class="built_in">NSError</span> *)error</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Discover Characteristics"</span>);</div><div class="line">    <span class="keyword">for</span> (CBCharacteristic *characteristic <span class="keyword">in</span> service.characteristics)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Discovered characteristic %@"</span>, characteristic);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取特性的值"><a href="#获取特性的值" class="headerlink" title="获取特性的值"></a>获取特性的值</h3><p>一个特性包含一个单一的值，这个值包含了Peripheral服务的信息。在获取到特性之后，我们就可以从特性中获取这个值。只需要调用CBPeripheral实例的readValueForCharacteristic:方法即可。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Reading value for characteristic %@"</span>, characteristic);</div><div class="line">[peripheral readValueForCharacteristic:characteristic];</div></pre></td></tr></table></figure>
<p>当我们读取特性中的值时，peripheral对象会调用代理对象的peripheral:didUpdateValueForCharacteristic:error:方法来获取该值。如果获取成功，我们可以通过特性的value属性来访问它，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(<span class="built_in">NSError</span> *)error</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSData</span> *data = characteristic.value;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Data = %@"</span>, data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="订阅特性的值"><a href="#订阅特性的值" class="headerlink" title="订阅特性的值"></a>订阅特性的值</h3><p>虽然使用readValueForCharacteristic:方法读取特性值对于一些使用场景非常有效，但对于获取改变的值不太有效。对于大多数变动的值来讲，我们需要通过订阅来获取它们。当我们订阅特性的值时，在值改变时，我们会从peripheral对象收到通知。</p>
<p>我们可以调用CBPeripheral类的setNotifyValue:forCharacteristic:方法来订阅感兴趣的特性的值。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[peripheral setNotifyValue:<span class="literal">YES</span> forCharacteristic:characteristic];</div></pre></td></tr></table></figure>
<p>当我们尝试订阅特性的值时，会调用peripheral对象的代理对象的peripheral:didUpdateNotificationStateForCharacteristic:error: 方法。如果订阅失败，我们可以实现该代理方法来访问错误，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(<span class="built_in">NSError</span> *)error</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (error)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error changing notification state: %@"</span>, [error localizedDescription]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在成功订阅特性的值后，当特性值改变时，peripheral设备会通知我们的应用。</p>
<h3 id="写入特性的值"><a href="#写入特性的值" class="headerlink" title="写入特性的值"></a>写入特性的值</h3><p>一些场景下，我们需要写入特性的值。例如我们需要与BLE数字恒温器交互时，可能需要给恒温器提供一个值来设定房间的温度。如果特性的值是可写的，我们可以通过调用CBPeripheral实例的writeValue:forCharacteristic:type:方法来写入值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithBytes:[<span class="string">@"test"</span> UTF8String] length:<span class="string">@"test"</span>.length];</div><div class="line">[peripheral writeValue:data forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];</div></pre></td></tr></table></figure>
<p>当尝试写入特性值时，我们需要指定想要执行的写入类型。上例指定了写入类型是CBCharacteristicWriteWithResponse，表示peripheral让我们的应用知道是否写入成功。</p>
<p>指定写入类型为CBCharacteristicWriteWithResponse的peripheral对象，在响应请求时会调用代理对象的peripheral:didWriteValueForCharacteristic:error:方法。如果写入失败，我们可以在这个方法中处理错误信息。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Core Bluetooth框架已经为我们封装了蓝牙通信的底层实现，我们只需要做简单的处理就可以在程序中实现基于蓝牙的通信。不过在游戏中，一般使用Game Kit中自带的蓝牙处理功能，以实现大数据量的通信。Core Bluetooth框架还是比较适合小数据量的通信。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html" target="_blank" rel="external">Core Bluetooth Programming Guide</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/27/ibeacon-exploration/" itemprop="url">
                  iBeacon技术初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-27T15:22:43+08:00" content="2014-07-27">
              2014-07-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/something/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>苹果在WWDC 2013上正式推出了iBeacon，并在iOS7设备上配备了该功能。苹果期望将其做为一种技术标准，这个标准允许移动App(包括iOS或Android设备)监听来自于iBeacon设备上的信号并做出响应。这种iBeacon设备配备有低功耗蓝牙(Bluetooth Low Energy, BLE)通信功能，并使用BLE向周围发送自己特有的ID，移动设备上的App在接收到该ID后可以做出相应的反应。比如，我们在店铺里设置iBeacon发射器，便可让应用接收到信息并将这一信息通知给服务器，服务器向我们的App返回与该店铺相关的产品或折扣信息。本质上讲，iBeacon技术允许移动应用了解它们在某个局部范围内的位置，并向用户分发基于位置的超文本上下文内容。本文将对iBeacon技术做个简要的介绍。</p>
<h2 id="低功耗蓝牙技术-Bluetooth-Low-Energy"><a href="#低功耗蓝牙技术-Bluetooth-Low-Energy" class="headerlink" title="低功耗蓝牙技术(Bluetooth Low Energy)"></a>低功耗蓝牙技术(Bluetooth Low Energy)</h2><p>iBeacon的底层通信技术是采用低功耗蓝牙技术，这种技术是在短距离范围内数据传输的无线区域网络技术。顾名思义，它即要求低功耗，又需要保证传统蓝牙技术的通信范围。</p>
<p>BLE与传统蓝牙有几点不同：</p>
<ol>
<li>耗电量：BLE是低耗电量的，iBeacon设备使用一个纽扣电池即可持续运作长达3年时间。</li>
<li>低成本：BLE的成本只相当于传统蓝牙设备的60%-80%</li>
<li>应用：BLE适用于只要求少量定期传输数据的简单应用。传统的蓝牙适用于需要持续通信和大量数据传输的复杂应用。</li>
</ol>
<p>BLE通信数据包主要由称为”Advertisements”的数据或小的数据包组成，并通过无线电波由Beacons或其它BLE设备以有规律的时间间隔来广播。BLE广告是一种单向通信(one-way communication)方法。希望被发现的Beacon设备可以以设定的时间间隔广播或”广告”自包含的数据包。这些数据包由智能手机等设备收集，并在设备上触发一些事件，如推送消息、提示等。</p>
<p>苹果iBeacon标准要求广播时间的间隔是100ms。频率超高越耗电，但可以让智能手机或其它监听设备越快地发现iBeacon。标准的BLE广播距离是100m，这使Beacon在室内位置跟踪场景下的效果更理想。</p>
<h2 id="监听Beacon区域"><a href="#监听Beacon区域" class="headerlink" title="监听Beacon区域"></a>监听Beacon区域</h2><p>Beacon区域监听使用iOS设备的内置无线电来检测用户何时在广告iBeacon信息的BLE设备附近。由于是地理位置的监听，当用户进入或在一个Beacon区域时，我们可以使用这些功能来生成提示或提供其它相关的信息。一个Beacon区域通过以下值的组合来进行标识：</p>
<ol>
<li>proximity UUID(全局唯一标识)：一个128位值，唯一标识一类或一个组织中的一个或多个Beacon。</li>
<li>major值，一个16位无符号整数，用于分组有相同proximity UUID值的相关的Beacon。</li>
<li>minor值，一个16位无符号整数，用于区分具有相同proximity UUID值和major的值。</li>
</ol>
<p>因为一个Beacon区域可以包含多个iBeacon设备，Beacon区域监听支持同时监听多个感兴趣的设备。例如，一个App为了在特定商场提高用户体验，可用使用相同的proximity UUID来监听商场的所有商铺。当用户进入一个商店时，App检测商铺的iBeacon设备并使用major和minor值来获取额外的信息，如用户进入哪家商店或用户在商店的哪个区域(注意：虽然每个iBeacon都必须有一个proximity UUID，但major和minor的值是可选的)。</p>
<h3 id="定义一个Beacon区域"><a href="#定义一个Beacon区域" class="headerlink" title="定义一个Beacon区域"></a>定义一个Beacon区域</h3><p>我们使用<strong>CLBeaconRegion</strong>类的初始化方法来定义一个beacon区域，并在系统中注册，以开启一个监听。当创建一个CLBeaconRegion对象时，我们指定需要监听的Beacon区域的proximityUUID, major和minor属性。我们必须提供一个唯一标识区域的字符串以便我们在代码中能引用它。注意一个区域的标识与Beacon标识信息无关。</p>
<p>为了注册一个beacon区域，调用CLLocationManager对象的startMonitoringForRegion方法。代码清单1是创建并注册的beacon区域的简单方法。</p>
<p><strong>代码清单1：创建和注册一个beacon区域</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)registerBeaconRegionWithUUID:(<span class="built_in">NSUUID</span> *)proximityUUID andIdentifier:(<span class="built_in">NSString</span> *)identifier</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CLBeaconRegion</span> *beaconRegion = [[<span class="built_in">CLBeaconRegion</span> alloc] initWithProximityUUID:proximityUUID identifier:identifier];</div><div class="line">    </div><div class="line">    [manager startMonitoringForRegion:beaconRegion];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>App在注册并监听某个Beacon区域后，会立即开始监听此区域。当App监听到注册的Beacon区域时，系统会为App生成一个合适的区域事件。</p>
<h3 id="处理边界穿越事件"><a href="#处理边界穿越事件" class="headerlink" title="处理边界穿越事件"></a>处理边界穿越事件</h3><p>当用户进入一个注册的Beacon区域时，CLLocationManager对象将调用其代理对象的locationManager:didEnterRegion:方法。类似的，当用户离开这个区域时，将调用代理对象的locationManager:didExitRegion:方法。注意，用户必须穿过区域边界来触发这些调用，如果用户已经在区域中，CLLocationManager对象将不会调用locationManager:didEnterRegion:。我们可以实现这些代理方法来提示用户或展示一个指定位置的UI。</p>
<p>我们可以设置Beacon区域的notifyOnEntry和notifyOnExit属性来指定哪个边界穿越事件应该通知给我们的App。例如，如果在用户离开区域时不需要通知App，则可以设置区域的notifyOnEntry属性为NO。</p>
<p>我们也可以在用户打开设备的屏幕时再通知用户已进入一个Beacon区域。我们只需要在注册Beacon区域时，简单的设置Beacon区域的notifyEntryStateOnDisplay属性为YES，以及设置notifyOnEntry属性为NO。为了防止多余的通知被发送给用户，只在进入一个区域时才发送一个本地通知。</p>
<p>当用户已经在注册的Beacon区域内时，App可以调用CLLocationManager类的startRangingBeaconsInRegion:方法来确定我们的设备与区域中的一个或多个iBeacon设备的相对距离，并在距离改变时被通知。(注意：我们总是在尝试查找区域内的iBeacon设备时调用CLLocationManager的类方法isRangingAvailable)。对于大多数程序来说，知道这个相对距离是很有用的。例如，想像一个在每个展品上安装了iBeacon设备的博物馆。如果我们使用这个博物馆相应的App，当我们走近某个展品时，就可以通过iBeacon来向我们的App发送关于展品的信息。</p>
<p>当指定Beacon区域的iBeacon设备进入范围、离开范围或相对距离改变时，CLLocationManager对象调用代理对象的locationManager:didRangeBeacons:inRegion:方法。这个代理方法提供一个CLBeacon对象的数组来表示当前设备范围内的iBeacon。iBeacon的数组根据离设备的相对距离来排序，最近的在最前面。我们可以使用这些对象中的信息来确定用户离每个iBeacon设备的距离。CLBeacon对象的proximity属性给出了到一个beacon的相对距离。</p>
<p><em>注：iBeacon的排列依赖于检测到的BLE无线信号的强度，以及这些信号受墙壁、门或其它物理实体的影响。当我们使用iBeacon时需要考虑这些影响因素。</em></p>
<p>代码清单2显示了如何使用一个Beacon的proximity属性来确定到用户设备的相对距离。</p>
<p><strong>代码清单2：确定用户设备与beacon的相对距离</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)locationManager:(<span class="built_in">CLLocationManager</span> *)manager didRangeBeacons:(<span class="built_in">NSArray</span> *)beacons inRegion:(<span class="built_in">CLBeaconRegion</span> *)region</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([beacons count] &gt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">CLBeacon</span> *nearestExhibit = [beacons firstObject];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (<span class="built_in">CLProximityNear</span> == nearestExhibit.proximity)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, nearestExhibit.major.integerValue);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"test"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：当多个iBeacon设备广告了相同的proximityUUID, major和minor属性组合时，在locationManager:didRangeBeacons:inRegion:方法中它们可能会有不同的距离与精度。建议每一个beacon设备都是唯一标识的。</p>
<h2 id="在iOS设备中开启iBeacon功能"><a href="#在iOS设备中开启iBeacon功能" class="headerlink" title="在iOS设备中开启iBeacon功能"></a>在iOS设备中开启iBeacon功能</h2><p>支持使用BLE分享数据的iOS设备可以当作iBeacon设备来使用。由于应用必须运行于前台，因此iOS设备上的iBeacon支持主要用于测试目的和任何情况下都运行于前台的App。对于其它类型的iBeacon实现，我们必须从第三方的制造商那获取专用的iBeacon设备。</p>
<p>因为将iOS设备作为一个iBeacon设备需要使用Core Bluetooth framework，所以我们需要在XCode工程中链接CoreBluetooth.framework。同时在相关的资源文件中导入<corebluetooth corebluetooth.h="">头文件。</corebluetooth></p>
<p>要在一个iOS设备上创建和广告一个Beacon区域，首先我们需要生成一个128位的UUID作为我们的proximity UUID。我们可以在终端使用uuidgen命令来生成一个UUID。然后，我们使用这个UUID来创建一个Beacon区域，同时定义所需的major和minor值。代码清单3显示了如何创建一个新Beacon区域</p>
<p><strong>代码清单3</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUUID</span> *proximityUUID = [[<span class="built_in">NSUUID</span> alloc] initWithUUIDString:<span class="string">@"D80415EC-AC22-4046-8497-4BDAC297323C"</span>];</div><div class="line">    </div><div class="line"><span class="built_in">CLBeaconRegion</span> *beaconRegion = [[<span class="built_in">CLBeaconRegion</span> alloc] initWithProximityUUID:proximityUUID identifier:<span class="string">@"com.mycompany.myregion"</span>];</div></pre></td></tr></table></figure>
<p>现在我们已经创建了一个Beacon区域，然后我们需要使用Core Bluetooth framework的CBPeripheralManager来广告我们的Beacon的proximity UUID(及major或minor值)。在Core Bluetooth中，一个peripheral是使用BLE来广告和分享数据的设备。广告Beacon的数据是其它设备能检测并排列我们的Beacon设备的唯一方法。</p>
<p>为了在Core Bluetooth中广告peripheral数据，我们调用CBPeripheralManager实例的startAdvertising:方法。这个方法需要广告数据的字典。然后我们创建一个CBPeripheralManager类的实例，并让其广告我们的Beacon来让其它设备监听。代码清单4所示了这一过程。</p>
<p><strong>代码清单4</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *beaconPeripheralData = [beaconRegion peripheralDataWithMeasuredPower:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">manager = [[CBPeripheralManager alloc] initWithDelegate:<span class="keyword">self</span> queue:<span class="literal">nil</span> options:<span class="literal">nil</span>];</div><div class="line">[manager startAdvertising:beaconPeripheralData];</div></pre></td></tr></table></figure>
<p><strong>重要：当我们创建一个peripheral管理对象时，peripheral管理对象会调用它的代理的peripheralManagerDidUpdateState:方法。我们必须实现这个代理方法以确保BLE在本地peripheral设备上可用。</strong></p>
<p>在广告我们的iBeacon后，我们必须在前台继续运行程序来广播所需要的蓝牙信号。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>iBeacon是苹果提出的近场定位技术，其目标直指NFC。在App中使用iBeacon并不复杂，苹果已经为我们解决了大部分的底层技术问题。我们只需要简单的创建一个Beacon区域并监听它，在代理对象中处理相应的事件即可。它的实质就是一种定位技术，其在室内导航方面前景光明，相信这一技术会在今后大有作为。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/LocationAwarenessPG/Introduction/Introduction.html" target="_blank" rel="external">Location and Maps Programming Guide</a></li>
<li><a href="http://www.cocoachina.com/applenews/devnews/2014/0115/7705.html" target="_blank" rel="external">如何使用iOS 7的iBeacons来提高你的应用</a></li>
<li><a href="http://www.cocoachina.com/applenews/devnews/2014/0512/8377.html" target="_blank" rel="external">开发使用 iBeacon 的 iOS 7 应用</a></li>
<li>代码示例：<a href="https://developer.apple.com/library/ios/samplecode/AirLocate/Introduction/Intro.html" target="_blank" rel="external">AirLocate: Using CoreLocation to monitor, range, and configure your device as an iBeacon</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/20/bonjour-2/" itemprop="url">
                  Bonjour理论2：域命名约定、API及其操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-20T15:52:22+08:00" content="2014-07-20">
              2014-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="域命名约定"><a href="#域命名约定" class="headerlink" title="域命名约定"></a>域命名约定</h2><p>服务实例与服务类型的Bonjour名称与DNS域名相关。这里我们将介绍DNS域名，Bonjour本地“域”，和Bonjour服务实例与服务类型的命名规则。</p>
<h3 id="域名与DNS"><a href="#域名与DNS" class="headerlink" title="域名与DNS"></a>域名与DNS</h3><p>DNS使用specific-to-general命名方案来为域名命名。最能用的域是”.”,称为根域名，这是类似于UNIX文件系统中的根目录”/“。所有其它域都在根域名的层次结构中。例如，域名www.apple.com.可以解析为根域”.”，其下包含顶级域名”com.”,再下面是二级域”apple.com.”, 其下就是”www.apple.com.”。下图显示了这种层次结构：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/names_01dns_2x.png" alt="image"></p>
<p>在这棵倒树的顶部是根域。在其下面是一些顶级域：com., edu., org.等。在顶级域下面是一些二级域，如apple, darwin, zeroconf。这棵树可以无限延伸下去。</p>
<h3 id="Bonjour和本地链路"><a href="#Bonjour和本地链路" class="headerlink" title="Bonjour和本地链路"></a>Bonjour和本地链路</h3><p>Bonjour协议很大程度上都是在处理本地链路(网络的一部分)。一个主机的本地链路或才链路本地网络(link-lock network)包括主机本身及其它可以不修改IP分组数据就是交换包的主机。在实践中，这包含所有没被路由器分开的主机。</p>
<p>在Bonjour系统中，”local.”用于标识在本地IP网络中应该使用IP多播查询来进行查找的名称。</p>
<p>注意：”local.”不是一个真实的域。我们可以将”local.”当成一个伪域。它与传统的DNS域有一个根本的区别：其它域的名称是全局唯一的，而链路本地域名不是。www.apple.com在全球只有唯一的一个DNS入口。而以local.结尾的主机名是本地网络中由多播DNS响应者的集合管理的，所以命名范围就是”local.”(本地)。所以只要不在同一个本地网络中，就可以有两台命名相同的主机，即使是在同一栋楼中。而在同一个本地网络中，也需要确保名称的唯一性。如果在本地网络中发生名称冲突，一个Bonjour主机会自动查找一个新的名称或让用户输入一个新的。</p>
<h3 id="现有服务类型的Bonjour名称"><a href="#现有服务类型的Bonjour名称" class="headerlink" title="现有服务类型的Bonjour名称"></a>现有服务类型的Bonjour名称</h3><p>Bonjour服务根据IP服务的现有网络标准(RFC 2782)来命名。Bonjour服务名结合服务类型和传输协议绑定以形成一个注册类型。注册类型用于注册一个服务并创建DNS资源记录。如果要在DNS资源记录中区分注册类型和域名，可以要注册类型每个组件前使用下划线。其格式如下</p>
<p><strong>_ServiceType._TransportProtocolName</strong></p>
<p>服务类型是该服务的官方IANA注册名称，如ftp,http或打印机。传输协议的名称是tcp或udp，取决于服务使用的传输协议。一个运行在TCP上的FTP服务注册类型应该是_ftp._tcp，并将注册一个名称为_ftp._tcp.local.的DNS PTR记录，以作为服务所在主机的多播DNS响应者。</p>
<h3 id="新服务的Bonjour名称"><a href="#新服务的Bonjour名称" class="headerlink" title="新服务的Bonjour名称"></a>新服务的Bonjour名称</h3><p>如果我们正在设计一个新的协议以作为Bonjour网络服务来推广，则应该在IANA中注册它。</p>
<p>IANA目前要求每个每个注册的服务都与一个”众所周知的端口”或众所周知的端口范围相关联。例如，http的端口是80，所以我们在浏览器中访问一个站点时，程序都假设HTTP服务运行在80端口上，除非我们另行指定。</p>
<p>但在Bonjour中，我们不需要知道端口号。因为客户端程序通过对服务类型进行简单查询，就能发现我们的服务，因此不需要端口。</p>
<h3 id="服务实例的Bonjour名称"><a href="#服务实例的Bonjour名称" class="headerlink" title="服务实例的Bonjour名称"></a>服务实例的Bonjour名称</h3><p>服务实例名称是一种可读的字符串，因此，它们的名称具有描述性，并可以让用户重写我们提供的默认名称。由于它们是可浏览的，而不是类型化的，服务实例名可以是编码为UTF8的任何Unicode字符串，最多63个字节长度。</p>
<p>例如，一个在网络中分享音乐的程序可能使用本地用户名来分享服务(如Emille的曲库)。用户可以重写默认服务名，并将服务命名为Zealous Lizard’s Tune Studio._music._tcp.local.</p>
<p>下图说明了一个Bonjour服务实例的名称结构。在树的顶部是域，如本地网络的local.。下一级是注册类型，它由前面加下划线的服务类型(_music)和传输协议(同样前面有开线)组成。在树的底部是可读的服务实例名，如Zealous Lizard’s Tune Studio。完整的名称由底至顶，每个组件由”.”分割。</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/names_02services_2x.png" alt="image"></p>
<h2 id="Bonjour的API架构"><a href="#Bonjour的API架构" class="headerlink" title="Bonjour的API架构"></a>Bonjour的API架构</h2><p>Bonjour网络服务的API结构如下图所示：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/rendarch_04apilayers_2x.png" alt="image"></p>
<p>其主要有这么几部分：</p>
<ol>
<li>NSNetService和NSNetServiceBrowser类：在Foundation框架中</li>
<li>CFNetServices：Core Services中CFNetwork框架的一部分；</li>
<li>DNS Service Discovery for Java(OS X)</li>
<li>底层DNS Service Discovery API：构建在BSD socket</li>
</ol>
<p>所有这些API集合提供了发布、搜索和网络服务解析的基础方法。下面我们简单介绍一下这几个部分</p>
<h3 id="NSNetService和NSNetServiceBrowser"><a href="#NSNetService和NSNetServiceBrowser" class="headerlink" title="NSNetService和NSNetServiceBrowser"></a>NSNetService和NSNetServiceBrowser</h3><p>NSNetService和NSNetServiceBrowser提供了服务搜索和发布的面向对象接口。NSNetService对象表示Bonjour服务的实例，用于客户端发布和服务搜索；NSNetServiceBrowser表示特定类型服务的浏览器。大多数Cocoa程序员应该使用这些类来处理需求。如果需要更多详细的控制，可以使用DNS Service Discovery API。</p>
<p>NSNetService和NSNetServiceBrowser被安排到默认的NSRunLoop对象中来异步执行发布、搜索和解析操作。所以NSNetService和NSNetServiceBrowser返回的结果都由代理对象来处理。这些对象必须与一个run loop相关联，但不必是默认的run loop。</p>
<h3 id="CFNetServices"><a href="#CFNetServices" class="headerlink" title="CFNetServices"></a>CFNetServices</h3><p>CFNetServices API位于Core Services框架中，提供Core Foundation样式的类型和函数来管理服务和服务搜索。CFNetServices定义了三个Core Foundation对象类型: </p>
<ol>
<li>CFNetService：服务实例的抽象表示，用于发布或其它用途。相关的函数提供了发布和解析服务的支持</li>
<li>CFNetServiceBrowser：表示特定域中特定类型服务的浏览者。通常只在基于Core Foundation编码时使用这个类型</li>
<li>CFNetServiceMonitor</li>
</ol>
<p>CFNetService和CFNetServiceBrowser对象通常在CFRunLoop中使用。为了获取结果，程序需要实现处理事件的回调函数，如新的服务产生和消失等。与NSNetService和NSNetServiceBrowser不同的是，CFNetServices类型可以不需要一个run loop，可以在需要的时候同步运行。但通常不建议同步使用。</p>
<h3 id="DNS-Service-Discovery"><a href="#DNS-Service-Discovery" class="headerlink" title="DNS Service Discovery"></a>DNS Service Discovery</h3><p>DNS Service Discovery API声明在/usr/include/dns_sd.h中，它为Bonjour服务提供了低级别BSD socket通信。DNS Service Discovery作为软件与多播DNS响应者或DNS服务器之间的中介层。它为我们管理DNS响应者，让我们编写程序时专注于服务和服务浏览者而不是DNS资源记录。</p>
<p>由于DNS Service Discovery API是Darwin开源工程的一部分，我们应该在写跨平台代码使用它，或者在诸如在NSNetService这样的高级别API无法获取低级特性时使用它。</p>
<h2 id="Bonjour操作"><a href="#Bonjour操作" class="headerlink" title="Bonjour操作"></a>Bonjour操作</h2><p>Bonjour的网络服务结构包含一个简单易用的机制来发布、搜索和使用基于IP的服务。Bonjour支持三种基础操作，每一种都是零配置网络服务所必须的：</p>
<ol>
<li>发布(Publication): 广告一个服务</li>
<li>搜索(Discovery): 浏览可用的服务</li>
<li>解析(Resolution): 将服务实例名转化为地址和端口</li>
</ol>
<p>下面将分别介绍这三个部分。</p>
<h3 id="Publication"><a href="#Publication" class="headerlink" title="Publication"></a>Publication</h3><p>为了发布一个服务，程序或设备必须使用一个多播DNS响应者来注册服务，或者通过高级API，或者直接与响应者(mDNSResponser)通信。Bonjour同样支持在传统的DNS服务中存储记录。当注册服务后，会创建三个相关的DNS记录：服务记录(SRV), 指针记录(PTR)和文本记录(TXT)。其中TXT记录会包含额外的数据用于解析或使用服务，虽然这些数据通常是空的。</p>
<h4 id="服务记录"><a href="#服务记录" class="headerlink" title="服务记录"></a>服务记录</h4><p>服务记录将服务实例名称映射到实际使用服务所需要的信息。客户端通过持久化方式存储服务实例名以访问这些服务，并在连接的时候执行针对主机名和端口号的DNS查询。这个额外的indirection级提供了两个重要的特性</p>
<ol>
<li>服务由一个可读的名称标识，而不是域名和端口号</li>
<li>客户端可以在服务的端口号和IP地址变化时访问服务，只要服务名不变即可。</li>
</ol>
<p>SRV记录包含两部分信息来标识一个服务</p>
<ol>
<li>主机名</li>
<li>端口号</li>
</ol>
<p>主机名是服务可被发现的域名。用主机名代替IP地址的原因是一个主机可能对应多个IP地址，或者可以同时有IPv4地址和IPv6地址。使用主机名可以让所有这些情况被正确的处理。</p>
<p>端口号标识的服务的TCP或UDP端口号。</p>
<p>SRV记录以下面的规则来命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Instance Name&gt;.&lt;Service Type&gt;.&lt;Domain&gt;</div></pre></td></tr></table></figure>
<p>\<instance name="">是服务实例名称，可以是任何UTF-8编码的字符串，通常是可读的有意义的字符串</instance></p>
<p>\<service type="">是标准的IP协议名称，前面带有下划线，后面跟着传输协议(TCP/UDP，前缀也是下划线)。</service></p>
<p>\<domain>是标准的DNS域名。这可能是一个特定的域名，如apple.com.，也可以是通用的以local.为后缀的域名(用于本地链路的服务)</domain></p>
<p>下面是SRV记录的例子，它是一个运行在TCP上端口号为515上，名称为PrintsAlot的打印后台处理程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PrintsAlot._printer._tcp.local. 120 IN src 0 0 515 blackhawk.local.</div></pre></td></tr></table></figure>
<p>这条记录将在本地链路的叫做blackhawk.local.的打印机的多播DNS响应者设备上被创建。初始的120是用于缓存的TTL值。两个0是分别表示权重和优先级，在传统DNS上选择多个与给定名匹配的记录时需要使用这两个值，而对于多播DNS，将忽略这两个值。</p>
<h4 id="指针记录"><a href="#指针记录" class="headerlink" title="指针记录"></a>指针记录</h4><p>PTR记录可以通过将实例的类型映射到服务的特定类型的实例的名字来开启服务搜索。这个记录添加了另一个indirection层，以便服务可以只通过查询使用服务类型标定的PTR记录就被找到。</p>
<p>这个记录只包含信息的一小块–服务实例的名称。PTR记录的命名与SRV记录类似，不过没有实例名，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Service Type&gt;.&lt;Domain&gt;</div></pre></td></tr></table></figure>
<h4 id="文本记录"><a href="#文本记录" class="headerlink" title="文本记录"></a>文本记录</h4><p>TXT记录与相应的SRV记录有相同的名称，并且可以包含少量的关于服务实例的额外的信息，一般不超过100-200个字节。记录也可以是空的。例如，一个网络游戏可以在多人游戏中广告所使用的地图名称。如果需要传输大量的数据，主机需要与客户端建立一个连接并直接发送数据。</p>
<p>通常，这个记录用于运行在同一地址同一端口的多个服务上，例如在同一个打印服务器上运行的多个打印队列，在这种情况下，TXT记录中额外的信息可用于标识预期的打印队列。如下表所示：</p>
<p><img src="http://b140.photo.store.qq.com/psb?/V130i6W71atwfr/AFtWnv5ko6gDjydKCfEChHIKr1la*sMWMqfKcG8VTXg!/b/dCtmdVP4JAAA&amp;bo=TATAAAAAAAADAK0!&amp;rf=viewer_4" alt="image"></p>
<p>这么做是必要的，因为服务类型曾经与众所周知的端口相关联。建议新的Bonjour协议的设计者在不同的动态分配的端口上来运行每一个服务的实例，而不是在相同的众所周知的端口号上运行它们(这种情况下还需要额外的信息来指定客户端试图通信的服务实例)。</p>
<p>TXT记录中的数据的特性和格式特定于每种服务的类型，所有每个新的服务类型需要为自己相关的TXT记录定义数据的格式，并将其作为协议规范的一部分发布。</p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>服务搜索使用服务发布期间注册的DNS记录来查找特定类型的服务的所有实例。为了做到这一点，所有的应用执行一个匹配服务类型的PTR记录的查询。如_http._tcp，通常使用高级接口。运行于每个设备上的多播DNS响应者将使用服务实例名来返回PTR记录。以音乐共享服务为例，下图显示了搜索的过程</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/rendarch_02discover_2x.png" alt="image"></p>
<p>在搜索音乐共享服务的过程，主要有两步：</p>
<ol>
<li>客户端程序向标准多播地址224.0.0.251发出一个在local.域中服务类型为_music._tcp的查询。</li>
<li>网络中的每一个多播DNS响应者都将接收到这个请求，但只有音乐共享设备会使用一个PTR记录来作出响应。在这种情况下，PTR记录保存一个服务实例名Ed’s Party Mix._music._tcp.local.，客户端程序可以从PTR记录中提取服务实例名然后将其添加到一个音乐服务器的离线列表中。</li>
</ol>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>服务搜索通常只会发生一次，例如，当用户第一次选择打印机时。这个操作保存了服务实例名，和一个服务的任何给定实例的稳定的标识符。端口号，IP地址，主机名可能经常改变，但用户在每次连接服务时不需要再次选择一个打印机。因此，将一个服务名解析为socket信息只有在服务真正使用时才发生。</p>
<p>为了解析一个服务，程序使用服务名来执行SRV记录的DNS查询。多播DNS响应者使用包含当前信息的SRV记录来作出响应。下图演示了音乐共享实例中服务解析的这样一个过程：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/rendarch_03resolve_2x.png" alt="image"></p>
<p>这个过程主要分为几步：</p>
<ol>
<li>解析进程发送一个DNS查询到多播地址224.0.0.251，查询Ed’s Party Mix._music._tcp.local.的SRV记录。</li>
<li>查询返回服务的主机名和端口号(eds-musicbox.local., 1010)</li>
<li>客户端发送一个IP地址的多播请求</li>
<li>请求解析为IP地址169.254.150.84.然后客户端使用这个IP地址和端口号来连接服务器。这个过程发生在服务被使用时，从而总是查找服务的最新地址和端口号。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Introduction.html" target="_blank" rel="external">Bonjour Overview</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/19/bonjour-1/" itemprop="url">
                  Bonjour理论1：基本概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-19T11:38:39+08:00" content="2014-07-19">
              2014-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在过去的二十年里，IP协议已经成为计算机等硬件设备之间通信的基本协议。大部分计算机和其它网络设备都是基于TCP/IP进行通信的。在这种网络中，每个设备都需要一个唯一的IP地址，不管是手动设定的还是由DHCP服务器动态分配的。动态指定的地址是可以改变的，但是像打印机等设备是必须手动设定一个静态地址的，这样网络中的计算机才能连接到它们。然后网络管理员需要配置一个DNS服务器，这样计算机用户就不需要通过IP地址来连接打印机了。这样，一个看起来很小的工作需要比较复杂的配置。但是如果我们需要在自己家中搭建一个局域网，而我们对此一无所知的话，这就是个大问题了。即使对于专业的网络管理员，也需要去手动配置打印机。但我们很多时候并不希望去做这些配置，就可以直接连入局域网内去获取打印机、或在文件服务器、甚至游戏服务器去获取我们想要的东西。</p>
<p>我们希望找到可用的设备并从一个列表中选择它们，而不是必须知道每个服务名或IP地址。这便是Bonjour所需要解决的问题。它是基于IP的一组零配置网络的协议。零配置网络有很大的潜力。</p>
<p>假设我们带着笔记本电脑去客户的公司，这时我们需要打印一些东西。如果这家公司有一台支持Bonjour协议的打印机，那么只要两台设备在同一个局域网内，就可以直接打印。此时，我们的每户本会搜索到任何可用的设备。我们只需要打开文档，选择设备列表中的打印机，点击打印就可完成打印操作。图1演示了这样一个过程：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/about_01example_2x.png" alt="image"></p>
<p>这种零配置网络能够满足手机游戏、家庭网络、分布式计算和其它很多网络应用的需求。</p>
<p>那么Bonjour到底是什么呢？</p>
<h2 id="Bonjour三要素"><a href="#Bonjour三要素" class="headerlink" title="Bonjour三要素"></a>Bonjour三要素</h2><p>Bonjour是由苹果提出的基于IP的无配置网络建议。它产生于ZEROCONF工作组的工作，是IETF的一部分。ZEROCONF工作组对于基于IP的零配置网络的需要主要有三个要求</p>
<ol>
<li>寻址(分配IP地址给主机)</li>
<li>命名(使用名字而非IP地址来表示主机)</li>
<li>服务搜索(自动搜索网络服务)</li>
</ol>
<p>Bonjour即是这些需求的一个解决方案。它允许服务提供商、硬件制造商和程序开发者在使用新的技术时只使用单一的网络协议–IP。网络用户不再需要指定IP地址和主机名，甚至不需要指定网络中访问设备的类型。用户只需要简单的查看有哪些网络服务可用，然后从列表中选择。程序能自动检测到所需要的服务或它们需要进行交互的其它程序，允许自动连接、通信和进行数据传输，而不需要用户的介入。</p>
<p>下面我们来分别看看Bonjour如何解决零配置网络的三个要素</p>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>寻址问题通过自分配链路本地寻址方法来解决。链路本地寻址(Link-local addressing)使用为本地网络保留的地址范围，特别是一个小的LAN或单独的LAN片断。IPv6标准将自分配链路本地寻址作为协议的一部分。而IPv4本身不包含链路本地寻址，因此零配置网络寻址的主要挑战是如何在IPv4中改进此功能。</p>
<p>在IPv4中，自分配寻址通过在链路本地范围内挑选一个随机的IP地址并对其进行测试。如果地址没有使用，则作为本地地址。如果已经使用了，计算机或其它设备将选择另一个随机地址并测试。</p>
<p>目前大多数主流操作系统都支持IPv4和IPv6的链路本地寻址。</p>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>在本地网络中进行name-to-address转换操作建议的方案是使用多播DNS，其中DNS格式查询使用IP多播传送到本地网络中。因为这些DNS查询被发送到多播地址中，因此没有一个全局的DNS服务器来回答这个查询。每个服务或设备都可以提供自己的DNS功能，当前发现一个针对自己名称的查询时，它使用自己的地址来响应这个DNS查询。</p>
<p>Bonjour更进了一步。它在主机或iOS设备上包含一个响应来处理任何网络服务的多播DNS查询。这降低了中断应用来响应多播消息的压力。通过注册服务，Bonjour的mDNSResponder守护进程自动广告我们的服务是否可用，以便把我们名字的查询自动被引导到正确的IP地址和端口号上。</p>
<p>为了让name-to-address转换能正确的工作，需要一个本地网络的唯一的名字。与转换DNS主机名不同的是，这个本地名称只在本地网络或LAN段上有效。我们可以像自分配一个本地地址一样自分配一个本地名称，选中其中一个；如果这个名称没有使用，则：</p>
<ol>
<li>硬件制造商通过设备发送一个多播DNS查询并查看响应来确定其选中的名字是否已使用。如果有响应，则设备应该选择另外一个名字。没有用户界面的设备可以在默认名字后面添加一下大数直到这个名字是唯一的。例如，如果在网络中的默认名字是XYZ-LaserPrinter.local，则可以使用XYZ-LaserPrinter.local，XYZ-LaserPrinter-2.local，XYZ-LaserPrinter-3.local进行测试，直到名字唯一。</li>
<li>软件服务在注册Bonjour时提供一个名字，如果提供的名字已使用，则Bonjour会自动重命名我们的服务。</li>
</ol>
<p>在OS X中，用户可以在系统偏好设置的共享面板中设置本地主机名来为计算机设置一个主机名，在iOS中，主机名是自动产生的且不能配置。这个主机名可用于任何DNS主机名常规使用的地方，如Web浏览器、命令行工具等等。为了向系统表明名字是一个本地主机名，可在主机名后添加.local.，如Setve.local.即为一个本地主机名。</p>
<p>如果用户在浏览器中输入steve.local.，这将告诉系统多播一个请求以在本地网络中查询steve，而不是将其发送到常规DNS服务器。如果在本地网络中有一台支持Bonjour的计算机名字为steve，则用户的浏览器将发送正确的IP地址给它。这允许用户访问本地主机和服务崦不需要常规DNS服务。</p>
<h3 id="服务搜索"><a href="#服务搜索" class="headerlink" title="服务搜索"></a>服务搜索</h3><p>Bonjour最后一个要素是服务搜索。服务搜索允许程序查找所有可用的特定类型的服务并维护一个命名服务及端口的列表。应用可以将服务主机名解析为IPv4和IPv6地址列表。</p>
<p>命名服务的列表在服务与其当前DNS名和端口中提供了一个indirection层。indirection允许程序保存一个可用服务的持久化列表并在使用服务前解析一个实际的网络地址。该列表允许服务被动态迁移，而不会产生大量的网络流量来宣告这个改变。</p>
<p>在Bonjour中服务搜索是通过”browsing”来实现的。一个多播DNS查询发送一个指定的服务类型和域，任何匹配的服务都会回复他们的名字。其结果就是一个可用服务的列表。这与传统的网络服务以设备为中心的思考很不一样。对于处理服务、网络设备和网络编程的的个人来讲，很容易习惯性认为服务基于物理硬件(services in terms of physical hardware)。<br>从设备为中心的角度来看，网络由许多设备或主机组成，每个包含一组服务。例如，网络可能由服务器和客户机组成。在一个设备为中心的浏览架构中，一个客户端向服务器查询哪些服务正在运行，获取一个列表(FTP, HTTP等)，并决定使用哪个服务。这个接口反映了物理系统组织的方式。但这不一定是用户在逻辑上希望的或想要的。</p>
<p>用户通常想要完成特定的任务，而不是查找设备列表来找出什么服务正在运行。让客户端只询问一次“什么打印服务可用？”比查询每个可用的设备来问“你正在运行什么服务”然后筛选结果查找打印服务来得更有意义。以设备为中心的方法不但耗时，而且需要大量的网络流量，且其中大部分是无用的。而以服务为中心的方法发送单个查询，只生成相关的回复。</p>
<p>此外，服务不与指定的IP或主机名绑定。例如，一个站点可能被多个有不同地址的服务器托管。在一个组织中，网络管理员可能需要将一个服务从一个服务器移到另一个服务器来做负载均衡。如果客户端存储了主机名，如果服务移到另一个不同的主机，则无法再连接。</p>
<p>Bonjour从面向服务的角度来看问题。它通过所需要的服务类型来查找，而不是主机名。应用存储的是服务实例名，而不是地址，所以如果IP地址、端口号，甚至主机名改变了，应用仍然可以连接。通过专注于服务而不是设备，用户的浏览体验将更有用且无故障。</p>
<h2 id="降低消耗"><a href="#降低消耗" class="headerlink" title="降低消耗"></a>降低消耗</h2><p>服务器的寻址、命名和服务搜索可能会产生大量的网络流量，但Bonjour采取了一些措施来将流量降低到最少。这允许Bonjour达到AppleTalk的易用性，同时又避免了不必要的“繁琐”。Bonjour采用了多种机制来降低零配置的开销，包括缓存、禁止重复响应，指数回退和服务公告。下面我们将简单介绍下这几种机制。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Bonjour采用了多播DNS记录缓存来防止主机请求那些已请求过的信息。例如，当一个主机请求一个LPR打印后台的处理程序列表时，列表通过多播传回来，所有本地主机都将看到这个列表。下次本地网络中的一个主机需要一个打印后台处理程序的列表时，因为它已经缓存了这个列表，所以不需要再次发起请求。多播DNS响应者负责维护这个缓存；程序开发者不需要做任何事情来维护它</p>
<h3 id="禁止重复响应"><a href="#禁止重复响应" class="headerlink" title="禁止重复响应"></a>禁止重复响应</h3><p>为了阻止重复响应相同的请求，Bonjour服务查询包含一个已知答案的列表。例如，如果主机正在浏览打印机，第一个查询不包含打印服务，但从可用打印服务器得到12个回复。下一次该主机查询打印服务时，查询包含已知服务器的列表。已经在列表中的打倒服务器将不做响应。</p>
<p>Bonjour以另一种方式来抑制重复响应。如果一个主机将要响应，但发现另一个主机已经响应了相同的信息，则主机会抑制它的响应。</p>
<p>程序开发者不需要采取任何措施来抑制重复发送，Bonjour会处理。</p>
<h3 id="指数回退和服务公告"><a href="#指数回退和服务公告" class="headerlink" title="指数回退和服务公告"></a>指数回退和服务公告</h3><p>当主机浏览服务时，它不会不间断地发送查询来查看是否有新的服务。相反，主机会初始一个查询，后续会不断增加查询时间的间隔，如1s, 3s, 9s, 27s这样一个时长间隔，最后可能会长达1小时的间隔。</p>
<p>但这不意味着花费一个小时的时间间隔再来查看新的服务。当在网络中启动一个服务时，它会使用几次回退算法来通知它的存在。这样就将服务公告和搜索的网络流量保持在最小，而新的服务也会很快就知晓。</p>
<p>在一个Bonjour配置主机上运行的服务在注册到mDNSResponder守护程序时会自动发出公告。在其它硬件上的服务，如打印机，将使用指数回退算法来公告其存在，这样充分利用了Bonjour的优势。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Introduction.html" target="_blank" rel="external">Bonjour Overview</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/18/cover-flowte-xiao-shi-xian/" itemprop="url">
                  Cover Flow特效实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-18T22:12:57+08:00" content="2014-07-18">
              2014-07-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sourcecode/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cocoachina.com/bbs/read.php?tid=74500" target="_blank" rel="external">原文</a>发表在cocoachina上，现在把它整理过来。</p>
<h2 id="Cover-Flow介绍"><a href="#Cover-Flow介绍" class="headerlink" title="Cover Flow介绍"></a>Cover Flow介绍</h2><p>Cover flow是苹果首创的将多首歌曲的封面以3D界面的形式显示出来的方式。</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Cove%20flow.png?raw=true" alt="image"> </p>
<h3 id="随处可见的Cover-Flow特效"><a href="#随处可见的Cover-Flow特效" class="headerlink" title="随处可见的Cover Flow特效"></a>随处可见的Cover Flow特效</h3><p>iTunes:在iTunes音乐中点击搜索框左边“查看”项第三个，即以cover flow形式显示专辑封面（前提是你得添加插图或音乐自带插图），也可以在全屏模式使用</p>
<p>iPhone/iPod Touch:在竖屏模式播放音乐，iPhone只会显示一张专辑的封面；但当用户将机身旋转为横屏模式后，则能看到多首歌曲的封面以3D界面的形式显示出来，用手指左右的滑动能够进行歌曲的选择，点击相应的专辑封面则会显示该张唱片的曲目，点击相应歌曲即可开始播放。</p>
<p>苹果官网:官网上有以Flash展示的cover flow界面iPod NANO3/4/5:基本类似于在iphone中的操作，利用触摸轮滑动使封面转换Safari </p>
<p>使用 Cover Flow，您可以像在 iTunes 中翻看专辑插图一样轻松地翻看网站。Cover Flow 可以将您的书签和历史记录显示为大图预览，这样您就能立即找到网站。要查看 Cover Flow 如何工作，请单击 Safari“书签”栏左端的打开书本图标来打开书签列表。在“精选”列表中选择“历史记录”或您要查看其标签的精选。使用水平滚动条来翻看网页预览。您还可以使用鼠标上的滚动按钮来翻看预览。如果您的触控板已配置为支持触控板手势，则您可以左右扫动。</p>
<h2 id="特效制作"><a href="#特效制作" class="headerlink" title="特效制作"></a>特效制作</h2><h3 id="方法一：UICoverFlowLayer"><a href="#方法一：UICoverFlowLayer" class="headerlink" title="方法一：UICoverFlowLayer"></a>方法一：UICoverFlowLayer</h3><p>正式的SDK并未包含UICoverFlowLayer，但是它仍然是标准的UIKit。通过steve nygard的类转储(class-dump), 能从UIKit框架中提取 UICoverFlowLayer头文件。</p>
<p>由于UICoverFlowLayer是私有的，无法应用于应用程序(无法通过苹果的审查)，所以在此简单介绍使用方法：</p>
<ol>
<li>将UICoverFlowLayer.h文件拷贝到工程中创建cover flow视图，并将UICoverFlowLayer图层分配到视图图层中</li>
<li>视图发送dragFlow:atPoint消息，以处理与Cover Flow图层的触摸和拖动的交互过程构建cover flow视图控制器，分配和初始化视图，并提供委托和数据源方法</li>
</ol>
<p>使用UICoverFlowLayer的方法如下代码所示</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UICoverFlowLayer</span> *cfLayer = [[<span class="built_in">UICoverFlowLayer</span> alloc] initWithFrame:frame numberOfCovers:count];</div><div class="line">	</div><div class="line">[[<span class="keyword">self</span> layer] addSublayer:cfLayer];</div></pre></td></tr></table></figure>
<h3 id="方法二：OpenFlow"><a href="#方法二：OpenFlow" class="headerlink" title="方法二：OpenFlow"></a>方法二：OpenFlow</h3><p>OpenFlow是一个用于实现Cover Flow特效的开源库，它是基于Quartz实现的，能很好的实现Cover Flow特效，同时又易于使用。</p>
<p>下载地址：<a href="https://github.com/thefaj/OpenFlow" target="_blank" rel="external">https://github.com/thefaj/OpenFlow</a></p>
<p>使用OpenFlow的基本步骤如下：</p>
<ol>
<li>创建工程</li>
<li>添加OpenFlow源代码到工程中</li>
<li>添加QuartzCore和CoreGraphics框架到工程中</li>
<li>定义CoverFlowViewController(自定义)类</li>
<li>在CoverFlowViewController.h中导入”AFOpenFlowView.h”</li>
<li>实现AFOpenFlowViewDelegate类和AFOpenFlowDataSource协议</li>
</ol>
<p>定义CoverFlowViewController类的代码如下所示</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  CoverFlowViewController.h</span></div><div class="line"><span class="comment">//  CoverFlow</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by Avinash on 4/7/10.</span></div><div class="line"><span class="comment">//  Copyright Apple Inc 2010. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line">	</div><div class="line"><span class="meta">#import <span class="meta-string">"AFOpenFlowView.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CoverFlowViewController</span> : <span class="title">UIViewController</span>  </span>&#123;</div><div class="line">    <span class="comment">// Queue to hold the cover flow p_w_picpath</span></div><div class="line">    <span class="built_in">NSOperationQueue</span> *loadImagesOperationQueue;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>实现CoverFlowViewController类</p>
<p>加载图片</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">     <span class="comment">// loading p_w_picpath into the queue</span></div><div class="line">    loadImagesOperationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</div><div class="line">    <span class="built_in">NSString</span> *imageName;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        imageName = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"cover_%d.jpg"</span>, i];</div><div class="line">        [(AFOpenFlowView *)<span class="keyword">self</span>.view setImage:[<span class="built_in">UIImage</span> imageNamed:imageName] forIndex:i];</div><div class="line">        [imageName release];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%d is the index"</span>,i); </div><div class="line">   &#125;</div><div class="line">    [(AFOpenFlowView *)<span class="keyword">self</span>.view setNumberOfImages:<span class="number">10</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现委托方法，以设置Cover Flow默认图片及通知哪幅图片被选中</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//delegate protocols</span></div><div class="line"><span class="comment">// delegate protocol to tell which image is selected</span></div><div class="line">- (<span class="keyword">void</span>)openFlowView:(AFOpenFlowView *)openFlowView selectionDidChange:(<span class="keyword">int</span>)index&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d is selected"</span>,index);</div><div class="line">&#125;</div><div class="line"><span class="comment">// setting the image 1 as the default pic</span></div><div class="line">- (<span class="built_in">UIImage</span> *)defaultImage&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"cover_1.jpg"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改xib文件中视图的类UIView为AFOpenFlowView(重要)</p>
<p>完成上述步骤之后，就可以运行一下程序看一下效果了。虽然与苹果的Cover Flow效果还是有点差距，但还是不错哦。</p>
<h3 id="方法三：FlowCover"><a href="#方法三：FlowCover" class="headerlink" title="方法三：FlowCover"></a>方法三：FlowCover</h3><p>FlowCover也是一个开源库，它是基于OpenGL ES。FlowCover的源代码非常简单，只有FlowCoverView和DataCache两个类。这两个类的功能如下：</p>
<ol>
<li>FlowCoverView：定义主视图。这是一个OpenGL ES视点，可以被嵌套在其它视图中。</li>
<li>DataCache：提供一个简单的数据缓存方案，保存一定量的对象，当对象超过最大值时，旧的对象会被舍弃。</li>
</ol>
<p>使用FlowCover的基本步骤如下：</p>
<ol>
<li>创建工程</li>
<li>添加FlowCover源代码到工程中</li>
<li>然后就可以像用其它UIView一样使用FlowCoverView了</li>
</ol>
<p>FlowCover中需要实现FlowCoverViewDelegate协议，该协议中主要有三个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">int</span>)flowCoverNumberImages:(FlowCoverView *)view;</div></pre></td></tr></table></figure>
<p>返回FlowCoverView视图中显示的图片数量</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UIImage</span> *)flowCover:(FlowCoverView *)view cover:(<span class="keyword">int</span>)cover;</div></pre></td></tr></table></figure>
<p>返回FlowCoverView视图中用cover指定的图片</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)flowCover:(FlowCoverView *)view didSelect:(<span class="keyword">int</span>)cover;</div></pre></td></tr></table></figure>
<p>当用户触击FlowCoverView中的cover时调用。</p>
<h3 id="方法四：Tapku框架"><a href="#方法四：Tapku框架" class="headerlink" title="方法四：Tapku框架"></a>方法四：Tapku框架</h3><p>Tapku库是一个开源的iOS框架，它包含CoverFlow, Calendar Grid, Char View等等API，总之还是一个比较强大的库。把Tapku加下工程中还是比较复杂的，有兴趣的童鞋可以去网上搜一下。</p>
<p>Tapku下载地址：<a href="https://github.com/devinross/tapkulibrary" target="_blank" rel="external">https://github.com/devinross/tapkulibrary</a></p>
<p>Tapku中与Cover Flow相关的类主要有如下两个：</p>
<ol>
<li>TKCoverflowCoverView: 该类表示的是单个cover。相当于UITableViewCell</li>
<li>TKCoverflowView:该类相当于UITableView类，用来管理和显示cover flow中图片及实现cover flow效果。</li>
</ol>
<p>同时还有两个相关的协议：TKCoverflowViewDelegate， TKCoverflowViewDataSource，分别是 TKCoverflowView的代理及数据源。这两个协议分别有一个必须实现的方法，分别是<br>TKCoverflowViewDelegate协议的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasBroughtToFront:(<span class="keyword">int</span>)index;</div></pre></td></tr></table></figure>
<p>TKCoverflowViewDataSource协议的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasDoubleTapped:(<span class="keyword">int</span>)index</div></pre></td></tr></table></figure>
<p>在工程中使用Tapku的CoverFlow步骤如下</p>
<ol>
<li>创建工程</li>
<li>添加Tapku库到工程中(该步骤有点麻烦，而且Tapku库比较大，个人认为可以只把CoverFlow相关的类抽取出来直接用)。</li>
<li>新建一个视图控制器CoverflowViewController，在该控制器中添加如下代码</li>
</ol>
<p>在头文件CoverflowViewController.h中</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CoverflowViewController</span> : <span class="title">UIViewController</span> &lt;<span class="title">TKCoverflowViewDelegate</span>,<span class="title">TKCoverflowViewDataSource</span>,<span class="title">UIScrollViewDelegate</span>&gt; </span>&#123;</div><div class="line">    TKCoverflowView *coverflow; </div><div class="line">    <span class="built_in">NSMutableArray</span> *covers; <span class="comment">// album covers p_w_picpath</span></div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在CoverflowViewController.m文件中主要有如下处理</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建视图</span></div><div class="line">- (<span class="keyword">void</span>) loadView&#123;</div><div class="line">   [<span class="keyword">super</span> loadView];</div><div class="line">    ......</div><div class="line">    coverflow = [[TKCoverflowView alloc] initWithFrame:<span class="keyword">self</span>.view.bounds];</div><div class="line">    coverflow.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</div><div class="line">    coverflow.coverflowDelegate = <span class="keyword">self</span>;</div><div class="line">    coverflow.dataSource = <span class="keyword">self</span>;</div><div class="line">    <span class="keyword">if</span>([<span class="built_in">UIDevice</span> currentDevice].userInterfaceIdiom == <span class="built_in">UIUserInterfaceIdiomPad</span>)&#123;</div><div class="line">       coverflow.coverSpacing = <span class="number">100</span>;</div><div class="line">      coverflow.coverSize = <span class="built_in">CGSizeMake</span>(<span class="number">300</span>, <span class="number">300</span>);</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.view addSubview:coverflow];</div><div class="line">   ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现代理方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasBroughtToFront:(<span class="keyword">int</span>)index&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">//生成单个cover flow</span></div><div class="line">- (TKCoverflowCoverView*) coverflowView:(TKCoverflowView*)coverflowView coverAtIndex:(<span class="keyword">int</span>)index&#123;</div><div class="line">    TKCoverflowCoverView *cover = [coverflowView dequeueReusableCoverView];</div><div class="line">    <span class="keyword">if</span>(cover == <span class="literal">nil</span>)&#123;</div><div class="line">       <span class="built_in">BOOL</span> phone = [<span class="built_in">UIDevice</span> currentDevice].userInterfaceIdiom == <span class="built_in">UIUserInterfaceIdiomPhone</span>;</div><div class="line">       <span class="built_in">CGRect</span> rect = phone ? <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">224</span>, <span class="number">300</span>) : <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">600</span>);</div><div class="line">  </div><div class="line">      cover = [[[TKCoverflowCoverView alloc] initWithFrame:rect] autorelease]; <span class="comment">// 224</span></div><div class="line">       cover.baseline = <span class="number">224</span>;  </div><div class="line">    &#125;</div><div class="line">    cover.image = [covers objectAtIndex:index%[covers count]];</div><div class="line">   <span class="keyword">return</span> cover;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasDoubleTapped:(<span class="keyword">int</span>)index&#123;</div><div class="line">   TKCoverflowCoverView *cover = [coverflowView coverAtIndex:index];</div><div class="line">    <span class="keyword">if</span>(cover == <span class="literal">nil</span>) <span class="keyword">return</span>;</div><div class="line">    [<span class="built_in">UIView</span> beginAnimations:<span class="literal">nil</span> context:<span class="literal">nil</span>];</div><div class="line">    [<span class="built_in">UIView</span> setAnimationDuration:<span class="number">1</span>];</div><div class="line">    [<span class="built_in">UIView</span> setAnimationTransition:<span class="built_in">UIViewAnimationTransitionFlipFromLeft</span> forView:cover cache:<span class="literal">YES</span>];</div><div class="line">    [<span class="built_in">UIView</span> commitAnimations];</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"Index: %d"</span>,index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="效果比较"><a href="#效果比较" class="headerlink" title="效果比较"></a>效果比较</h2><p>在效果上个人感觉Tapku会好些，渲染流畅，美中不足的是在快速拖动时，停止下来的时候会有抖动的感觉（当然快速拖动这一功能是否需要可视情况而定，如果将此功能禁掉，跟苹果自身的效果还是差不多的）。</p>
<p>OpenFlow的问题在于当改变图像时，新选中的图像会先放大并置于表层，然后才缓动到中间。这是其一个瑕疵。</p>
<p>总体感觉上来讲，苹果自身的CoverFlow的缓动效果还是最好的，有那种渐进渐出的效果，而如上几个开源的库其动画显得有点生硬，有兴趣的童鞋可以试着改进一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/07/17/ioszhong-liu-stream-de-shi-yong/" itemprop="url">
                  iOS中流(Stream)的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-07-17T23:30:26+08:00" content="2014-07-17">
              2014-07-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>流提供了一种简单的方式在不同和介质中交换数据，这种交换方式是与设备无关的。流是在通信路径中串行传输的连续的比特位序列。从编码的角度来看，流是单向的，因此流可以是输入流或输出流。除了基于文件的流外，其它形式的流都是不可查找的，这些流的数据一旦消耗完后，就无法从流对象中再次获取。</p>
<p>在Cocoa中包含三个与流相关的类：NSStream、NSInputStream和NSOutputStream。NSStream是一个抽象基类，定义了所有流对象的基础接口和属性。NSInputStream和NSOutputStream继承自NSStream，实现了输入流和输出流的默认行为。下图描述了流的应用场景：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Streams/Articles/Art/stream_src_dest.gif" alt="image"></p>
<p>从图中看，NSInputStream可以从文件、socket和NSData对象中获取数据；NSOutputStream可以将数据写入文件、socket、内存缓存和NSData对象中。这三处类主要处理一些比较底层的任务。</p>
<p>流对象有一些相关的属性。大部分属性是用于处理网络安全和配置的，这些属性统称为SSL和SOCKS代理信息。两个比较重要的属性是：</p>
<ol>
<li>NSStreamDataWrittenToMemoryStreamKey：允许输出流查询写入到内存的数据</li>
<li>NSStreamFileCurrentOffsetKey：允许操作基于文件的流的读写位置</li>
</ol>
<p>可以给流对象指定一个代理对象。如果没有指定，则流对象作为自己的代理。流对象调用唯一的代理方法stream:handleEvent:来处理流相关的事件：</p>
<ol>
<li>对于输入流来说，是有可用的数据可读取事件。我们可以使用read:maxLength:方法从流中获取数据</li>
<li>对于输出流来说，是准备好写入的数据事件。我们可以使用write:maxLength:方法将数据写入流</li>
</ol>
<p>Cocoa中的流对象与Core Foundation中的流对象是对应的。我们可以通过toll-free桥接方法来进行相互转换。NSStream、NSInputStream和NSOutputStream分别对应CFStream、CFReadStream和CFWriteStream。但这两者间不是完全一样的。Core Foundation一般使用回调函数来处理数据。另外我们可以子类化NSStream、NSInputStream和NSOutputStream，来自定义一些属性和行为，而Core Foundation中的流对象则无法进行扩展。</p>
<p>上面主要介绍了iOS中流的一些基本概念，我们下面将介绍流的具体使用，首先看看如何从流中读取数据。</p>
<h2 id="从输入流中读取数据"><a href="#从输入流中读取数据" class="headerlink" title="从输入流中读取数据"></a>从输入流中读取数据</h2><p>从一个NSInputStream流中读取数据主要包括以下几个步骤：</p>
<ol>
<li>从数据源中创建和初始化一个NSInputStream实例</li>
<li>将流对象放入一个run loop中并打开流</li>
<li>处理流对象发送到其代理的事件</li>
<li>当没有更多数据可读取时，关闭并销毁流对象。</li>
</ol>
<h3 id="准备流对象"><a href="#准备流对象" class="headerlink" title="准备流对象"></a>准备流对象</h3><p>要使用一个NSInputStream，必须要有数据源。数据源可以是文件、NSData对象和网络socket。创建好后，我们设置其代理对象，并将其放入到run loop中，然后打开流。代码清单1展示了这个准备过程.</p>
<p><strong>代理清单1</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setUpStreamForFile:(<span class="built_in">NSString</span> *)path</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSInputStream</span> *inputStream = [[<span class="built_in">NSInputStream</span> alloc] initWithFileAtPath:path];</div><div class="line">    inputStream.delegate = <span class="keyword">self</span>;</div><div class="line">    [inputStream scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line">    </div><div class="line">    [inputStream open];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在流对象放入run loop且有流事件(有可读数据)发生时，流对象会向代理对象发送stream:handleEvent:消息。在打开流之前，我们需要调用流对象的scheduleInRunLoop:forMode:方法，这样做可以避免在没有数据可读时阻塞代理对象的操作。我们需要确保的是流对象被放入正确的run loop中，即放入流事件发生的那个线程的run loop中。</p>
<h3 id="处理流事件"><a href="#处理流事件" class="headerlink" title="处理流事件"></a>处理流事件</h3><p>打开流后，我们可以使用streamStatus属性查看流的状态，用hasBytesAvailable属性检测是否有可读的数据，用streamError来查看流处理过程中产生的错误。</p>
<p>流一旦打开后，将会持续发送stream:handleEvent:消息给代理对象，直到流结束为止。这个消息接收一个NSStreamEvent常量作为参数，以标识事件的类型。对于NSInputStream对象，主要的事件类型包括NSStreamEventOpenCompleted、NSStreamEventHasBytesAvailable和NSStreamEventEndEncountered。通常我们会对NSStreamEventHasBytesAvailable更感兴趣。代理清单2演示了从流中获取数据的过程</p>
<p><strong>代理清单2</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)stream:(<span class="built_in">NSStream</span> *)aStream handleEvent:(<span class="built_in">NSStreamEvent</span>)eventCode</div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span> (eventCode) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamEventHasBytesAvailable</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (!data) &#123;</div><div class="line">                data = [<span class="built_in">NSMutableData</span> data];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            uint8_t buf[<span class="number">1024</span>];</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">            len = [(<span class="built_in">NSInputStream</span> *)aStream read:buf maxLength:<span class="number">1024</span>];  <span class="comment">// 读取数据</span></div><div class="line">            <span class="keyword">if</span> (len) &#123;</div><div class="line">                [data appendBytes:(<span class="keyword">const</span> <span class="keyword">void</span> *)buf length:len];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当NSInputStream在处理流的过程中出现错误时，它将停止流处理并产生一个NSStreamEventErrorOccurred事件给代理。我们同样的上面的代理方法中来处理这个事件。</p>
<h3 id="清理流对象"><a href="#清理流对象" class="headerlink" title="清理流对象"></a>清理流对象</h3><p>当NSInputStream读取到流的结尾时，会发送一个NSStreamEventEndEncountered事件给代理，代理对象应该销毁流对象，此过程应该与创建时相对应，代码清单3演示了关闭和释放流对象的过程。</p>
<p><strong>代理清单3</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)stream:(<span class="built_in">NSStream</span> *)aStream handleEvent:(<span class="built_in">NSStreamEvent</span>)eventCode</div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span> (eventCode) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamEventEndEncountered</span>:</div><div class="line">        &#123;</div><div class="line">            [aStream close];</div><div class="line">            [aStream removeFromRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line">            aStream = <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="写入数据到输出流"><a href="#写入数据到输出流" class="headerlink" title="写入数据到输出流"></a>写入数据到输出流</h2><p>类似于从输入流读取数据，写入数据到输出流时，需要下面几个步骤：</p>
<ol>
<li>使用要写入的数据创建和初始化一个NSOutputStream实例，并设置代理对象</li>
<li>将流对象放到run loop中并打开流</li>
<li>处理流对象发送到代理对象中的事件</li>
<li>如果流对象写入数据到内存，则通过请求NSStreamDataWrittenToMemoryStreamKey属性来获取数据</li>
<li>当没有更多数据可供写入时，处理流对象</li>
</ol>
<p>基本流程与输入流的读取差不多，我们主要介绍不同的地方</p>
<ol>
<li>数据可写入的位置包括文件、C缓存、程序内存和网络socket。</li>
<li>hasSpaceAvailable属性表示是否有空间来写入数据</li>
<li>在stream:handleEvent:中主要处理NSStreamEventHasSpaceAvailable事件，并调用流的write:maxLength方法写数据。代码清单4演示了这一过程。</li>
<li>如果NSOutputStream对象的目标是应用的内存时，在NSStreamEventEndEncountered事件中可能需要从内存中获取流中的数据。我们将调用NSOutputStream对象的propertyForKey:的属性，并指定key为NSStreamDataWrittenToMemoryStreamKey来获取这些数据。</li>
</ol>
<p><strong>代理清单4</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)stream:(<span class="built_in">NSStream</span> *)aStream handleEvent:(<span class="built_in">NSStreamEvent</span>)eventCode</div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span> (eventCode) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamEventHasSpaceAvailable</span>:</div><div class="line">        &#123;</div><div class="line">            uint8_t *readBytes = (uint8_t *)[data mutableBytes];</div><div class="line">            readBytes += byteIndex;</div><div class="line">            <span class="keyword">int</span> data_len = [data length];</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> len = (data_len - byteIndex &gt;= <span class="number">1024</span>) ? <span class="number">1024</span> : (data_len - byteIndex);</div><div class="line">            uint8_t buf[len];</div><div class="line">            </div><div class="line">            (<span class="keyword">void</span>)memcpy(buf, readBytes, len);</div><div class="line">            </div><div class="line">            len = [aStream write:(<span class="keyword">const</span> uint_8 *)buf maxLength:len];</div><div class="line">            byteIndex += len;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要注意的是：当代理接收到NSStreamEventHasSpaceAvailable事件而没有写入任何数据到流时，代理将不再从run loop中接收该事件，直到NSOutputStream对象接收到更多数据，这时run loop会重启NSStreamEventHasSpaceAvailable事件。</p>
<h2 id="流的轮循处理"><a href="#流的轮循处理" class="headerlink" title="流的轮循处理"></a>流的轮循处理</h2><p>在流的处理过程中，除了将流放入run loop来处理流事件外，还可以对流进行轮循处理。我们将流处理数据的过程放到一个循环中，并在循环中不断地去询问流是否有可用的数据供读取(hasBytesAvailable)或可用的空间供写入(hasSpaceAvailable)。当处理到流的结尾时，我们跳出循环结束流的操作。</p>
<p>具体的过程如代码清单5所示</p>
<p><strong>代码清单5</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)createNewFile &#123;</div><div class="line">    <span class="built_in">NSOutputStream</span> *oStream = [[<span class="built_in">NSOutputStream</span> alloc] initToMemory];</div><div class="line">    [oStream open];</div><div class="line">   </div><div class="line">    uint8_t *readBytes = (uint8_t *)[data mutableBytes];</div><div class="line">    uint8_t buf[<span class="number">1024</span>];</div><div class="line">    <span class="keyword">int</span> len = <span class="number">1024</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ([oStream hasSpaceAvailable])</div><div class="line">        &#123;</div><div class="line">            (<span class="keyword">void</span>)strncpy(buf, readBytes, len);</div><div class="line">            readBytes += len;</div><div class="line">            <span class="keyword">if</span> ([oStream write:(<span class="keyword">const</span> uint8_t *)buf maxLength:len] == <span class="number">-1</span>)</div><div class="line">            &#123;</div><div class="line">                [<span class="keyword">self</span> handleError:[oStream streamError]];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            [bytesWritten setIntValue:[bytesWritten intValue]+len];</div><div class="line">            len = (([data length] - [bytesWritten intValue] &gt;= <span class="number">1024</span>) ? <span class="number">1024</span> : [data length] - [bytesWritten intValue]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSData</span> *newData = [oStream propertyForKey:<span class="built_in">NSStreamDataWrittenToMemoryStreamKey</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!newData) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"No data written to memory!"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> processData:newData];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [oStream close];</div><div class="line">    [oStream release];</div><div class="line">    oStream = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种处理方法的问题在于它会阻塞当前线程，直到流处理结束为止，才继续进行后面的操作。而这种问题在处理网络socket流时尤为严重，我们必须等待服务端数据回来后才能继续操作。因此，通常情况下，建议使用run loop方式来处理流事件。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当流出现错误时，会停止对流数据的处理。一个流对象在出现错误时，不能再用于读或写操作，虽然在关闭前可以查询它的状态。</p>
<p>NSStream和NSOutputStream类会以几种方式来告知错误的发生：</p>
<ol>
<li>如果流被放到run loop中，对象会发送一个NSStreamEventErrorOccurred事件到代理对象的stream:handleEvent:方法中</li>
<li>任何时候，可以调用streamStatus属性来查看是否发生错误(返回NSStreamStatusError)</li>
<li>如果在通过调用write:maxLength:写入数据到NSOutputStream对象时返回-1，则发生一个写错误。</li>
</ol>
<p>一旦确定产生错误时，我们可以调用流对象的streamError属性来查看错误的详细信息。在此我们不再举例。</p>
<h2 id="设置Socket流"><a href="#设置Socket流" class="headerlink" title="设置Socket流"></a>设置Socket流</h2><p>在iOS中，NSStream类不支持连接到远程主机，幸运的是CFStream支持。前面已经说过这两者可以通过toll-free桥接来相互转换。使用CFStream时，我们可以调用CFStreamCreatePairWithSocketToHost函数并传递主机名和端口号，来获取一个CFReadStreamRef和一个CFWriteStreamRef来进行通信，然后我们可以将它们转换为NSInputStream和NSOutputStream对象来处理。</p>
<p>具体的处理流程我们会在后期详细讨论。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Streams/Streams.html" target="_blank" rel="external">Stream Programming Guide</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">85</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>
