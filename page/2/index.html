<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="南峰子的技术博客">
<meta property="og:url" content="http://southpeak.github.io/page/2/index.html">
<meta property="og:site_name" content="南峰子的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南峰子的技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://southpeak.github.io/page/2/"/>

  <title> 南峰子的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-68856508-1', 'auto');
  ga('send', 'pageview');
</script>







  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">南峰子的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">攀登，一步一个脚印，方能知其乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-techset">
          <a href="/categories/techset" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fighter-jet"></i> <br />
            
            知识小集
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/categories/swift" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-space-shuttle"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/objectivec" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/cocoa" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-subway"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/categories/translate" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sourcecode">
          <a href="/categories/sourcecode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            源码分析
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/categories/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bicycle"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/20/ios-techset-6/" itemprop="url">
                  iOS知识小集 第6期(2015.10.20)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-20T17:45:14+08:00" content="2015-10-20">
              2015-10-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>天气有点冷啊，冬天快来了～～然后貌似互联网的冬天也来了啊。阿里缩减校招名额，美团融资失败，大众点评与美团报团，百度腾讯调整招聘，一丝丝的凉意啊～～再然后就是网易邮箱密码泄漏，这又是要搞哪样？不过话说我都不记得自己是不是有网易邮箱啊。额，不知道这个冬天的第一场雪什么时候会来。不管怎样，这个冬天还是窝一窝，等来年春暖花开之时再出去浪了。</p>
<p>这一期的主要内容还是三点：</p>
<ol>
<li><code>Xcode 7</code>中<code>Playground</code>中导入并使用图片</li>
<li><code>Playground</code>中的字面量(<code>Xcode 7.1</code>)</li>
<li><code>CAEmitterLayer</code>实现粒子动画</li>
</ol>
<p>内容不是很多，都是些小东西，主要还是一些知识碎片，这也是知识小集的出发点。所以大家就当是饭后的小点心吧。以后争取勤快一点，至少每个月出个两篇吧（what?不是说过好多次了么？）。</p>
<h2 id="Xcode-7中Playground中导入并使用图片"><a href="#Xcode-7中Playground中导入并使用图片" class="headerlink" title="Xcode 7中Playground中导入并使用图片"></a>Xcode 7中Playground中导入并使用图片</h2><p>在<code>Playground</code>中做测试时，可能需要显示图片，这时我们就需要导入一些图片资源。在<code>Playground</code>中，没有像普通工程那样有个单独的<code>Images.xcassets</code>文件夹来存储图片，不过添加图片也是件非常简单的事情。</p>
<p>如果没有显示<code>project navigator</code>，则可以使用快捷键<code>cmd + 0</code>打开。默认情况下，我们可以在<code>project navigator</code>看到两个<code>group</code>。一个是<code>Source</code>，另一个是<code>Resources</code>。其中<code>Resources</code>这个<code>group</code>就是用来放置资源的(包括图片资源)，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/playground%20resource%201.png" alt="image"></p>
<p>选中这个<code>group</code>，然后点击左下角的<code>+</code>按钮，在弹出的菜单中选择<code>Add Files to &#39;Resource&#39;</code>，然后选择要添加的文件，点确定。这样就把资源文件添加到我们的<code>Playground</code>了。</p>
<p>添加完成后，我们就可以使用这些资源了。如要显示图片，则可以使用以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let image: UIImage = UIImage(named: &quot;test.png&quot;)!</div></pre></td></tr></table></figure>
<p>在<code>Playground</code>中显示如下：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/playground%20resource%203.png" alt="image"></p>
<p>另外，初始情况下，<code>Playground</code>的包里面并没有<code>Resources</code>文件夹，在我们添加资源后，会自动创建这个文件夹。然后我们可以在<code>File Inspector</code>中查看文件夹的具体位置，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/playground%20resource%202.png" alt="image"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/recipes/Playground_Help/Chapters/AddResource.html#//apple_ref/doc/uid/TP40015166-CH29-SW1" target="_blank" rel="external">Playground Help - Adding Resources to a Playground</a></li>
<li><a href="http://stackoverflow.com/questions/24069479/swift-playgrounds-with-uiimage" target="_blank" rel="external">Swift playgrounds with UIImage</a></li>
<li><a href="http://natashatherobot.com/xcode-6-add-image-assets-to-playground/" target="_blank" rel="external">XCode 6: How To Add Image Assets To Your Playground</a></li>
</ol>
<h2 id="Playground中的字面量-Xcode-7-1"><a href="#Playground中的字面量-Xcode-7-1" class="headerlink" title="Playground中的字面量(Xcode 7.1)"></a>Playground中的字面量(Xcode 7.1)</h2><p><code>Xcode 7.1</code>新增了一项特性，让我们可以在<code>playground</code>代码中嵌入文件、图片和颜色的字面量。</p>
<p>以图片字面量为例，以往如果需要在<code>playground</code>使用图片资源，我们总是需要通过文件名来指定图片，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let image = UIImage(named: &quot;swift.png&quot;)</div></pre></td></tr></table></figure>
<p>其效果如下：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/Literals%20in%20playerground%20-%20image%20literal%201.png" alt="image"></p>
<p>而在<code>Xcode 7.1</code>中，我们无需在编辑器中键入<code>&quot;swift.png&quot;</code>，而只需将图片从<code>Finder</code>或是资源中拖到我们的代码里面，就可以直接生成一个<code>UIImage</code>对象，如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Literals%20in%20playerground%20-%20image%20literal%202.png?raw=true" alt="image"></p>
<p>可以看到，代码中<code>=</code>右侧的那个类似于小图标的东东就是一个图片字面量。是不是很酷来着？</p>
<p>与图片字面量类似，我们同样可以添加颜色字面量和文件字面量，添加方法可以参考<a href="https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AddColorLiteral.html#//apple_ref/doc/uid/TP40015166-CH50-SW1" target="_blank" rel="external">Adding Color Literals</a>和<a href="https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AddFileLiteral.html#//apple_ref/doc/uid/TP40015166-CH51-SW1" target="_blank" rel="external">Adding File Literals</a>。</p>
<p>当然，除了看上去很酷之外，这也让我们在<code>playground</code>中写代码时能够更快地去编辑这些资源。我们可以通过颜色选择器来插入我们想要的颜色，可以直接从<code>Finder</code>中将文件或图片拖到我们的代码中，而不再需要手动输入颜色值或文件名等。而如果我们想替换资源，只需要双击这些字面量就可以轻松地选择其它的资源。</p>
<h3 id="字面量的表示"><a href="#字面量的表示" class="headerlink" title="字面量的表示"></a>字面量的表示</h3><p>这里有一个问题，在代码中，这些字面量是如何表示的呢？</p>
<p>我们还是以图片字面量为例。选中一个图片字面量，<code>cmd+C</code>一下，然后找个文本编辑器，再<code>cmd+V</code>一下，发现拷贝出来的是如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[#Image(imageLiteral: &quot;swift.png&quot;)#]</div></pre></td></tr></table></figure>
<p>类似于一个构造器。我们再到<code>UIImage</code>中找找，可以看到<code>UIImage</code>有一个扩展，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extension UIImage : _ImageLiteralConvertible &#123;</div><div class="line">    required public convenience init(imageLiteral name: String)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个扩展让<code>UIImage</code>类实现了<code>_ImageLiteralConvertible</code>协议，看这命名，貌似是一个私有的协议。我们来看看它的字义，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// Conforming types can be initialized with image literals (e.g.</div><div class="line">/// `[#Image(imageLiteral: &quot;hi.png&quot;)#]`).</div><div class="line">public protocol _ImageLiteralConvertible &#123;</div><div class="line">    public init(imageLiteral: String)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，实现这个协议的类型就可以使用图片字面量来初始化，即我们上面所看到。当然，我们没办法看到源码是怎么实现的，只能到此为止。</p>
<p>实际上，这些字面量会被转换成平台指定的类型，在官方的<code>swift blog</code>中列出了一个清单，如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Literals%20in%20playerground%20-%20image%20literal%203.png?raw=true" alt="image"></p>
<p>还有件看起来很酷但似乎并不太实用的事是：这些字面量不但可以用在<code>playground</code>中，而且还有可用在工程代码中。不过之所有不太实用，是因为在工程代码中只能以纯文本的形式来展现，而不是像在<code>playground</code>中那样能直观的显示。这种纯文本形式即我们上面拷贝出来的信息，我们再贴一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[#Image(imageLiteral: &quot;swift.png&quot;)#]</div></pre></td></tr></table></figure>
<p>我们码段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let image = [#Image(imageLiteral: &quot;swift.png&quot;)#]</div><div class="line"></div><div class="line">let imageView = UIImageView(image: image)</div><div class="line">imageView.frame = CGRect(x: 100, y: 100, width: 100, height: 100)</div><div class="line"></div><div class="line">self.view.addSubview(imageView)</div></pre></td></tr></table></figure>
<p>其效果如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Literals%20in%20playerground%20-%20image%20literal%204.png?raw=true" alt="image"></p>
<p>从代码实践的角度来看，这种写法看上去并不是那么美啊。不过由于这种写法是与平台相关的，所以如果工程需要同时支持<code>OSX</code>、<code>iOS</code>和<code>tvOS</code>，还是可以考虑用一下的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总之，在<code>playground</code>中使用图片、颜色、文件字面量还是一件很酷的事，它大大提高了我们使用资源的效率，同时也更加直观，用起来还是满爽的。</p>
<p>这里附上官方的实例:<a href="https://developer.apple.com/swift/blog/downloads/Literals.zip" target="_blank" rel="external">Literals.playground</a></p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/swift/blog/" target="_blank" rel="external">Literals in Playgrounds</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AddImageLiteral.html#//apple_ref/doc/uid/TP40015166-CH49-SW1" target="_blank" rel="external">Adding Image Literals</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AddColorLiteral.html#//apple_ref/doc/uid/TP40015166-CH50-SW1" target="_blank" rel="external">Adding Color Literals</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AddFileLiteral.html#//apple_ref/doc/uid/TP40015166-CH51-SW1" target="_blank" rel="external">Adding File Literals</a></li>
</ol>
<h2 id="CAEmitterLayer实现粒子动画"><a href="#CAEmitterLayer实现粒子动画" class="headerlink" title="CAEmitterLayer实现粒子动画"></a>CAEmitterLayer实现粒子动画</h2><p>前段时间<a href="http://weibo.com/u/1956547962" target="_blank" rel="external">@MartinRGB</a>做了个带粒子效果的删除单元格动画，今天问他具体的实现方式，然后他把参考的原始工程发我看了一下。于是就找到了这个：<a href="https://github.com/icanzilb/UIEffectDesignerView" target="_blank" rel="external">UIEffectDesignerView</a>。是<code>github</code>上的一个粒子动画的开源代码。其效果如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/CAEmitterLayer%201.jpg?raw=true" alt="image"></p>
<p>这个动画的实现基于<code>CAEmitterLayer</code>类，它继承自<code>CALayer</code>。这个类是<code>Core Animation</code>提供的用于实现一个粒子发射器系统的类。这个类主要提供了一些属性来设置粒子系统的几何特性。我们可以如下处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let emitter = CAEmitterLayer()</div><div class="line"></div><div class="line">// setup the emitter metrics</div><div class="line">emitter.emitterPosition = CGPoint(x: self.bounds.size.width / 2, y: self.bounds.height / 2)</div><div class="line">emitter.emitterSize = self.bounds.size</div><div class="line"></div><div class="line">// setup the emitter type and mode</div><div class="line">let kEmitterModes = [ kCAEmitterLayerUnordered, kCAEmitterLayerAdditive, kCAEmitterLayerOldestLast, kCAEmitterLayerOldestFirst ]</div><div class="line">emitter.emitterMode = kEmitterModes[ Int(valueFromEffect(&quot;emitterMode&quot;)) ]</div></pre></td></tr></table></figure>
<p><em>需要注意的就是粒子系统会被绘制到层的背影颜色及边框之上。</em></p>
<p>当然，要想发射粒子，就需要有粒子源。一个粒子源定义了发射的粒子的方向及其它属性。在<code>Core Animation</code>中，使用<code>CAEmitterCell</code>对象来表示一个粒子源。<code>CAEmitterCell</code>定义了大量的属性来设置一个粒子源的特性，如粒子的显示特性(<code>color</code>, <code>scale</code>, <code>style</code>)、运动特性(如<code>spin</code>, <code>emissionLatitude</code>)、时间特性(如<code>lifetime</code>, <code>birthRate</code>, <code>velocity</code>)等。我们可以手动来设置这些值，也可以从文件中获取。在<code>UIEffectDesignerView</code>工程中，粒子发射器的信息是放在一个<code>ped</code>文件中，这个文件以<code>JSON</code>格式存储了粒子信息，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    "latitude": 0, </div><div class="line">    "alphaSpeed": 0, </div><div class="line">    "scaleSpeed": 0, </div><div class="line">    "blueRange": 0.33, </div><div class="line">    "width": 120, </div><div class="line">    "texture": "....", </div><div class="line">    "spinRange": 0, </div><div class="line">    "lifetime": 5, </div><div class="line">    "greenSpeed": 0, </div><div class="line">    "aux3": null, </div><div class="line">    "emitterType": 0, </div><div class="line">    "version": 0.1, </div><div class="line">    "zAcceleration": 0, </div><div class="line">    "velocity": 100, </div><div class="line">    "velocityRange": 150, </div><div class="line">    ...</div><div class="line">    "y": 390, </div><div class="line">    "aux2": null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们从文件中把粒子信息读取出来放到一个字典中，然后再将值赋给一个<code>CAEmitterCell</code>对象，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// create new emitter cell</div><div class="line">let emitterCell: CAEmitterCell = CAEmitterCell()</div><div class="line"></div><div class="line">let effect: [String: AnyObject] = loadFile(filename)</div><div class="line"></div><div class="line">...</div><div class="line">emitterCell.birthRate           = effect(&quot;birthRate&quot;)</div><div class="line">emitterCell.lifetime            = effect(&quot;lifetime&quot;)</div><div class="line">emitterCell.lifetimeRange       = effect(&quot;lifetimeRange&quot;)</div><div class="line">emitterCell.velocity            = effect(&quot;velocity&quot;)</div><div class="line">emitterCell.velocityRange       = effect(&quot;velocityRange&quot;)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>之后，我们便可以把这个粒子源添加到粒子系统中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emitter.emitterCells = [ emitterCell ]</div></pre></td></tr></table></figure>
<p>这样就可以发射粒子了。</p>
<p>当然对于一个粒子的特性，除了受粒子源设置的属性影响外，同样也还受粒子系统的一些属性的影响，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emitter.scale = 0.5</div></pre></td></tr></table></figure>
<p>其效果如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/CAEmitterLayer%202.jpg?raw=true" alt="image"></p>
<p>另外，一个粒子源也可以包含一个子粒子源的数组，每个子源都可以作为一个独立的发射源。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://github.com/icanzilb/UIEffectDesignerView" target="_blank" rel="external">UIEffectDesignerView</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CAEmitterLayer_class/" target="_blank" rel="external">CAEmitterLayer Class Reference</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CAEmitterCell_class/index.html" target="_blank" rel="external">CAEmitterCell Class Reference</a></li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="C语言的int类型在Swift中的对应类型"><a href="#C语言的int类型在Swift中的对应类型" class="headerlink" title="C语言的int类型在Swift中的对应类型"></a>C语言的int类型在Swift中的对应类型</h3><p>一言以蔽之，<code>C</code>语言的<code>int</code>类型在<code>Swift</code>中的对应类型是<code>CInt</code>，它是<code>Int32</code>的一个别名。今天一哥们用<code>Swift</code>写了一段测试代码来调用<code>C</code>方法，方法中有个参数是<code>int</code>类型，类似于如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let str = &quot;Hello, World!&quot;</div><div class="line">let a = str.characters.count</div><div class="line">Test.test(a)		// test方法接受一个int类型的参数</div><div class="line"></div><div class="line">// 编译器错误：Cannot convert value of type &apos;Distance&apos;(aka &apos;Int&apos;) to expected argument type Int32</div></pre></td></tr></table></figure>
<p>可以看到我们需要传入一个<code>Int32</code>类型的参数。</p>
<p>之所以使用<code>Int32</code>，是因为在<code>C</code>语言中，<code>int</code>是<code>4</code>个字节，而<code>Swift</code>中的<code>Int</code>则依赖于平台，可能是<code>4</code>个字节，也可能是<code>8</code>个字节。嗯，这个问题是凑数的，点到为止吧。</p>
<h3 id="Swift中获取类型的大小"><a href="#Swift中获取类型的大小" class="headerlink" title="Swift中获取类型的大小"></a>Swift中获取类型的大小</h3><p>在<code>C</code>语言中，如果我们想获取一个变量或数据类型的大小，则可以使用<code>sizeof</code>函数。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a = 10;</div><div class="line">printf(&quot;%lu, %lu&quot;, sizeof(int), sizeof(a));</div><div class="line"></div><div class="line">// 输出：4,4</div></pre></td></tr></table></figure>
<p>在<code>Swift</code>中，也提供了相应的函数。我们可以使用<code>sizeof</code>来获取给定类型的大小，使用<code>sizeofValue</code>来获取给定值的类型的大小。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sizeof(Int)				// 8</div><div class="line"></div><div class="line">let c: Int = 10</div><div class="line">sizeofValue(c)			// 8</div></pre></td></tr></table></figure>
<p>不过，与<code>C</code>语言中的<code>sizeof</code>不同的是，<code>Siwft</code>中的<code>sizeof</code>与<code>sizeofValue</code>不包含任何内存对齐的填充部分。如<code>timeval</code>结构体，在<code>C</code>语言中的大小是<code>16</code>，而在<code>Swift</code>中，则是<code>12</code>，并未包含<code>4</code>个填充字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sizeof(timeval)			// 12</div></pre></td></tr></table></figure>
<p>不过，<code>Swift</code>提供了两个对应的函数，来计算经过内存对齐的类型的大小，即<code>strideof</code>秘<code>strideofValue</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let time = timeval(tv_sec: 10, tv_usec: 10)</div><div class="line"></div><div class="line">strideof(timeval)		// 16</div><div class="line">strideofValue(time)		// 16</div></pre></td></tr></table></figure>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html" target="_blank" rel="external">Using Swift with Cocoa and Objective-C (Swift 2)</a></li>
</ol>
<h3 id="问题：纯Playground中使用Objective-C-C代码"><a href="#问题：纯Playground中使用Objective-C-C代码" class="headerlink" title="问题：纯Playground中使用Objective-C/C代码"></a>问题：纯Playground中使用Objective-C/C代码</h3><p>今天想在纯<code>Playground</code>中测试一下<code>CC_MD5</code>方法，发现没招。因为<code>CC_MD5</code>实际上是一个<code>C</code>方法，需要导入<code>&lt;CommonCrypto/CommonCrypto.h&gt;</code>头文件。这就涉及到<code>Swift</code>与<code>Objective-C</code>混编，需要创建一个桥接文件。但是纯<code>Playground</code>貌似并不支持这么做（搜了一下没搜着解决方法）。于是只能采取曲线救国策略，建立一个基于<code>Swift</code>的工程，在这里面创建桥接文件，导入头文件。然后在工程中创建一个<code>Playground</code>来做测试了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/26/ios-techset-5/" itemprop="url">
                  iOS知识小集 第5期(2015.09.26)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-26T23:42:33+08:00" content="2015-09-26">
              2015-09-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>忽悠一个月又过去了，今年的9月还是挺精彩的。苹果发布<code>iPhone 6s</code>，<code>iPad Pro</code>，<code>iOS 9</code>，让我们又有很多活可做了；然后是<code>XCodeGoast</code>搅得圈内沸沸扬扬的，居然还惊动了<code>CCAV</code>；再然后苏宁的小伙伴们给大家送上了一份中秋礼物，虽然是老代码，但这是要搞哪样啊？不过，正是这些事情为我等屌丝的生活平添了许多的乐趣，还是挺酸爽的嘛。</p>
<p>嗯，回到正题上来。这期的知识小集主要是<code>Swift</code>开发的一些内容，主要的内容有三点：</p>
<ol>
<li><code>Swift</code>中随机数的使用</li>
<li><code>Swift</code>中<code>String</code>与<code>CChar</code>数组的转换</li>
<li><code>Swift</code>中<code>Selector</code>方法的访问权限控制问题</li>
</ol>
<p>相对<code>Objective-C</code>来说，个人觉得<code>Swift</code>写起来大多数时候还是挺爽的，简洁多了，以后有事没事还是多撸撸<code>Swift</code>。</p>
<h2 id="Swift中随机数的使用"><a href="#Swift中随机数的使用" class="headerlink" title="Swift中随机数的使用"></a>Swift中随机数的使用</h2><p>在我们开发的过程中，时不时地需要产生一些随机数。这里我们总结一下<code>Swift</code>中常用的一些随机数生成函数。这里我们将在<code>Playground</code>中来做些示例演示。</p>
<h3 id="整型随机数"><a href="#整型随机数" class="headerlink" title="整型随机数"></a>整型随机数</h3><p>如果我们想要一个整型的随机数，则可以考虑用<code>arc4random</code>系列函数。我们可以通过<code>man arc4random</code>命令来看一下这个函数的定义：</p>
<blockquote>
<p>The arc4random() function uses the key stream generator employed by the arc4 cipher, which uses 8*8 8 bit S-Boxes.  The S-Boxes can be inabout (2^1700) states.  The arc4random() function returns pseudo-random numbers in the range of 0 to (2^32)-1, and therefore has twice the range of rand(3) and random(3).</p>
</blockquote>
<p><code>arc4random</code>使用了<code>arc4密码</code>加密的<code>key stream</code>生成器(请脑补)，产生一个<code>[0, 2^32)</code>区间的随机数(注意是左闭右开区间)。这个函数的返回类型是<code>UInt32</code>。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arc4random()				// 2,919,646,954</div></pre></td></tr></table></figure>
<p>如果我们想生成一个指定范围内的整型随机数，则可以使用<code>arc4random() % upper_bound</code>的方式，其中<code>upper_bound</code>指定的是上边界，如下处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arc4random() % 10			// 8</div></pre></td></tr></table></figure>
<p>不过使用这种方法，在<code>upper_bound</code>不是2的幂次方时，会产生一个所谓<a href="http://eternallyconfuzzled.com/arts/jsw_art_rand.aspx" target="_blank" rel="external">Modulo bias(模偏差)</a>的问题。</p>
<p>我们在控制台中通过<code>man arc4random</code>命令，可以查看<code>arc4random</code>的文档，有这么一条：</p>
<blockquote>
<p>arc4random_uniform() will return a uniformly distributed random number less than upper_bound.  arc4random_uniform() is recommended over constructions like ‘’arc4random() % upper_bound’’ as it avoids “modulo bias” when the upper bound is not a power of two.</p>
</blockquote>
<p>因此可以使用<code>arc4random_uniform</code>，它接受一个<code>UInt32</code>类型的参数，指定随机数区间的上边界<code>upper_bound</code>，该函数生成的随机数范围是<code>[0, upper_bound)</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arc4random_uniform(10)		// 6</div></pre></td></tr></table></figure>
<p>而如果想指定区间的最小值（如随机数区间在<code>[5, 100)</code>），则可以如下处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let max: UInt32 = 100</div><div class="line">let min: UInt32 = 5</div><div class="line">arc4random_uniform(max - min) + min			// 82</div></pre></td></tr></table></figure>
<p>当然，在<code>Swift</code>中也可以使用传统的<code>C</code>函数<code>rand</code>与<code>random</code>。不过这两个函数有如下几个缺点：</p>
<ol>
<li>这两个函数都需要初始种子，通常是以当前时间来确定。</li>
<li>这两个函数的上限在<code>RAND_MAX=0X7fffffff(2147483647)</code>，是<code>arc4random</code>的一半。</li>
<li><code>rand</code>函数以有规律的低位循环方式实现，更容易预测</li>
</ol>
<p>我们以<code>rand</code>为例，看看其使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">srand(UInt32(time(nil)))            // 种子,random对应的是srandom</div><div class="line">rand()								// 1,314,695,483</div><div class="line">rand() % 10							// 8</div></pre></td></tr></table></figure>
<h3 id="64位整型随机数"><a href="#64位整型随机数" class="headerlink" title="64位整型随机数"></a>64位整型随机数</h3><p>在大部分应用中，上面讲到的几个函数已经足够满足我们获取整型随机数的需求了。不过我们看看它们的函数声明，可以发现这些函数主要是针对<code>32</code>位整型来操作的。如果我们需要生成一个<code>64</code>位的整型随机数呢？毕竟现在的新机器都是支持<code>64</code>位的了。</p>
<p>目前貌似没有现成的函数来生成<code>64</code>位的随机数，不过<code>jstn</code>在<code>stackoverflow</code>上为我们分享了他的方法。我们一起来看看。</p>
<p>他首先定义了一个泛型函数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func arc4random &lt;T: IntegerLiteralConvertible&gt; (type: T.Type) -&gt; T &#123;</div><div class="line">    var r: T = 0</div><div class="line">    arc4random_buf(&amp;r, UInt(sizeof(T)))</div><div class="line">    return r</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数中使用了<code>arc4random_buf</code>来生成随机数。让我们通过<code>man arc4random_buf</code>来看看这个函数的定义：</p>
<blockquote>
<p>arc4random_buf() function fills the region buf of length nbytes with ARC4-derived random data.</p>
</blockquote>
<p>这个函数使用<code>ARC4</code>加密的随机数来填充该函数第二个参数指定的长度的缓存区域。因此，如果我们传入的是<code>sizeof(UInt64)</code>，该函数便会生成一个随机数来填充<code>8</code>个字节的区域，并返回给<code>r</code>。那么<code>64</code>位的随机数生成方法便可以如下实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">extension UInt64 &#123;</div><div class="line">    static func random(lower: UInt64 = min, upper: UInt64 = max) -&gt; UInt64 &#123;</div><div class="line">        var m: UInt64</div><div class="line">        let u = upper - lower</div><div class="line">        var r = arc4random(UInt64)</div><div class="line"></div><div class="line">        if u &gt; UInt64(Int64.max) &#123;</div><div class="line">            m = 1 + ~u</div><div class="line">        &#125; else &#123;</div><div class="line">            m = ((max - (u * 2)) + 1) % u</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        while r &lt; m &#123;</div><div class="line">            r = arc4random(UInt64)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return (r % u) + lower</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来试用一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UInt64.random()					// 4758246381445086013</div></pre></td></tr></table></figure>
<p>当然<code>jstn</code>还提供了<code>Int64</code>，<code>UInt32</code>，<code>Int32</code>的实现，大家可以脑补一下。</p>
<h3 id="浮点型随机数"><a href="#浮点型随机数" class="headerlink" title="浮点型随机数"></a>浮点型随机数</h3><p>如果需要一个浮点值的随机数，则可以使用<code>drand48</code>函数，这个函数产生一个<code>[0.0, 1.0]</code>区间中的浮点数。这个函数的返回值是<code>Double</code>类型。其使用如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">srand48(Int(time(nil)))</div><div class="line">drand48()						// 0.396464773760275</div></pre></td></tr></table></figure>
<p>记住这个函数是需要先调用<code>srand48</code>生成一个种子的初始值。</p>
<h3 id="一个小示例"><a href="#一个小示例" class="headerlink" title="一个小示例"></a>一个小示例</h3><p>最近写了一个随机键盘，需要对<code>0-9</code>这几个数字做个随机排序，正好用上了上面的<code>arc4random</code>函数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let arr = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;]</div><div class="line"></div><div class="line">let numbers = arr.sort &#123; (_, _) -&gt; Bool in</div><div class="line">    arc4random() &lt; arc4random()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在闭包中，随机生成两个数，比较它们之间的大小，来确定数组的排序规则。还是挺简单的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实如果翻看一下<code>Swift</code>中关于<code>C</code>函数的<code>API</code>，发现还有许多跟随机数相关的函数，如<code>arc4random_addrandom</code>，<code>erand48</code>等。上面的只是我们经常用到的一些函数，这几个函数基本上够用了。当然，不同场景有不同的需求，我们需要根据实际的需求来选择合适的函数。</p>
<p>以上的代码已上传到<code>github</code>，地址是<a href="https://github.com/southpeak/Swift/tree/master/Basic/Random.playground" target="_blank" rel="external">Random.playground</a>有需要的可以参考一下。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/random/" target="_blank" rel="external">rand(3) / random(3) / arc4random(3) / et al.</a></li>
<li><a href="https://medium.com/@skreutzb/random-swift-102c23cd1755" target="_blank" rel="external">Random Swift</a></li>
<li><a href="http://stackoverflow.com/questions/24007129/how-does-one-generate-a-random-number-in-apples-swift-language" target="_blank" rel="external">How does one generate a random number in Apple’s Swift language?</a></li>
</ol>
<h2 id="Swift中String与CChar数组的转换"><a href="#Swift中String与CChar数组的转换" class="headerlink" title="Swift中String与CChar数组的转换"></a>Swift中String与CChar数组的转换</h2><p>在现阶段<code>Swift</code>的编码中，我们还是有很多场景需要调用一些<code>C</code>函数。在<code>Swift</code>与<code>C</code>的混编中，经常遇到的一个问题就是需要在两者中互相转换字符串。在<code>C</code>语言中，字符串通常是用一个<code>char数组</code>来表示，在<code>Swift</code>中，是用<code>CChar数组</code>来表示。从<code>CChar</code>的定义可以看到，其实际上是一个<code>Int8</code>类型，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// The C &apos;char&apos; type.</div><div class="line">///</div><div class="line">/// This will be the same as either `CSignedChar` (in the common</div><div class="line">/// case) or `CUnsignedChar`, depending on the platform.</div><div class="line">public typealias CChar = Int8</div></pre></td></tr></table></figure>
<p>如果我们想将一个<code>String</code>转换成一个<code>CChar数组</code>，则可以使用<code>String</code>的<code>cStringUsingEncoding</code>方法，它是<code>String</code>扩展中的一个方法，其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/// Returns a representation of the `String` as a C string</div><div class="line">/// using a given encoding.</div><div class="line">@warn_unused_result</div><div class="line">public func cStringUsingEncoding(encoding: NSStringEncoding) -&gt; [CChar]?</div></pre></td></tr></table></figure>
<p>参数指定的是编码格式，我们一般指定为<code>NSUTF8StringEncoding</code>，因此下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let str: String = &quot;abc1个&quot;</div><div class="line"></div><div class="line">// String转换为CChar数组</div><div class="line">let charArray: [CChar] = str.cStringUsingEncoding(NSUTF8StringEncoding)!</div></pre></td></tr></table></figure>
<p>其输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[97, 98, 99, 49, -28, -72, -86, 0]</div></pre></td></tr></table></figure>
<p>可以看到<code>&quot;个&quot;</code>字由三个字节表示，这是因为<code>Swift</code>的字符串是<code>Unicode</code>编码格式，一个字符可能由1个或多个字节组成。另外需要注意的是<code>CChar</code>数组的最后一个元素是<code>0</code>，它表示的是一个字符串结束标志符<code>\n</code>。</p>
<p>我们知道，在<code>C</code>语言中，一个数组还可以使用指针来表示，所以字符串也可以用<code>char *</code>来表示。在<code>Swift中</code>，指针是使用<code>UnsafePointer</code>或<code>UnsafeMutablePointer</code>来包装的，因此，<code>char指针</code>可以表示为<code>UnsafePointer&lt;CChar&gt;</code>，不过它与<code>[CChar]</code>是两个不同的类型，所以以下代码会报编译器错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Error: Cannot convert value of type &apos;[CChar]&apos; to specified type &apos;UnsafePointer&lt;CChar&gt;&apos;</div><div class="line">let charArray2: UnsafePointer&lt;CChar&gt; = str.cStringUsingEncoding(NSUTF8StringEncoding)!</div></pre></td></tr></table></figure>
<p>不过有意思的是我们可以直接将<code>String</code>字符串传递给带有<code>UnsafePointer&lt;CChar&gt;</code>参数的函数或方法，如以下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func length(s: UnsafePointer&lt;CChar&gt;) &#123;</div><div class="line">    print(strlen(s))</div><div class="line">&#125;</div><div class="line"></div><div class="line">length(str)</div><div class="line"></div><div class="line">// 输出：7\n</div></pre></td></tr></table></figure>
<p>而<code>String</code>字符串却不能传递给带有<code>[CChar]</code>参数的函数或方法，如以下代码会报错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func length2(s: [CChar]) &#123;</div><div class="line">    print(strlen(s))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Error: Cannot convert value of type &apos;String&apos; to expected argument type &apos;[CChar]&apos;</div><div class="line">length2(str)</div></pre></td></tr></table></figure>
<p>实际上，在<code>C</code>语言中，我们在使用数组参数时，很少以数组的形式来定义参数，则大多是通过指针方式来定义数组参数。</p>
<p>如果想从<code>[CChar]</code>数组中获取一上<code>String</code>字符串，则可以使用<code>String</code>的<code>fromCString</code>方法，其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/// Creates a new `String` by copying the nul-terminated UTF-8 data</div><div class="line">/// referenced by a `CString`.</div><div class="line">///</div><div class="line">/// Returns `nil` if the `CString` is `NULL` or if it contains ill-formed</div><div class="line">/// UTF-8 code unit sequences.</div><div class="line">@warn_unused_result</div><div class="line">public static func fromCString(cs: UnsafePointer&lt;CChar&gt;) -&gt; String?</div></pre></td></tr></table></figure>
<p>从注释可以看到，它会将<code>UTF-8</code>数据拷贝以新字符串中。如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let chars: [CChar] = [99, 100, 101, 0]</div><div class="line">let str2: String = String.fromCString(chars)!</div><div class="line"></div><div class="line">// 输出：cde</div></pre></td></tr></table></figure>
<p>这里需要注意的一个问题是，<code>CChar</code>数组必须以<code>0</code>结束，否则会有不可预料的结果。在我的<code>Playground</code>示例代码中，如果没有<code>0</code>，报了以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Execution was interrupted. reason: EXC_BAD_INSTRUCTION</div></pre></td></tr></table></figure>
<p>还有可能出现的情况是<code>CChar</code>数组的存储区域正好覆盖了之前某一对象的区域，这一对象有一个可以表示字符串结尾的标识位，则这时候，<code>str2</code>输出的可能是<code>&quot;cde1一&quot;</code>。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>在<code>Swift</code>中，<code>String</code>是由独立编码的<code>Unicode</code>字符组成的，即<code>Character</code>。一个<code>Character</code>可能包括一个或多个字节。所以将<code>String</code>字符串转换成<code>C</code>语言的<code>char *</code>时，数组元素的个数与<code>String</code>字符的个数不一定相同(即在<code>Swift</code>中，与<code>str.characters.count</code>计算出来的值不一定相等)。这一点需要注意。另外还需要注意的就是将<code>CChar</code>数组转换为<code>String</code>时，数组最后一个元素应当为字符串结束标志符，即<code>0</code>。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://forums.developer.apple.com/thread/9386" target="_blank" rel="external">UTF8String</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_String_Structure/#//apple_ref/swift/structcm/String/s:ZFSS11fromCStringFMSSFGVSs13UnsafePointerVSs4Int8_GSqSS_" target="_blank" rel="external">String Structure Reference</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/swift/chapter2/03_Strings_and_Characters.html#counting_characters" target="_blank" rel="external">The Swift Programming Language中文版</a></li>
</ol>
<h2 id="Swift中Selector方法的访问权限控制问题"><a href="#Swift中Selector方法的访问权限控制问题" class="headerlink" title="Swift中Selector方法的访问权限控制问题"></a>Swift中Selector方法的访问权限控制问题</h2><p>今天用<code>Swift</code>写了个视图，在视图上加个手势，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">panGestureRecognizer = UIPanGestureRecognizer(target: self, action: &quot;beginDragged:&quot;)</div><div class="line">addGestureRecognizer(panGestureRecognizer)</div></pre></td></tr></table></figure>
<p>运行了下程序，然后崩溃了。崩溃日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[**.SwipeCardView beginDragged:]: unrecognized selector sent to instance 0x125e5bc10</div></pre></td></tr></table></figure>
<p>而我已经在<code>SwipeCardView</code>类中定义了<code>beginDragged:</code>方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private func beginDragged(gestureRecognizer: UIPanGestureRecognizer) &#123;</div><div class="line">	// ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于我并不想将<code>beginDragged:</code>方法暴露出去，所以将其定义为一个<code>private</code>方法。方法的定义一切正常，手势的<code>Selector</code>方法也设置正常，却报了未找到方法的异常。那问题可能就应该在访问权限问题上了。</p>
<p>我们知道<code>Selector</code>是<code>Objective-C</code>的产物，它用于在运行时作为一个键值去找到对应方法的实现。一个<code>Objective-C</code>的方法是由<code>objc_method</code>结束体定义的，其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct objc_method &#123;</div><div class="line"></div><div class="line">    SEL method_name                 	OBJC2_UNAVAILABLE;  // 方法名</div><div class="line">    char *method_types                  OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就要求<code>selector</code>引用的方法必须对<code>ObjC</code>运行时是可见的。而<code>Swift</code>是静态语言，虽然继承自<code>NSObject</code>的类默认对<code>ObjC</code>运行时是可见的，但如果方法是由<code>private</code>关键字修饰的，则方法默认情况下对<code>ObjC</code>运行时并不是可见的，所以就导致了以上的异常：运行时并没找到<code>SwipeCardView</code>类的<code>beginDragged:</code>方法。</p>
<p>所以，我们必须将<code>private</code>修饰的方法暴露给运行时。正确的做法是在 <code>private</code> 前面加上 <code>@objc</code> 关键字，这样就OK了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@objc private func beginDragged(gestureRecognizer: UIPanGestureRecognizer) &#123;</div><div class="line">	// ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外需要注意的是，如果我们的类是纯<code>Swift</code>类，而不是继承自<code>NSObject</code>，则不管方法是<code>private</code>还是<code>internal</code>或<code>public</code>，如果要用在<code>Selector</code>中，都需要加上<code>@objc</code>修饰符。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://swifter.tips/selector/" target="_blank" rel="external">SELECTOR</a></li>
<li><a href="http://stackoverflow.com/questions/24007650/selector-in-swift" target="_blank" rel="external">@selector() in Swift?</a></li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="Swift中枚举项设置相同的值"><a href="#Swift中枚举项设置相同的值" class="headerlink" title="Swift中枚举项设置相同的值"></a>Swift中枚举项设置相同的值</h3><p>在<code>Objective-C</code>及<code>C</code>语言中，在枚举中我们可以设置两个枚举项的值相等，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, Type) &#123;</div><div class="line">    TypeIn      = 0,</div><div class="line">    TypeOut     = 1,</div><div class="line">    TypeInOut   = 2,</div><div class="line">    TypeDefault = TypeIn</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在上例中，我们让枚举项<code>TypeDefault</code>的值等于<code>TypeIn</code>。</p>
<p>而在<code>Swift</code>中，要求枚举项的<code>rawValue</code>是唯一的，如果像下面这样写，则编译器会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum Type: UInt &#123;</div><div class="line">    case In         = 0</div><div class="line">    case Out        = 1</div><div class="line">    case InOut      = 2</div><div class="line">    case Default    = 0		// Error: Raw value for enum case is not unique</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那如果我们希望上面枚举中<code>Default</code>的值与<code>In</code>的值一样，那应该怎么做呢？这时候就需要充分利用<code>Swift</code>中<code>enum</code>的特性了。我们知道，<code>Swift</code>中的<code>enum</code>与结构体、类一样，可以为其定义属性和方法，所以我们可以如下处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">enum Type: UInt &#123;</div><div class="line">    case In         = 0</div><div class="line">    case Out        = 1</div><div class="line">    case InOut      = 2</div><div class="line"></div><div class="line">    static var Default: Type &#123;</div><div class="line">        get &#123;</div><div class="line">            return .In</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将<code>Default</code>定义为<code>Type</code>的一个静态只读属性，这个属性与枚举的其它枚举项的调用方式是一样的，可以如下调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let type: Type = .Default</div></pre></td></tr></table></figure>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://stackoverflow.com/questions/28037772/swift-enum-multiple-cases-with-the-same-value" target="_blank" rel="external">Swift enum multiple cases with the same value</a></li>
</ol>
<h3 id="Swift中如何实现IBOutletCollection"><a href="#Swift中如何实现IBOutletCollection" class="headerlink" title="Swift中如何实现IBOutletCollection"></a>Swift中如何实现IBOutletCollection</h3><p>在使用IB做界面开发时，我们经常需要将界面上的元素连接到我们的代码中。<code>IBOutlet</code>和<code>IBAction</code>就是专门用来做这事的两个关键字。另外在<code>Objective-C</code>还提供了一个伪关键字<code>IBOutletCollection</code>，它的实际作用是将界面上的一组相同的控件连接到一个数组中。具体可以参考<a href="http://southpeak.github.io/blog/2015/05/10/ioszhi-shi-xiao-ji-di-%5B%3F%5D-qi-2015-dot-05-dot-10/">iOS知识小集 第一期(2015.05.10)</a>中的<code>IBOutletCollection</code>一节。</p>
<p>在<code>Swift</code>中，同样提供了<code>@IBOutlet</code>和<code>@IBAction</code>实现<code>Objective-C</code>中对应的功能，不过却没提供<code>@IBOutletCollection</code>来将一组相同控件连接到一个数组中。那如果我们想实现类似的功能，需要怎么处理呢？</p>
<p>实际上，我们在IB中选中一组相同的控件，然后将其连到到代码中时，会生成一个<code>IBOutlet</code>修饰的控件数组，类似于如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@IBOutlet var numberButtons: [UIButton]!</div></pre></td></tr></table></figure>
<p>这就是<code>Swift</code>中类<code>IBOutletCollection</code>的处理。如果需要往数组中添加新建的对应的控件，则只需要在代码前面的小圆点与UI上的控件做个连线就OK了。而如果要想将控件从数组中移除，则只需要将对应的连接关系移除就可以了。</p>
<h4 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://southpeak.github.io/blog/2015/05/10/ioszhi-shi-xiao-ji-di-%5B%3F%5D-qi-2015-dot-05-dot-10/">iOS知识小集 第一期(2015.05.10)</a></li>
<li><a href="http://stackoverflow.com/questions/24052459/swift-iboutletcollection-equivalent" target="_blank" rel="external">Swift - IBOutletCollection equivalent</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/23/sourcecode-mmtweenanimation/" itemprop="url">
                  MMTweenAnimation实现分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-23T20:18:24+08:00" content="2015-09-23">
              2015-09-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sourcecode/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先来个效果图吧：</p>
<p><img src="https://raw.githubusercontent.com/adad184/MMTweenAnimation/master/Images/2.gif" alt="image"></p>
<p>这是<code>MMTweenAnimation</code>库实现的一个弹跳动画。<code>MMTweenAnimation</code>基于Facebook的<code>pop</code>动画库，它提供了10套自定义的动画曲线，分别是：<code>Back</code>、<code>Bounce</code>、<code>Circ</code>、<code>Cubic</code>、<code>Elastic</code>、<code>Expo</code>、<code>Quad</code>、<code>Quart</code>、<code>Quint</code>、<code>Sine</code>。具体的效果可以参考<a href="https://github.com/adad184/MMTweenAnimation" target="_blank" rel="external">MMTweenAnimation</a>。</p>
<p>在这里，我们主要来<code>MMTweenAnimation</code>的具体实现及使用。</p>
<p>我们知道，动画实际上是许多帧静止的画面，以一定的速度连续播放，由于肉眼视觉残象产生的错觉，因此我们感觉画面是活动的。这就是动画的基本原理。所以，我们要做的就是按一定的速率去播放帧，在每一帧中计算曲线的路径，并将其绘制到界面上。这主要涉及到曲线的插值算法。</p>
<h3 id="主要部件"><a href="#主要部件" class="headerlink" title="主要部件"></a>主要部件</h3><p><code>MMTweenAnimation</code>的主体类主要有两个：<code>MMTweenAnimation</code>和<code>MMTweenFunction</code>。<code>MMTweenFunction</code>类主要定义各种插值算法，<code>MMTweenAnimation</code>主要是实现动画操作。</p>
<h4 id="MMTweenFunction类"><a href="#MMTweenFunction类" class="headerlink" title="MMTweenFunction类"></a>MMTweenFunction类</h4><p><code>MMTweenFunction</code>类主要是实现各种插值算法。这些插值算法分别10类，即上面列出的10套动画。而每套根据不同的缓动方式，又分为<code>EaseIn</code>、<code>EaseOut</code>、<code>EaseInOut</code>三种，因此<code>MMTweenAnimation</code>库实际上是实现了30种动画。每个插值算法都实现为一个闭包函数，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typealias MMTweenFunctionBlock = (t: <span class="built_in">CFTimeInterval</span>,            <span class="comment">// 当前时间与起始时间的差值</span></div><div class="line">                                  b: Double,                    <span class="comment">// 起点</span></div><div class="line">                                  c: Double,                    <span class="comment">// 起点与终点的差值</span></div><div class="line">                                  d: <span class="built_in">CFTimeInterval</span>) -&gt; Double  <span class="comment">// 动画持续时间</span></div></pre></td></tr></table></figure>
<p>而每个动画的插值都是根据数学公式算法出来的，我们以图例中的<code>Bounce-EaseOut</code>动画为例，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let bounceOut: MMTweenFunctionBlock = &#123; (t, b, c, d) -&gt; Double <span class="keyword">in</span></div><div class="line">    let k: Double = <span class="number">2.75</span></div><div class="line">    var t1 = t / d</div><div class="line">    <span class="keyword">if</span> t1 &lt; (<span class="number">1</span> / k) &#123;</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1) + b</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> t1 &lt; (<span class="number">2</span> / k) &#123;</div><div class="line">        t1 -= <span class="number">1.5</span> / k</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1 + <span class="number">0.75</span>) + b</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> t1 &lt; (<span class="number">2.5</span> / k) &#123;</div><div class="line">        t1 -= <span class="number">2.25</span> / k</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1 + <span class="number">0.9375</span>) + b</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        t1 -= <span class="number">2.625</span> / k</div><div class="line">        <span class="keyword">return</span> c * (<span class="number">7.5625</span> * t1 * t1 + <span class="number">0.984375</span>) + b</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计算出来的插值将会用于计算当前帧的终点值。</p>
<h4 id="MMTweenAnimation类"><a href="#MMTweenAnimation类" class="headerlink" title="MMTweenAnimation类"></a>MMTweenAnimation类</h4><p><code>MMTweenAnimation</code>是实现动画的主体类。这个类继承自<code>pop</code>的<code>POPCustomAnimation</code>，<code>POPCustomAnimation</code> 直接继承自<code>PopAnimation</code>类，用于创建自定义动画的基类，它基本上是一个 <code>display link</code>的方便的转换，来在动画的每一个<code>tick</code>的回调<code>block</code>中驱动自定义的动画。</p>
<p><code>MMTweenAnimation</code>定义了几个基本属性，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MMTweenAnimation: POPCustomAnimation &#123;</div><div class="line">    var animationBlock: MMTweenAnimationBlock?          <span class="comment">// 动画回调</span></div><div class="line">    var fromValue: [<span class="built_in">CGFloat</span>]?                           <span class="comment">// 起点数组</span></div><div class="line">    var toValue: [<span class="built_in">CGFloat</span>]?                             <span class="comment">// 终点数组</span></div><div class="line">    var duration: Double = <span class="number">0.3</span>                          <span class="comment">// 动画时长</span></div><div class="line"></div><div class="line">    <span class="comment">// ......</span></div><div class="line">    var functionBlock: MMTweenFunctionBlock?			<span class="comment">// 动画插值Block</span></div><div class="line">    <span class="comment">// ......</span></div><div class="line"></div><div class="line">    <span class="comment">// ......</span></div><div class="line">    var functionType: MMTweenFunctionType				<span class="comment">// 动画插值类型</span></div><div class="line">    <span class="comment">// ......</span></div><div class="line"></div><div class="line">    <span class="comment">// ......</span></div><div class="line">    var easingType: MMTweenEasingType					<span class="comment">// 动画缓动类型</span></div><div class="line">    <span class="comment">// ......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而<code>MMTweenAnimation</code>类最关键的是定义它的回调<code>block</code>。<code>MMTweenAnimation</code>类定义了一个类方法<code>animation()</code>，在这个方法中，通过调用从父类继承来的便捷初始化方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public convenience init!(block: POPCustomAnimationBlock!)</div></pre></td></tr></table></figure>
<p>来创建一个<code>MMTweenAnimation</code>对象。其实现如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> func animation() -&gt; MMTweenAnimation? &#123;</div><div class="line"></div><div class="line">        let tweaner: MMTweenAnimation = MMTweenAnimation &#123; (target, animation) -&gt; Bool <span class="keyword">in</span></div><div class="line"></div><div class="line">            let anim: MMTweenAnimation = animation as! MMTweenAnimation</div><div class="line"></div><div class="line">            let t = animation.currentTime - animation.beginTime <span class="comment">// 当前时间与起始时间的差值</span></div><div class="line">            let d = anim.duration</div><div class="line"></div><div class="line">            assert(anim.fromValue!.count == anim.toValue!.count, <span class="string">"fromValue.count != toValue.count"</span>)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> t &lt; d &#123;      <span class="comment">// 确保在动画持续时间类才处理</span></div><div class="line">                var values: [<span class="built_in">CGFloat</span>] = [<span class="built_in">CGFloat</span>]()</div><div class="line"></div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;anim.fromValue!.count &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> let functionBlock = anim.functionBlock &#123;     <span class="comment">// 计算插值</span></div><div class="line">                        values.append(<span class="built_in">CGFloat</span>(functionBlock(t: t, b: Double(anim.fromValue![i]), c: Double(anim.toValue![i]) - Double(anim.fromValue![i]), d: d)))</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> let animationBlock = anim.animationBlock &#123;   <span class="comment">// 动画回调，以实现绘制操作</span></div><div class="line">                    animationBlock(time: t, duration: d, values: values, target: target, animation: anim)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> tweaner</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中动画回调的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias MMTweenAnimationBlock = (time: <span class="built_in">CFTimeInterval</span>, duration: <span class="built_in">CFTimeInterval</span>, values: [<span class="built_in">CGFloat</span>], target: AnyObject, animation: MMTweenAnimation) -&gt; Void</div></pre></td></tr></table></figure>
<p>以上两个类便是<code>MMTweenAnimation</code>的主要部件。</p>
<h3 id="动画示例"><a href="#动画示例" class="headerlink" title="动画示例"></a>动画示例</h3><p>有了主要部件，我们就来看看怎么去使用它。<code>MMTweenAnimation</code>给了一个示例，其效果就是开头的图例。为此，<code>MMTweenAnimation</code>定义了类<code>MMPaintView</code>，这个类的主要目的就是绘制上面的曲线，其主要操作如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func addDot(point: <span class="built_in">CGPoint</span>) &#123;</div><div class="line">    __dots.append(point)</div><div class="line">    <span class="comment">// __path = __interpolateCGPointsWithHermite(__dots)</span></div><div class="line">    __path = __interpolateCGPointsWithCatmullRom(__dots)</div><div class="line">    setNeedsDisplay()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法首先是将参数中的点(即每一帧计算出来的终点值)添加到对象的<code>__dots</code>数组中，然后再通过<code>__interpolateCGPointsWithCatmullRom</code>方法创建一条<code>Bezier</code>曲线，最后调用<code>setNeedsDisplay()</code>来重新绘制曲线。</p>
<p>我们先来看看这个点是如何获取到的。在<code>MMAnimationController</code>类，我们定义动画对象时，设置了其动画回调，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__anim!.animationBlock = &#123; [unowned <span class="keyword">self</span>] (diff: <span class="built_in">CFTimeInterval</span>, duration: <span class="built_in">CFTimeInterval</span>, values: [<span class="built_in">CGFloat</span>], target: AnyObject, animation: MMTweenAnimation) -&gt; Void <span class="keyword">in</span></div><div class="line">    let value: <span class="built_in">CGFloat</span> = values[<span class="number">0</span>]          <span class="comment">// 获取当前时间结束点的值</span></div><div class="line"></div><div class="line">    <span class="keyword">self</span>.__dummy!.center = <span class="built_in">CGPoint</span>(x: <span class="keyword">self</span>.__dummy!.center.x, y: value)     <span class="comment">// 计算小红点的中心位置</span></div><div class="line">    <span class="keyword">self</span>.__ball!.center = <span class="built_in">CGPoint</span>(x: <span class="number">50.0</span> + (<span class="built_in">CGRectGetWidth</span>(<span class="built_in">UIScreen</span>.mainScreen().bounds) - <span class="number">150.0</span>) * <span class="built_in">CGFloat</span>(diff / duration), y: value)</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.__paintView!.addDot(<span class="keyword">self</span>.__ball!.center)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个动画回调获取当前时间结束点的值，用于设置小红点的中心位置，同时将这个中心位置的值丢给<code>MMPaintView</code>对象去生成<code>Bezier</code>曲线。</p>
<h3 id="动画渲染操作执行的时间点"><a href="#动画渲染操作执行的时间点" class="headerlink" title="动画渲染操作执行的时间点"></a>动画渲染操作执行的时间点</h3><p>知道了<code>MMTweenAnimation</code>库的主要部件，我们现在来看看动画是如何被驱动的。我们在<code>MMTweenAnimation</code>类的<code>animation()</code>方法中，在动画回调的起始位置打个断点，运行一下程序，看看调用栈，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/MMTweenAnimation-stack.png" alt="image"></p>
<p>可以看到在<code>Run Loop</code>中执行了一个观察者回调，在这个回调中调用了<code>POPAnimator</code>对象的<code>_scheduleProcessPendingList</code>方法的一个<code>block</code>回调，一直追溯到我们的动画操作。也就是说，是在<code>Run Loop</code>的某个时刻执行了一次动画的渲染。</p>
<p>我们再从代码入手，来看看动画执行代码是什么时候添加到Run Loop中的。在<code>MMAnimationController</code>的<code>viewDidAppear</code>方法中，有如下调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__dummy!.pop_addAnimation(__anim, forKey: <span class="string">"center"</span>)</div></pre></td></tr></table></figure>
<p>其中<code>pop_addAnimation</code>方法是<code>POPAnimator</code>类中定义的。顺着代码，我们最终可以找到<code>_scheduleProcessPendingList</code>的定义，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)_scheduleProcessPendingList</div><div class="line">&#123;</div><div class="line">  <span class="comment">// ......</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!_pendingListObserver) &#123;</div><div class="line">    __<span class="keyword">weak</span> POPAnimator *weakSelf = <span class="keyword">self</span>;</div><div class="line">	</div><div class="line">    <span class="comment">// 添加Run Loop监听器</span></div><div class="line">    _pendingListObserver = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopBeforeWaiting | kCFRunLoopExit, <span class="literal">false</span>, POPAnimationApplyRunLoopOrder, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</div><div class="line">      [weakSelf _processPendingList];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (_pendingListObserver) &#123;</div><div class="line">      <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), _pendingListObserver,  kCFRunLoopCommonModes);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在这个方法中创建了一个<code>Run Loop</code>的观察者，这个观察者在<code>Run Loop</code>的<code>kCFRunLoopBeforeWaiting</code>或<code>kCFRunLoopExit</code>阶段时会执行监听回调处理函数。回调函数中调用了<code>_processPendingList</code>方法，然后从调用栈里面可以看到，一直会执行到<code>MMTweenAnimation</code>的动画闭包中，即我们打断点的地方。</p>
<p>OK，动画渲染时间点找着了，那整个流程就可以完整拼接起来了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>MMTweenAnimation</code>的实现并不复杂，只要了解了动画的基本原理和其中的插值算法，再加上一些<code>pop</code>动画的基础知识，基本上就OK了。要想做出很牛B的动画，还是需要大量的数学知识。其实在<code>MMTweenAnimation</code>库中，除了那10套插值算法外，在<code>MMPaintView</code>类中，计算<code>Bezier</code>的控制点时，还用到了Catmull-Rom样条与Hermite样条，大家有兴趣可以研究一下。</p>
<p><code>MMTweenAnimation</code>初始源码是<code>Objective-C</code>实现的，我将它用<code>Swift</code>重写了一遍，并放在github上，地址是<a href="https://github.com/southpeak/Swift/tree/master/Animation/MMTweenAnimation-Swift" target="_blank" rel="external">MMTweenAnimation-Swift</a>，有兴趣可以看一下。</p>
<p>本想放在知识小集中，但由于篇幅稍长，所以独立成篇。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://github.com/adad184/MMTweenAnimation" target="_blank" rel="external">MMTweenAnimation</a></li>
<li><a href="http://objccn.io/issue-12-6/" target="_blank" rel="external">交互式动画</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/14/app-transport-security-ats/" itemprop="url">
                  App Transport Security(ATS)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-14T19:47:32+08:00" content="2015-09-14">
              2015-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/something/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近下载<code>iOS 9 GM</code>版，然后跑了下我们的应用，发现有些网络请求失效了。先前在<code>WWDC 2015</code>上了解到<code>iOS 9</code>将要求网络请求使用<code>HTTPS</code>协议，但一直没有在<code>iOS 9 beta</code>版上跑过。现在这个问题突显出来了，所以搜了一些博文研究了一下。</p>
<p>我们知道，<code>Apple</code>在安全及用户隐私方面做了很多工作，包括沙盒机制、代码签名、禁用私有API等。而在今年6月份的<code>WWDC 2015</code>上，<code>Apple</code>又提出了<code>App Transport Security(ATS)</code>的概念。这一特性的主要意图是为我们的<code>App</code>与服务器之间提供一种安全的通信方式，以防止中间人窃听、篡改传输的数据。这一特性在<code>iOS 9+</code>和<code>OS X 10.11+</code>中是默认的支持项。这一概念的提出，也将意味着<code>Apple</code>将会慢慢转向支持<code>HTTPS</code>，而可能放弃<code>HTTP</code>。</p>
<h2 id="App-Transport-Security技术要求"><a href="#App-Transport-Security技术要求" class="headerlink" title="App Transport Security技术要求"></a>App Transport Security技术要求</h2><p>我们先来看看<code>ATS</code>的技术要求（参考<a href="https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/" target="_blank" rel="external">App Transport Security Technote</a>）：</p>
<ul>
<li>The server must support at least Transport Layer Security (TLS) protocol version 1.2.</li>
<li>Connection ciphers are limited to those that provide forward secrecy (see the list of ciphers below.)</li>
<li>Certificates must be signed using a SHA256 or better signature hash algorithm, with either a 2048 bit or greater RSA key or a 256 bit or greater Elliptic-Curve (ECC) key.</li>
</ul>
<p>可以看到服务端必须支持<code>TLS 1.2</code>或以上版本；必须使用支持前向保密的密码；证书必须使用<code>SHA-256</code>或者更好的签名<code>hash</code>算法来签名，如果证书无效，则会导致连接失败。</p>
<p><code>Apple</code>认为这是目前保证通信安全性的最佳实践，特别是使用<code>TLS 1.2</code>和前向保密。当然，相信<code>Apple</code>也会与时俱进，不断的修正<code>ATS</code>，以保证网络通信的安全性。</p>
<h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><p>在<code>iOS 9+</code>和<code>OS X 10.11+</code>中，如果我们的<code>App</code>使用了<code>NSURLConnection</code>、<code>CFURL</code> 或者<code>NSURLSession</code>相关的<code>API</code>来进行数据通信的话，则默认是通过<code>ATS</code>的方式来传输数据。在此配置下，如果我们使用<code>HTTP</code>来进行通信，则会导致请求失败，并报以下错误：</p>
<blockquote>
<p>The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.</p>
</blockquote>
<p>这样意味着如果使用<code>ATS</code>，将无法支持<code>HTTP</code>协议（我们测试了一下，由于我们的登录服务是使用<code>HTTP</code>协议，目前在<code>iOS 9</code>下已无法正常登录）。相信目前还有大量的应用是通过HTTP协议来访问服务器的。而要让所有的应用都转向支持<code>HTTPS</code>，显然是一件费时费力的事（与今年年头所有应用必须支持64位<code>ARM</code>不同，那次只是在客户端层面，而<code>ATS</code>涉及到服务端，影响面更大）。所以苹果提供了一种兼容方案，下面我们就来看看如何处理。</p>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>考虑到现实因素，我们可能并不想使用默认配置，或者至少需要一个过渡时期。为此，<code>Apple</code>允许我们在<code>Info.plist</code>文件中来自行配置以修改默认设置(<code>Exceptions</code>)，下表是一些键值及对应的类型和说明：</p>
<table>
<thead>
<tr>
<th>键</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSAppTransportSecurity</td>
<td>Dictionary</td>
<td>配置ATS的顶层键值</td>
</tr>
<tr>
<td>NSAllowsArbitraryLoads</td>
<td>Boolean</td>
<td>这是一个开关键，设置不在NSExceptionDomains列表中的其它域ATS特性。默认值是NO，如果设置为YES，则会关闭其它域的ATS特性。</td>
</tr>
<tr>
<td>NSExceptionDomains</td>
<td>Dictionary</td>
<td>特定域列表</td>
</tr>
<tr>
<td><domain-name-for-exception-as-string></domain-name-for-exception-as-string></td>
<td>Dictionary</td>
<td>需要自定义配置的域名，键是对应的域名，如www.apple.com</td>
</tr>
<tr>
<td>NSExceptionMinimumTLSVersion</td>
<td>String</td>
<td>指定域所需要的TLS的最低版本。有效值包括：TLSv1.0、TLSv1.1、TLSv1.2。默认值是TLSv1.2</td>
</tr>
<tr>
<td>NSExceptionRequiresForwardSecrecy</td>
<td>Boolean</td>
<td>指定域是否需要支持前向保密。默认值是YES</td>
</tr>
<tr>
<td>NSExceptionAllowsInsecureHTTPLoads</td>
<td>Boolean</td>
<td>指定域的请求是否允许使用不安全的HTTP。使用这个键来访问没有证书，或者证书是自签名、过期或主机名不匹配的证书。默认值为NO，表示需要使用HTTPS。</td>
</tr>
<tr>
<td>NSIncludesSubdomains</td>
<td>Boolean</td>
<td>指定自定义的值是否应用到域的所有子域中。默认值是NO</td>
</tr>
<tr>
<td>NSThirdPartyExceptionMinimumTLSVersion</td>
<td>String</td>
<td>类似于NSExceptionMinimumTLSVersion键，只不过指定的是应用本身无法控制的第三方组件的域所需要的TLS的最低版本。</td>
</tr>
<tr>
<td>NSThirdPartyExceptionRequiresForwardSecrecy</td>
<td>Boolean</td>
<td>同上。指定第三方组件的域是否需要支持前向保密</td>
</tr>
<tr>
<td>NSThirdPartyExceptionAllowsInsecureHTTPLoads</td>
<td>Boolean</td>
<td>同上。指定第三方组件的域的请求是否使用HTTPS</td>
</tr>
</tbody>
</table>
<p>通过设置上面的这些值，就可以精确的配置应用中访问的不同域的<code>ATS</code>特性。如下是<a href="http://www.neglectedpotential.com/2015/06/working-with-apples-application-transport-security/" target="_blank" rel="external">WORKING WITH APPLE’S APP TRANSPORT SECURITY</a>中给出的一个配置示例：</p>
<p><img src="http://neglectedpotential.com/wp-content/uploads/ATSInfoplist.png" alt="image"></p>
<p>另外，在这篇文章中，也为我们例举了几种常见的配置，我们一起来看一下：</p>
<h3 id="Example-A：所有请求均使用ATS"><a href="#Example-A：所有请求均使用ATS" class="headerlink" title="Example A：所有请求均使用ATS"></a>Example A：所有请求均使用ATS</h3><p>这当然是默认配置，只需要我们使用<code>NSURLSession</code>, <code>NSURLConnection</code>或者<code>CFURL</code>来做网络请求。当然只有<code>iOS 9.0+</code>以及<code>OS X 10.11+</code>才支持这一特性。</p>
<h3 id="Example-B：配置部分域不使用ATS"><a href="#Example-B：配置部分域不使用ATS" class="headerlink" title="Example B：配置部分域不使用ATS"></a>Example B：配置部分域不使用ATS</h3><p>如果我们希望部分域的请求不使用<code>ATS</code>，则我们可以将这些域放在<code>NSExceptionDomains</code>列表中来进行配置，以修改这些域的<code>ATS</code>默认配置。如果我们希望指定域及其所有子域都禁用<code>ATS</code>，则设置<code>NSExceptionAllowsInsecureHTTPLoads</code>为YES并将<code>NSIncludesSubdomains</code>设置为YES，如下配置：</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleB.png" alt="image"></p>
<p>那当然，如果我们不想在指定域完全禁用<code>ATS</code>，则可以设置 <code>NSExceptionRequiresForwardSecrecy</code> 和<code>NSExceptionMinimumTLSVersion</code> 来指定更多的规则。</p>
<h3 id="Example-C：禁用ATS，但部分域使用ATS"><a href="#Example-C：禁用ATS，但部分域使用ATS" class="headerlink" title="Example C：禁用ATS，但部分域使用ATS"></a>Example C：禁用ATS，但部分域使用ATS</h3><p>如果我们想要在应用中禁用<code>ATS</code>特性，则可以设置<code>NSAllowsArbitraryLoads</code>的值为YES，这样所有的请求将不会使用<code>ATS</code>。而如果我们希望部分域使用<code>ATS</code>，则如同<code>Example B</code>中那样来设置指定域的 <code>NSExceptionAllowsInsecureHTTPLoads</code> 的值为NO，这样就要求指定域必须使用ATS来进行数据传输。如下配置：</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleC.png" alt="image"></p>
<h3 id="Example-D：降级ATS"><a href="#Example-D：降级ATS" class="headerlink" title="Example D：降级ATS"></a>Example D：降级ATS</h3><p>在一些情况下，我们可能需要使用<code>ATS</code>，但可能现实情况并不完全能够支持<code>ATS</code>的最佳实践。比如我们的服务端支持<code>TLS 1.2</code>，但却不支持前向保密。这种情况下，我们可以让指定域支持<code>ATS</code>，但同时禁用前向保密，这种情况下就可以设置<code>NSExceptionRequiresForwardSecrecy</code>为NO。同样，如果我们希望使用前向保密，但可以<code>TLS</code>的版本只是1.1，则我们可以设置 <code>NSExceptionMinimumTLSVersion</code> 的值为<code>TSLv1.1</code>，如下配置：</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleD.png" alt="image"></p>
<h3 id="Example-E：完全禁用ATS的更友好的方式"><a href="#Example-E：完全禁用ATS的更友好的方式" class="headerlink" title="Example E：完全禁用ATS的更友好的方式"></a>Example E：完全禁用ATS的更友好的方式</h3><p>如果想完全禁用<code>ATS</code>，我们可以在<code>Info.plist</code>中简单的设置<code>NSAllowsArbitraryLoads</code>为YES，如下配置：</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleE.png" alt="image"></p>
<p>以上几种情况基本上囊括了自定义<code>ATS</code>特性的所有情况。大家可以根据需要来自定义配置。</p>
<h2 id="Certificate-Transparency"><a href="#Certificate-Transparency" class="headerlink" title="Certificate Transparency"></a>Certificate Transparency</h2><p>对于<code>ATS</code>，大部分安全特性都是默认可用的，不过<code>Certificate Transparency</code>是必须配置的。<code>Certificate Transparency</code>的概念在<code>wiki</code>中的解释是：</p>
<blockquote>
<p>Certificate Transparency (CT) is an experimental IETF open standard and open source framework for monitoring and auditing digital certificates. Through a system of certificate logs, monitors, and auditors, certificate transparency allows website users and domain owners to identify mistakenly or maliciously issued certificates and to identify certificate authorities (CAs) that have gone rogue.</p>
</blockquote>
<p>它主要是让web站点的用户和域所有者可以识别出错误的或恶意的证书，以及识别出无效的证书颁发机构。</p>
<p>如果我们的证书支持<code>certificate transparency</code>，那么我们可以设置<code>NSRequiresCertificateTransparency</code>键来启用这一功能。而不如证书不支持<code>certificate transparency</code>，则该功能默认总是关闭的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Apple</code>提出<code>App Transport Security</code>这一特性，是为了保证用户数据的安全传输。安全因素始终是网络开发中一个重要的因素，相信会有越来越多的站点会转向<code>HTTPS</code>。而<code>Apple</code>作为业内技术的一个风向标，也会带动这一趋势的发展。所以，还不支持<code>HTTPS</code>的筒子们可以行为起来了。</p>
<p>这篇文章更多的是对App开发文档<a href="https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/" target="_blank" rel="external">App Transport Security Technote</a>和<a href="http://www.neglectedpotential.com/2015/06/working-with-apples-application-transport-security/" target="_blank" rel="external">WORKING WITH APPLE’S APP TRANSPORT SECURITY</a>两篇文章的整理。<a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">iOS程序犭袁</a>在他的<a href="https://github.com/ChenYilong/iOS9AdaptationTips" target="_blank" rel="external">iOS9AdaptationTips</a>一文中有更多有意思的内容，大家可以参考。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/" target="_blank" rel="external">App Transport Security Technote</a></li>
<li><a href="http://www.neglectedpotential.com/2015/06/working-with-apples-application-transport-security/" target="_blank" rel="external">WORKING WITH APPLE’S APP TRANSPORT SECURITY</a></li>
<li><a href="https://developer.apple.com/videos/wwdc/2015/?id=711" target="_blank" rel="external">WWDC 2015视频：Networking with NSURLSession</a></li>
<li><a href="http://willowtreeapps.com/blog/app-transport-security/" target="_blank" rel="external">App Transport Security</a></li>
<li><a href="https://github.com/ChenYilong/iOS9AdaptationTips" target="_blank" rel="external">iOS9AdaptationTips</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/31/translate-10-things-you-need-to-know-about-cocoa-auto-layout/" itemprop="url">
                  10 Things You Need to Know About Cocoa Auto Layout
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-31T22:49:30+08:00" content="2015-08-31">
              2015-08-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文由<a href="http://oleb.net/" target="_blank" rel="external">Ole Begemann</a>在<code>2013.3.31</code>发表于其个人博客，地址是<a href="http://oleb.net/blog/2013/03/things-you-need-to-know-about-cocoa-autolayout/" target="_blank" rel="external">10 Things You Need to Know About Cocoa Auto Layout</a></p>
<blockquote>
<p>译注：原文发表的时间有点早，主要是针对<code>Xcode 4.x</code>时代的<code>Auto Layout</code>，特别是第二部分”<code>Interface Builder</code>中的<code>Auto Layout</code>“，所以有些内容已经过时了。不过还是有很多可借鉴的地方。特别感谢<a href="http://weibo.com/u/1438670852" target="_blank" rel="external">@叶孤城</a> 叶大在微博中的分享，以及对译文的校对。</p>
</blockquote>
<p>第一次使用<code>Cocoa Auto Layout</code>时，感觉它与<code>Cocoa</code>开发者所熟知的<code>springs-struts</code>模式有很大的不同。尽管<code>Auto Layout</code>有点复杂，但我发现只需要了解一些基本规则就可以使用它。本文就来列出这些规则。</p>
<h2 id="Auto-Layout通用概念"><a href="#Auto-Layout通用概念" class="headerlink" title="Auto Layout通用概念"></a>Auto Layout通用概念</h2><h3 id="1-经验法则：每个维度至少有两个约束"><a href="#1-经验法则：每个维度至少有两个约束" class="headerlink" title="1.经验法则：每个维度至少有两个约束"></a>1.经验法则：每个维度至少有两个约束</h3><p>在每个维度(水平与竖直)上，一个视图的位置和大小由三个值来定义：头部空间(<code>leading space</code>)，大小和尾部空间(<code>trailing space</code>)<em>[注释1]</em>。一个视图的<code>leading</code>和<code>trailing</code>空间可以相对于父视图来定义，也可以相对于视图层级架构中的兄弟视图来定义。一般来说，我们的布局约束必须满足这两个值，以便计算第三个值(<code>size</code>)。其结果是，一个标准的视图在每个维度上必须至少有两个约束，以明确视图的布局。</p>
<h3 id="2-拥抱固有大小-Intrinsic-Size"><a href="#2-拥抱固有大小-Intrinsic-Size" class="headerlink" title="2.拥抱固有大小(Intrinsic Size)"></a>2.拥抱固有大小(Intrinsic Size)</h3><p>一些控件，如标签和按钮，都有一个所谓的固有大小(<code>Intrinsic Size</code>)。视控件的不同，固有大小可以在水平或竖直或同时两个方向上有效。当一个控件没有明确的宽度和高度约束时，就会使用它的固有大小作为约束。这允许我们在每个方向上只使用一个显式约束就可以创建明确的布局(相对于上面第1条规则)，并让控件可以根据自身的内容来自动调整大小。这是在本地化中创建一个最佳布局的关键。</p>
<h2 id="Interface-Builder中的Auto-Layout"><a href="#Interface-Builder中的Auto-Layout" class="headerlink" title="Interface Builder中的Auto Layout"></a>Interface Builder中的Auto Layout</h2><blockquote>
<p>更新于2014.3.3：当我写这篇文章时，<code>Xcode</code>的版本是4.x。到了<code>Xcode 5</code>时，<code>Interface Builder</code>对<code>Auto Layout</code>的处理已以有了显著的改变，所以下面的一些内容已经不再有效(特别是第3、4条)。<code>Xcode</code>现在允许<code>Interface Builder</code>在创建模棱两可的布局，并在编译时添加<code>missing constraints</code>来明确一个布局。这使得在开发过程中，原型的设计和快速变更来得更加简单。第5、6条在<code>Xcode 5</code>中仍然是有效的。</p>
</blockquote>
<p><code>Interface Builder</code>中的<code>Auto Layout</code>编辑器似乎有自己的想法。理解<code>Xcode</code>的工程师为什么这样设计，可以让我们使用它是不至于太过沮丧。</p>
<p><img src="http://oleb.net/media/interface-builder-constraints-editor-context-menu.png" alt="image"></p>
<p>图1：如果某个约束会导致模棱两可的布局，<code>IB</code>是不允许我们删除它的</p>
<h3 id="3-IB总是不让你创建一个模棱两可的布局"><a href="#3-IB总是不让你创建一个模棱两可的布局" class="headerlink" title="3.IB总是不让你创建一个模棱两可的布局"></a>3.IB总是不让你创建一个模棱两可的布局</h3><p><code>IB</code>的主要目标是保护我们自己。它决不会让我们创建一个模棱两可的布局。这意味着<code>IB</code>在我们将一个视图放到一个布局中时，会自动为我们创建约束。沿着IB的自动引导来放置我们的视图，以帮助<code>IB</code>正确的猜测我们想把视图放哪。</p>
<h3 id="4-在我们删除一个已存在的约束之前，必须创建另外一个约束"><a href="#4-在我们删除一个已存在的约束之前，必须创建另外一个约束" class="headerlink" title="4.在我们删除一个已存在的约束之前，必须创建另外一个约束"></a>4.在我们删除一个已存在的约束之前，必须创建另外一个约束</h3><p>使用<code>Size Inspector</code>来查看一个指定视图的所有约束。当一个约束的<code>Delete</code>菜单项是置灰时，就表示删除这个约束会导致混乱，因此这是不允许的。在删除它之前，我们必须创建至少一个自定义约束来取代它。</p>
<p><img src="http://oleb.net/media/interface-builder-create-constraints-ui.png" alt="image"></p>
<p>图2：创建新的布局约束的<code>IB</code>界面</p>
<p>为了创建一个新的约束，在布局中选择一个或多个视图，然后使用画布右下角的三个不显眼按钮来创建约束。这都是很容易被忽视的。</p>
<h3 id="5-不要显式地调整控件的大小"><a href="#5-不要显式地调整控件的大小" class="headerlink" title="5.不要显式地调整控件的大小"></a>5.不要显式地调整控件的大小</h3><p>尝试不要显式地设置一个控件的大小。只要我们不手动去改变它们的大小，大部分控件都会根据它们的内容来调整自己的大小，并使用固有大小(<code>intrinsic size</code>)来创建一个完美的、内容敏感的布局。这对于需要做本地化的UI尤其重要。一旦我们(无意或有意地)手动调整了控件的大小，<code>IB</code>将创建一个很难摆脱的显式大小约束。为了回归到固有大小，可以使用<code>Editor</code> &gt; <code>Size to Fit Content</code>命令。</p>
<h3 id="6-避免过早优化"><a href="#6-避免过早优化" class="headerlink" title="6.避免过早优化"></a>6.避免过早优化</h3><p>不幸的是，使用<code>Interface Builder</code>来做自动布局将迫使我们更加小心。例如，如果我们发现需要使用一个控件来替换另一个，从布局中删除原始控件可能导致IB自动创建一组新的约束，当我们插入新的控件时，需要再次手动修改这些约束。因此，在我们的布局仍处于不稳定状态时去优化我们的约束，可能并不是一个好主意。更好的是在它更稳定时再去优化它。</p>
<h2 id="代码中的Auto-Layout"><a href="#代码中的Auto-Layout" class="headerlink" title="代码中的Auto Layout"></a>代码中的Auto Layout</h2><p>在<code>Interface Builder</code>中使用<code>Auto Layout</code>中可能很快就会有种挫折感，因此更多的开发者喜欢在代码中使用<code>Auto Layout</code>。</p>
<h3 id="7-忘记Frame吧"><a href="#7-忘记Frame吧" class="headerlink" title="7.忘记Frame吧"></a>7.忘记Frame吧</h3><p>忘记<code>frame</code>属性吧。不要直接设置它。一个视图的<code>frame</code>在自动布局过程中会被自动设置，而不是一个输入结果。我们可以通过改变约束来改变<code>frame</code>。这将强迫我们改变看待<code>UI</code>的方式。不用再去考虑位置和大小了，而是考虑每个视图相对于它的兄弟视图和父视图的位置。这与<code>CSS</code>没有什么不同。</p>
<h3 id="8-别忘了禁用Autoresizing-Masks"><a href="#8-别忘了禁用Autoresizing-Masks" class="headerlink" title="8.别忘了禁用Autoresizing Masks"></a>8.别忘了禁用Autoresizing Masks</h3><p>为了保证代码的向后兼容性，<code>sprints-struts</code>模式仍然是默认的。对于每一个代码创建的需要使用<code>Auto Layout</code>的视图，请调用<code>setTranslatesAutoresizingMaskIntoConstraints:NO</code>。</p>
<h3 id="9-多留意Debugger控制台"><a href="#9-多留意Debugger控制台" class="headerlink" title="9.多留意Debugger控制台"></a>9.多留意Debugger控制台</h3><p>当我们写约束时，应该多留意<code>Debugger</code>控制台。我发现<code>Apple</code>关于模棱两可的约束或未满足的约束的错误日志总是可以帮助我们快速定位问题。这个可以参考<a href="https://developer.apple.com/library/ios/documentation/userexperience/conceptual/AutolayoutPG/ResolvingIssues/ResolvingIssues.html#//apple_ref/doc/uid/TP40010853-CH17-SW14" target="_blank" rel="external">Apple’s debugging tips in the Cocoa Auto Layout Guide</a>。</p>
<h3 id="10-让约束动起来，而不是frame"><a href="#10-让约束动起来，而不是frame" class="headerlink" title="10.让约束动起来，而不是frame"></a>10.让约束动起来，而不是frame</h3><p>在<code>Auto Layout</code>中，我们需要重新考虑动画。我们不再可以简单的动画一个视图的<code>frame</code>了；如果我们这样做了，视图将在动画完成后自动恢复到<code>Auto Layout</code>计算出来的位置和大小上。相反，我们需要直接动画布局的约束。要做到这一点，或者修改已存在的约束（我们可以为<code>IB</code>中创建的约束声明<code>IBOutlet</code>变量），也可以添加一个新的约束，然后在一个动画<code>block</code>中给我们的视图发送<code>layoutIfNeeded</code>消息。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol>
<li>在垂直维度，<code>leading</code>和<code>trailing</code>空间分别表示为<code>top</code>和<code>bottom</code>空间。在水平维度，我们可以选择两个方向：“<code>Leading to Trailing</code>” 或者是 “<code>Left to Right</code>”。这两者的不同之处在于，如果本地语言是从右到左的，则”<code>Leading to Trailing</code>”表示的就是”<code>Right to Left</code>”。在大多数时候，我们需要的是“<code>Leading to Trailing</code>”。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/15/ios-techset-4/" itemprop="url">
                  iOS知识小集 第4期(2015.08.15)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-15T22:21:02+08:00" content="2015-08-15">
              2015-08-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>又欠了一屁股债了。积累了一大堆的问题放在那，就是没有整理。不能怪别人，也能怪自己了，犯起懒来，啥事也不想做，连喜爱的户外运动也给拉下了，掐指一算，居然大半年没出去了。然后经常看到老驴子们出去玩耍，回来就是一通的美图，心里那个痒痒啊。</p>
<p>回到正题吧，这次的知识小集知识点不多，还是三个：</p>
<ol>
<li><code>ARC</code>与<code>MRC</code>的性能对比</li>
<li><code>Bitcode</code></li>
<li>在<code>Swift</code>中实现<code>NS_OPTIONS</code></li>
</ol>
<p>篇幅超过了预期，大家慢慢看，如有问题还请指正。</p>
<h2 id="ARC与MRC的性能对比"><a href="#ARC与MRC的性能对比" class="headerlink" title="ARC与MRC的性能对比"></a>ARC与MRC的性能对比</h2><p><code>MRC</code>似乎已经是一个上古时代的话题了，不过我还是绕有兴致的把它翻出来。因为，今天我被一个问题问住了：<code>ARC</code>与<code>MRC</code>的性能方面孰优劣。确实，之前没有对比过。</p>
<p>先来做个测试吧。首先我们需要一个计时辅助函数，我选择使用<code>mach_absolute_time</code>，计算时间差的函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">double subtractTimes(uint64_t endTime, uint64_t startTime) &#123;</div><div class="line"></div><div class="line">    uint64_t difference = endTime - startTime;</div><div class="line">    static double conversion = 0.0;</div><div class="line"></div><div class="line">    if(conversion == 0.0) &#123;</div><div class="line"></div><div class="line">        mach_timebase_info_data_t info;</div><div class="line">        kern_return_t err = mach_timebase_info(&amp;info);                       //Convert the timebaseinto seconds</div><div class="line"></div><div class="line">        if(err == 0)</div><div class="line">            conversion = 1e-9 * (double) info.numer / (double) info.denom;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return conversion * (double)difference;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后定义两个测试类，一个是<code>ARC</code>环境下的，一个是<code>MRC</code>环境下的，分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">// Test1.m</div><div class="line">+ (void)test &#123;</div><div class="line"></div><div class="line">    uint64_t start,stop;</div><div class="line"></div><div class="line">    start = mach_absolute_time();</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">        NSArray *array = [[NSArray alloc] init];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    stop = mach_absolute_time();</div><div class="line"></div><div class="line">    double diff = subtractTimes(stop, start);</div><div class="line"></div><div class="line">    NSLog(@&quot;ARC total time in seconds = %f\n&quot;, diff);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Test2.m</div><div class="line">// 在target-&gt;Build Phases-&gt;Compile Sources中，添加编译标识-fno-objc-arc</div><div class="line">+ (void)test &#123;</div><div class="line"></div><div class="line">    uint64_t start,stop;</div><div class="line"></div><div class="line">    start = mach_absolute_time();</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">        NSArray *array = [[NSArray alloc] init];</div><div class="line">        [array release];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    stop = mach_absolute_time();</div><div class="line"></div><div class="line">    double diff = subtractTimes(stop, start);</div><div class="line"></div><div class="line">    NSLog(@&quot;MRC total time in seconds = %f\n&quot;, diff);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多运行几组测试，然后挑两组吧来看看，数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// A组</div><div class="line">ARC total time in seconds = 0.077761</div><div class="line">MRC total time in seconds = 0.072469</div><div class="line"></div><div class="line">// B组</div><div class="line">ARC total time in seconds = 0.075722</div><div class="line">MRC total time in seconds = 0.101671</div></pre></td></tr></table></figure>
<p>从上面的数据可以看到，<code>ARC</code>与<code>MRC</code>各有快慢的情况。即使上升到统计学的角度，<code>ARC</code>也只是以轻微的优势胜出。看来我的测试姿势不对，并没有证明哪一方占绝对的优势。</p>
<p>嗯，那我们再来看看官方文档是怎么说的吧。在<a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a>中有这么一段话：</p>
<blockquote>
<p><strong>Is ARC slow?</strong></p>
<p>It depends on what you’re measuring, but generally “no.” The compiler efficiently eliminates many extraneous<code>retain</code>/<code>release</code> calls and much effort has been invested in speeding up the Objective-C runtime in general. In particular, the common “return a retain/autoreleased object” pattern is much faster and does not actually put the object into the autorelease pool, when the caller of the method is ARC code.</p>
<p>One issue to be aware of is that the optimizer is not run in common debug configurations, so expect to see a lot more <code>retain</code>/<code>release</code> traffic at <code>-O0</code> than at <code>-Os</code>.</p>
</blockquote>
<p>再来看看别人的数据吧。<code>Stefan Itterheim</code>在<a href="http://www.learn-cocos2d.com/2013/03/confirmed-arc-slow/" target="_blank" rel="external">Confirmed: Objective-C ARC is slow. Don’t use it! (sarcasm off)</a>一文中给出了大量的测试数据。这篇文章是<code>2013.3.20</code>号发表的。<code>Stefan Itterheim</code>通过他的测试得出一个结论</p>
<blockquote>
<p>ARC is generally faster, and ARC can indeed be slower</p>
</blockquote>
<p>嗯，有些矛盾。不过在文章中，<code>Steffen Itterheim</code>指出大部分情况下，<code>ARC</code>的性能是更好的，这主要得益于一些底层的优化以及<code>autorelease pool</code>的优化，这个从官方文档也能看到。但在一些情况下，<code>ARC</code>确实是更慢，<code>ARC</code>会发送一些额外的<code>retain/release</code>消息，如一些涉及到临时变量的地方，看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// this is typical MRC code:</div><div class="line">&#123;</div><div class="line">    id object = [array objectAtIndex:0];</div><div class="line">    [object doSomething];</div><div class="line">    [object doAnotherThing];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// this is what ARC does (and what is considered best practice under MRC):</div><div class="line">&#123;</div><div class="line">    id object = [array objectAtIndex:0];</div><div class="line">    [object retain]; // inserted by ARC</div><div class="line">    [object doSomething];</div><div class="line">    [object doAnotherThing];</div><div class="line">    [object release]; // inserted by ARC</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，在带对象参数的方法中，也有类似的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// this is typical MRC code:</div><div class="line">-(void) someMethod:(id)object</div><div class="line">&#123;</div><div class="line">    [object doSomething];</div><div class="line">    [object doAnotherThing];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// this is what ARC does (and what is considered best practice under MRC):</div><div class="line">-(void) someMethod:(id)object</div><div class="line">&#123;</div><div class="line">    [object retain]; // inserted by ARC</div><div class="line">    [object doSomething];</div><div class="line">    [object doAnotherThing];</div><div class="line">    [object release]; // inserted by ARC</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些些额外的<code>retain/release</code>操作也成了降低<code>ARC</code>环境下程序性能的罪魁祸首。但实际上，之所以添加这些额外的<code>retain/release</code>操作，是为了保证代码运行的正确性。如果只是在单线程中执行这些操作，可能确实没必要添加这些额外的操作。但一旦涉及以多线程的操作，问题就来了。如上面的方法中，<code>object</code>完全有可能在<code>doSoming</code>和<code>doAnotherThing</code>方法调用之间被释放。为了避免这种情况的发生，便在方法开始处添加了<code>[object retain]</code>，而在方法结束后，添加了<code>[object release]</code>操作。</p>
<p>如果想了解更多关于<code>ARC</code>与<code>MRC</code>性能的讨论，可以阅读一下<a href="http://stackoverflow.com/questions/12527286/are-there-any-concrete-study-of-the-performance-impact-of-using-arc" target="_blank" rel="external">Are there any concrete study of the performance impact of using ARC?</a>与<a href="http://mjtsai.com/blog/2013/09/10/arc-vs-mrc-performance/" target="_blank" rel="external">ARC vs. MRC Performance</a>，在此就不过多的摘抄了。</p>
<p>实际上，即便是<code>ARC</code>的性能不如<code>MRC</code>，我们也应该去使用<code>ARC</code>，因此它给我们带来的好处是不言而喻的。我们不再需要像使用<code>MRC</code>那样，去过多的关注内存问题(虽然内存是必须关注的)，而将更多的时间放在我们真正关心的事情上。如果真的对性能非常关切的话，可以考虑直接用<code>C</code>或<code>C++</code>。反正我是不会再回到<code>MRC</code>时代了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://stackoverflow.com/questions/12527286/are-there-any-concrete-study-of-the-performance-impact-of-using-arc" target="_blank" rel="external">Are there any concrete study of the performance impact of using ARC?</a></li>
<li><a href="http://mjtsai.com/blog/2013/09/10/arc-vs-mrc-performance/" target="_blank" rel="external">ARC vs. MRC Performance</a></li>
<li><a href="http://www.learn-cocos2d.com/2013/03/confirmed-arc-slow/" target="_blank" rel="external">Confirmed: Objective-C ARC is slow. Don’t use it! (sarcasm off)</a></li>
<li><a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a></li>
</ol>
<h2 id="Bitcode"><a href="#Bitcode" class="headerlink" title="Bitcode"></a>Bitcode</h2><p>今天试着用<code>Xcode 7 beta 3</code>在真机(<code>iOS 8.3</code>)上运行一下我们的工程，结果发现工程编译不过。看了下问题，报的是以下错误：</p>
<blockquote>
<p>ld: ‘/Users/**/Framework/SDKs/PolymerPay/Library/mobStat/lib**SDK.a(**ForSDK.o)’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64</p>
</blockquote>
<p>得到的信息是我们引入的一个第三方库不包含<code>bitcode</code>。嗯，不知道<code>bitcode</code>是啥，所以就得先看看这货是啥了。</p>
<h3 id="Bitcode是什么？"><a href="#Bitcode是什么？" class="headerlink" title="Bitcode是什么？"></a>Bitcode是什么？</h3><p>找东西嘛，最先想到的当然是先看官方文档了。在<a href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35" target="_blank" rel="external">App Distribution Guide - App Thinning (iOS, watchOS)</a>一节中，找到了下面这样一个定义：</p>
<blockquote>
<p><em>Bitcode</em> is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.</p>
</blockquote>
<p>说的是<code>bitcode</code>是被编译程序的一种中间形式的代码。包含<code>bitcode</code>配置的程序将会在<code>App store</code>上被编译和链接。<code>bitcode</code>允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到<code>App store</code>上。</p>
<p>嗯，看着挺高级的啊。</p>
<p>继续看，在<a href="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html" target="_blank" rel="external">What’s New in Xcode-New Features in Xcode 7</a>中，还有一段如下的描述</p>
<blockquote>
<p><strong>Bitcode.</strong> When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary.</p>
</blockquote>
<p>当我们提交程序到<code>App store</code>上时，<code>Xcode</code>会将程序编译为一个中间表现形式(<code>bitcode</code>)。然后<code>App store</code>会再将这个<code>bitcode</code>编译为可执行的<code>64</code>位或<code>32</code>位程序。</p>
<p>再看看这两段描述都是放在<code>App Thinning</code>(App瘦身)一节中，可以看出其与包的优化有关了。喵大(<a href="http://weibo.com/onevcat" target="_blank" rel="external">@onevcat</a>)在其博客<a href="http://onevcat.com/2015/06/ios9-sdk/" target="_blank" rel="external">开发者所需要知道的 iOS 9 SDK 新特性</a>中也描述了<code>iOS 9</code>中苹果在<code>App</code>瘦身中所做的一些改进，大家可以转场到那去研读一下。</p>
<h3 id="Bitcode配置"><a href="#Bitcode配置" class="headerlink" title="Bitcode配置"></a>Bitcode配置</h3><p>在上面的错误提示中，提到了如何处理我们遇到的问题：</p>
<blockquote>
<p>You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64</p>
</blockquote>
<p>要么让第三方库支持，要么关闭<code>target</code>的<code>bitcode</code>选项。</p>
<p>实际上在<code>Xcode 7</code>中，我们新建一个<code>iOS</code>程序时，<code>bit code</code>选项默认是设置为<code>YES</code>的。我们可以在<code>”Build Settings”</code>-&gt;<code>”Enable Bitcode”</code>选项中看到这个设置。</p>
<p>不过，我们现在需要考虑的是三个平台：<code>iOS</code>，<code>Mac OS</code>，<code>watchOS</code>。</p>
<ul>
<li>对应<code>iOS</code>，<code>bitcode</code>是可选的。</li>
</ul>
<ul>
<li>对于<code>watchOS</code>，<code>bitcode</code>是必须的。</li>
</ul>
<ul>
<li><code>Mac OS</code>不支持<code>bitcode</code>。</li>
</ul>
<p>如果我们开启了<code>bitcode</code>，在提交包时，下面这个界面也会有个<code>bitcode</code>选项：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Art/6_ios_review_dist_profile_submit_2x.png" alt="image"></p>
<blockquote>
<p>盗图，我的应用没办法在这个界面显示<code>bitcode</code>，因为依赖于第三方的库，而这个库不支持<code>bitcode</code>，暂时只能设置<code>ENABLE_BITCODE为NO</code>。</p>
<p>所以，如果我们的工程需要支持<code>bitcode</code>，则必要要求所有的引入的第三方库都支持<code>bitcode</code>。我就只能等着公司那些大哥大姐们啥时候提供一个新包给我们了。</p>
</blockquote>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>如上面所说，<code>bitcode</code>是一种中间代码。<code>LLVM</code>官方文档有介绍这种文件的格式，有兴趣的可以移步<a href="http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format" target="_blank" rel="external">LLVM Bitcode File Format</a>。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35" target="_blank" rel="external">App Distribution Guide - App Thinning (iOS, watchOS)</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html" target="_blank" rel="external">What’s New in Xcode-New Features in Xcode 7</a></li>
<li><a href="http://onevcat.com/2015/06/ios9-sdk/" target="_blank" rel="external">开发者所需要知道的 iOS 9 SDK 新特性</a></li>
<li><a href="http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format" target="_blank" rel="external">LLVM Bitcode File Format</a></li>
</ol>
<h2 id="在Swift中实现NS-OPTIONS"><a href="#在Swift中实现NS-OPTIONS" class="headerlink" title="在Swift中实现NS_OPTIONS"></a>在Swift中实现NS_OPTIONS</h2><p>从<code>Xcode 4.5</code>以后，我们在<code>Objective-C</code>中使用<code>NS_ENUM</code>和<code>NS_OPTIONS</code>来定义一个枚举，以替代<code>C</code>语言枚举的定义方式。其中<code>NS_ENUM</code>用于定义普通的枚举，<code>NS_OPTIONS</code>用于定义选项类型的枚举。</p>
<p>而到了<code>Swift</code>中，枚举增加了更多的特性。它可以包含原始类型(不再局限于整型)以及相关值。正是由于这些原因，枚举在<code>Swift</code>中得到了更广泛的应用。在<code>Foundation</code>中，<code>Objective-C</code>中的<code>NS_ENUM</code>类型的枚举，都会自动转换成<code>Swift</code>中<code>enum</code>，并且更加精炼。以<code>Collection View</code>的滚动方向为例，在<code>Objective-C</code>中，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, UICollectionViewScrollDirection) &#123;</div><div class="line">	UICollectionViewScrollDirectionVertical,</div><div class="line">	UICollectionViewScrollDirectionHorizontal</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>而在<code>Swift</code>中，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">enum UICollectionViewScrollDirection : Int &#123;</div><div class="line">	case Vertical</div><div class="line">	case Horizontal</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>精练多了吧，看着舒服多了，还能少码两个字。我们自己定义枚举时，也应该采用这种方式。</p>
<p>不过对于<code>Objective-C</code>中<code>NS_OPTIONS</code>类型的枚举，<code>Swift</code>中的实现似乎就没有那么美好了。</p>
<p>我们再来对比一下<code>UICollectionViewScrollPosition</code>的定义吧，在<code>Objective-C</code>中，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, UICollectionViewScrollPosition) &#123;</div><div class="line">    UICollectionViewScrollPositionNone                 = 0,</div><div class="line"></div><div class="line">    // The vertical positions are mutually exclusive to each other, but are bitwise or-able with the horizontal scroll positions.</div><div class="line">    // Combining positions from the same grouping (horizontal or vertical) will result in an NSInvalidArgumentException.</div><div class="line">    UICollectionViewScrollPositionTop                  = 1 &lt;&lt; 0,</div><div class="line">    UICollectionViewScrollPositionCenteredVertically   = 1 &lt;&lt; 1,</div><div class="line">    UICollectionViewScrollPositionBottom               = 1 &lt;&lt; 2,</div><div class="line"></div><div class="line">    // Likewise, the horizontal positions are mutually exclusive to each other.</div><div class="line">    UICollectionViewScrollPositionLeft                 = 1 &lt;&lt; 3,</div><div class="line">    UICollectionViewScrollPositionCenteredHorizontally = 1 &lt;&lt; 4,</div><div class="line">    UICollectionViewScrollPositionRight                = 1 &lt;&lt; 5</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>而在<code>Swift 2.0</code>中，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct UICollectionViewScrollPosition : OptionSetType &#123;</div><div class="line">    init(rawValue: UInt)</div><div class="line"></div><div class="line">    static var None: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line"></div><div class="line">    // The vertical positions are mutually exclusive to each other, but are bitwise or-able with the horizontal scroll positions.</div><div class="line">    // Combining positions from the same grouping (horizontal or vertical) will result in an NSInvalidArgumentException.</div><div class="line">    static var Top: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line">    static var CenteredVertically: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line">    static var Bottom: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line"></div><div class="line">    // Likewise, the horizontal positions are mutually exclusive to each other.</div><div class="line">    static var Left: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line">    static var CenteredHorizontally: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line">    static var Right: UICollectionViewScrollPosition &#123; get &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>额，光看代码，不看实现，这也是化简为繁的节奏啊。</p>
<p>为什么要这样做呢？<code>Mattt</code>给了我们如下解释：</p>
<blockquote>
<p>Well, the same integer bitmasking tricks in C don’t work for enumerated types in Swift. An <code>enum</code> represents a type with a closed set of valid options, without a built-in mechanism for representing a conjunction of options for that type. An <code>enum</code> could, ostensibly, define a case for all possible combinations of values, but for <code>n &gt; 3</code>, the combinatorics make this approach untenable.</p>
</blockquote>
<p>意思是<code>Swift</code>不支持<code>C</code>语言中枚举值的整型掩码操作的技巧。在<code>Swift</code>中，一个枚举可以表示一组有效选项的集合，但却没有办法支持这些选项的组合操作(“&amp;”、”|”等)。理论上，一个枚举可以定义选项值的任意组合值，但对于<code>n &gt; 3</code>这种操作，却无法有效的支持。</p>
<p>为了支持类<code>NS_OPTIONS</code>的枚举，<code>Swift 2.0</code>中定义了<code>OptionSetType</code>协议【在<code>Swift 1.2</code>中是使用<code>RawOptionSetType</code>，相比较而言已经改进了不少】，它的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/// Supplies convenient conformance to `SetAlgebraType` for any type</div><div class="line">/// whose `RawValue` is a `BitwiseOperationsType`.  For example:</div><div class="line">///</div><div class="line">///     struct PackagingOptions : OptionSetType &#123;</div><div class="line">///       let rawValue: Int</div><div class="line">///       init(rawValue: Int) &#123; self.rawValue = rawValue &#125;</div><div class="line">///     </div><div class="line">///       static let Box = PackagingOptions(rawValue: 1)</div><div class="line">///       static let Carton = PackagingOptions(rawValue: 2)</div><div class="line">///       static let Bag = PackagingOptions(rawValue: 4)</div><div class="line">///       static let Satchel = PackagingOptions(rawValue: 8)</div><div class="line">///       static let BoxOrBag: PackagingOptions = [Box, Bag]</div><div class="line">///       static let BoxOrCartonOrBag: PackagingOptions = [Box, Carton, Bag]</div><div class="line">///     &#125;</div><div class="line">///</div><div class="line">/// In the example above, `PackagingOptions.Element` is the same type</div><div class="line">/// as `PackagingOptions`, and instance `a` subsumes instance `b` if</div><div class="line">/// and only if `a.rawValue &amp; b.rawValue == b.rawValue`.</div><div class="line">protocol OptionSetType : SetAlgebraType, RawRepresentable &#123;</div><div class="line"></div><div class="line">    /// An `OptionSet`&apos;s `Element` type is normally `Self`.</div><div class="line">    typealias Element = Self</div><div class="line"></div><div class="line">    /// Convert from a value of `RawValue`, succeeding unconditionally.</div><div class="line">    init(rawValue: Self.RawValue)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从字面上来理解，<code>OptionSetType</code>是选项集合类型，它定义了一些基本操作，包括集合操作(<code>union</code>, <code>intersect</code>, <code>exclusiveOr</code>)、成员管理(<code>contains</code>, <code>insert</code>, <code>remove</code>)、位操作(<code>unionInPlace</code>, <code>intersectInPlace</code>, <code>exclusiveOrInPlace</code>)以及其它的一些基本操作。</p>
<p>作为示例，我们来定义一个表示方向的选项集合，通常我们是定义一个实现<code>OptionSetType</code>协议的结构体，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct Directions: OptionSetType &#123;</div><div class="line"></div><div class="line">    var rawValue:Int</div><div class="line">    init(rawValue: Int) &#123;</div><div class="line">        self.rawValue = rawValue</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static let Up: Directions = Directions(rawValue: 1 &lt;&lt; 0)</div><div class="line">    static let Down: Directions = Directions(rawValue: 1 &lt;&lt; 1)</div><div class="line">    static let Left: Directions = Directions(rawValue: 1 &lt;&lt; 2)</div><div class="line">    static let Right: Directions = Directions(rawValue: 1 &lt;&lt; 3)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所需要做的基本上就是这些。然后我们就可以创建<code>Directions</code>的实例了，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let direction: Directions = Directions.Left</div><div class="line">if direction == Directions.Left &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想同时支持两个方向，则可以如上处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let leftUp: Directions = [Directions.Left, Directions.Up]</div><div class="line">if leftUp.contains(Directions.Left) &amp;&amp; leftUp.contains(Directions.Up) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>leftUp</code>同时包含<code>Directions.Left</code>和<code>Directions.Up</code>，则返回<code>true</code>。</p>
<p>这里还有另外一种方法来达到这个目的，就是我们在<code>Directions</code>结构体中直接声明声明<code>Left</code>和<code>Up</code>的静态常量，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct Directions: OptionSetType &#123;</div><div class="line"></div><div class="line">    // ...</div><div class="line">    static let LeftUp: Directions = [Directions.Left, Directions.Up]</div><div class="line">    static let RightUp: Directions = [Directions.Right, Directions.Up]</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们就可以以如下方式来执行上面的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if leftUp == Directions.LeftUp &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，如果单一选项较多，而要去组合所有的情况，这种方法就显示笨拙了，这种情况下还是推荐使用<code>contains</code>方法。</p>
<p>总体来说，<code>Swift</code>中的对选项的支持没有<code>Objective-C</code>中的<code>NS_OPTIONS</code>来得简洁方便。而且在<code>Swift 1.2</code>的时候，我们还是可以使用”&amp;”和”|”操作符的。下面这段代码在<code>Swift 1.2</code>上是<code>OK</code>的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIView.animateWithDuration(0.3, delay: 1.0, options: UIViewAnimationOptions.CurveEaseIn | UIViewAnimationOptions.CurveEaseOut, animations: &#123; () -&gt; Void in</div><div class="line">    // ...</div><div class="line">&#125;, completion: nil)</div></pre></td></tr></table></figure>
<p>但到了<code>Swift 2.0</code>时，<code>OptionSetType</code>已经不再支持”&amp;”和”|”操作了，因此，上面这段代码需要修改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIView.animateWithDuration(0.3, delay: 1.0, options: [UIViewAnimationOptions.CurveEaseIn, UIViewAnimationOptions.CurveEaseInOut], animations: &#123; () -&gt; Void in</div><div class="line">        // ...</div><div class="line">&#125;, completion: nil)</div></pre></td></tr></table></figure>
<p>不过，慢慢习惯就好。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/rawoptionsettype/" target="_blank" rel="external">RawOptionSetType</a></li>
<li><a href="http://www.swift-studies.com/blog/2015/6/17/exploring-swift-20-optionsettypes" target="_blank" rel="external">Exploring Swift 2.0 OptionSetTypes</a></li>
<li><a href="http://www.informit.com/articles/article.aspx?p=2420231" target="_blank" rel="external">Notes from WWDC 2015: The Enumerated Delights of Swift 2.0 Option Sets</a>​</li>
<li>《100个Swift开发必备Tip》— Tip 66. Options</li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="静态分析中”Potential-null-dereference”的处理"><a href="#静态分析中”Potential-null-dereference”的处理" class="headerlink" title="静态分析中”Potential null dereference”的处理"></a>静态分析中”Potential null dereference”的处理</h3><p>我们在写一个方法时，如果希望在方法执行出错时，获取一个<code>NSError</code>对象，我们通常会像下面这样来定义我们的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (NSString )checkStringLength:(NSString *)str error:(NSError **)error &#123;</div><div class="line"></div><div class="line">	if (str.length &lt;= 0) &#123;</div><div class="line">	        *error = [NSError errorWithDomain:@&quot;ErrorDomain&quot; code:-1 userInfo:nil];</div><div class="line">    	return nil;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码看着没啥问题，至少在语法上是OK的，所以在编译时，编译器并不会报任何警告。</p>
<p>如果我们用以下方式去调用的话，也是一切正常的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil;</div><div class="line">[Test checkStringLength:@&quot;&quot; error:&amp;error];</div></pre></td></tr></table></figure>
<p>不过我们如果就静态分析器来分析一下，发现会在”<code>*error = ...</code>“这行代码处报如下的警告：</p>
<blockquote>
<p>Potential null dereference.  According to coding standards in ‘Creating and Returning NSError Objects’ the parameter may be null</p>
</blockquote>
<p>这句话告诉我们的是这里可能存在空引用。实际上，如果我们像下面这样调用方法的话，程序是会崩溃的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[Test checkStringLength:@&quot;&quot; error:NULL];</div></pre></td></tr></table></figure>
<p>因为此时在方法中，<code>error</code>实际上是<code>NULL</code>，<code>*error</code>这货啥也不是，对它赋值肯定就出错了。</p>
<p>这里正确的姿式是在使用<code>error</code>之前，先判断它是否为<code>NULL</code>，完整的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (NSString )checkStringLength:(NSString *)str error:(NSError **)error &#123;</div><div class="line"></div><div class="line">    if (str.length &lt;= 0) &#123;</div><div class="line"></div><div class="line">        if (error != NULL) &#123;</div><div class="line">            *error = [NSError errorWithDomain:@&quot;ErrorDomain&quot; code:-1 userInfo:nil];</div><div class="line">        &#125;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，对此这种方式的传值，我们始终需要去做非空判断。</p>
<h3 id="Charles支持iOS模拟器"><a href="#Charles支持iOS模拟器" class="headerlink" title="Charles支持iOS模拟器"></a>Charles支持iOS模拟器</h3><p>咬咬牙花了50刀买了一个<code>Charles</code>的<code>License</code>。</p>
<p>今天临时需要在模拟器上跑工程，想抓一下数据包，看一下请求<code>Header</code>里面的信息。工程跑起来时，发现<code>Charles</code>没有抓取到数据。嗯，本着有问题先问<code>stackoverflow</code>的原则，跑到上面搜了一下。找到了这个贴子：<a href="http://stackoverflow.com/questions/25439756/how-to-use-charles-proxy-on-the-xcode-6-ios-8-simulator" target="_blank" rel="external">How to use Charles Proxy on the Xcode 6 (iOS 8) Simulator?</a>。不过我的处理没有他这么麻烦，基本上两步搞定了：</p>
<p>1.在<code>Charles</code>的菜单中选择<code>Help &gt; SSL Proxying &gt; Install Charles Root Certificate in iOS Simulators</code>，直接点击就行。这时候会弹出一个提示框，点击OK就行。</p>
<p>2.如果这时候还不能抓取数据，就重启模拟器。</p>
<p>这样就OK了。在<code>Keychain</code>里面，真机和模拟器的证书是同一个。</p>
<p>至于<code>stackoverflow</code>里面提到的在3.9.3版本上还需要覆盖一个脚本文件，这个没有尝试过，哈哈，我的是最新的3.10.2。</p>
<p>还有个需要注意的是，在抓取模拟器数据时，如果关闭<code>Charles</code>，那么模拟器将无法再请求到网络数据。这时需要重新开启<code>Charles</code>，或者是重启模拟器。另外如果重置了模拟器的设置(<code>Reset Content and Settings…</code>)，<code>Charles</code>也抓取不到模拟器的数据，需要重新来过。</p>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://stackoverflow.com/questions/25439756/how-to-use-charles-proxy-on-the-xcode-6-ios-8-simulator" target="_blank" rel="external">How to use Charles Proxy on the Xcode 6 (iOS 8) Simulator?</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/20/cocoa-uikit-uiapearance/" itemprop="url">
                  UIKit: UIApearance
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-20T00:01:05+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/cocoa/" itemprop="url" rel="index">
                    <span itemprop="name">Cocoa</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章开头先援引一下<code>Mattt Thompson</code>大神在<a href="http://nshipster.com/uiappearance/" target="_blank" rel="external">UIApearance</a>里的一句话吧：</p>
<blockquote>
<p>Users will pay a premium for good-looking software.</p>
</blockquote>
<p>就如同大多数人喜欢看帅哥美女一样，一款<code>App</code>能不能被接受，长得怎样很重要。虽然大家都明白“人不可貌相”这个理，但大多数人其实还是视觉动物。用户体验用户体验，如果都让用户看得不爽了，又何谈用户体验呢？所以…所以…哎，我也只能在这默默地码字了。</p>
<p>在<code>iOS 5</code>以前，我们想去自定义系统控件的外观是一件麻烦的事。如果想统一地改变系统控件的外观，我们可能会想各种办法，如去继承现有的控件类，并在子类中修改，或者甚至于动用<code>method swizzling</code>这样高大上的方法。不过，苹果在<code>iOS 5</code>之后为我们提供了一种新的方法：<code>UIAppearance</code>，让这些事简单了不少。在这里，我们就来总结一下吧。</p>
<h2 id="UIApearance是作用"><a href="#UIApearance是作用" class="headerlink" title="UIApearance是作用"></a>UIApearance是作用</h2><p><code>UIApearance</code>实际上是一个协议，我们可以用它来获取一个类的外观代理(<code>appearance proxy</code>)。为什么说是一个类，而不明确说是一个视图或控件呢？这是因为有些非视图对象(如<code>UIBarButtonItem</code>)也可以实现这个协议，来定义其所包含的视图对象的外观。我们可以给这个类的外观代理发送一个修改消息，来自定义一个类的实例的外观。</p>
<p>我们以系统定义的控件<code>UIButton</code>为例，根据我们的使用方式，可以通过<code>UIAppearance</code>修改整个应用程序中所有<code>UIButton</code>的外观，也可以修改某一特定容器类中所有<code>UIButton</code>的外观(如<code>UIBarButtonItem</code>)。不过需要注意的是，这种修改只会影响到那些执行<code>UIAppearance</code>操作之后添加到我们的视图层级架构中的视图或控件，而不会影响到修改之前就已经添加的对象。因此，如果要修改特定的视图，先确保该视图在使用<code>UIAppearance</code>后才通过<code>addSubview</code>添加到视图层级架构中。</p>
<h2 id="UIAppearance的使用"><a href="#UIAppearance的使用" class="headerlink" title="UIAppearance的使用"></a>UIAppearance的使用</h2><p>如上面所说，有两种方式来自定义对象的外观：针对某一类型的所有实例；针对包含在某一容器类的实例中的某一类型的实例。讲得有点绕，我把文档的原文贴出来吧。</p>
<blockquote>
<p>for all instances, and for instances contained within an instance of a container class.</p>
</blockquote>
<p>为此，<code>UIAppearance</code>声明了两个方法。如果我们想自定义一个类所有实例的外观，则可以使用下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// swift</span></div><div class="line"><span class="keyword">static</span> func appearance() -&gt; Self</div><div class="line"></div><div class="line"><span class="comment">//objc</span></div><div class="line">+ (<span class="keyword">instancetype</span>)appearance</div></pre></td></tr></table></figure>
<p>例如，如果我们想修改<code>UINavigationBar</code>的所有实例的背影颜色和标题外观，则可以如下实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UINavigationBar</span>.appearance().barTintColor = <span class="built_in">UIColor</span>(red: <span class="number">104.0</span>/<span class="number">255.0</span>, green: <span class="number">224.0</span>/<span class="number">255.0</span>, blue: <span class="number">231.0</span>/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</div><div class="line">  </div><div class="line"><span class="built_in">UINavigationBar</span>.appearance().titleTextAttributes = [</div><div class="line">    <span class="built_in">NSFontAttributeName</span>: <span class="built_in">UIFont</span>.systemFontOfSize(<span class="number">15.0</span>),</div><div class="line">    <span class="built_in">NSForegroundColorAttributeName</span>: <span class="built_in">UIColor</span>.whiteColor()</div><div class="line">]</div></pre></td></tr></table></figure>
<p>我们也可以指定一类容器，在这个容器中，我们可以自定义一个类的所有实例的外观。我们可以使用下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)appearanceWhenContainedIn:(Class&lt;<span class="built_in">UIAppearanceContainer</span>&gt;)ContainerClass, ...</div></pre></td></tr></table></figure>
<p>如，我们想修改导航栏中所有的按钮的外面，则可以如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIBarButtonItem</span> appearanceWhenContainedIn:[<span class="built_in">UINavigationBar</span> <span class="keyword">class</span>], <span class="literal">nil</span>]</div><div class="line">   setBackgroundImage:myNavBarButtonBackgroundImage forState:state barMetrics:metrics];</div><div class="line"></div><div class="line">[[<span class="built_in">UIBarButtonItem</span> appearanceWhenContainedIn:[<span class="built_in">UINavigationBar</span> <span class="keyword">class</span>], [<span class="built_in">UIPopoverController</span> <span class="keyword">class</span>], <span class="literal">nil</span>]</div><div class="line">    setBackgroundImage:myPopoverNavBarButtonBackgroundImage forState:state barMetrics:metrics];</div><div class="line"></div><div class="line">[[<span class="built_in">UIBarButtonItem</span> appearanceWhenContainedIn:[<span class="built_in">UIToolbar</span> <span class="keyword">class</span>], <span class="literal">nil</span>]</div><div class="line">    setBackgroundImage:myToolbarButtonBackgroundImage forState:state barMetrics:metrics];</div><div class="line"></div><div class="line">[[<span class="built_in">UIBarButtonItem</span> appearanceWhenContainedIn:[<span class="built_in">UIToolbar</span> <span class="keyword">class</span>], [<span class="built_in">UIPopoverController</span> <span class="keyword">class</span>], <span class="literal">nil</span>]</div><div class="line">    setBackgroundImage:myPopoverToolbarButtonBackgroundImage forState:state barMetrics:metrics];</div></pre></td></tr></table></figure>
<p>注意这个方法的参数是一个可变参数，因此，它可以同时设置多个容器。</p>
<p>我们仔细看文档，发现这个方法没有<code>swift</code>版本，至少我在<code>iOS 8.x</code>的<code>SDK</code>中没有找到对应的方法。呵呵，如果想在<code>iOS 8.x</code>以下的系统用<code>swift</code>来调用<code>appearanceWhenContainedIn</code>，那就乖乖地用混编吧。</p>
<p>不过在<code>iOS 9</code>的<code>SDK</code>中(记录一下，今天是<code>2015.07.18</code>)，又把这个方法给加上了，不过这回参数换成了数组，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@available(iOS <span class="number">9.0</span>, *)</div><div class="line"><span class="keyword">static</span> func appearanceWhenContainedInInstancesOfClasses(containerTypes: [AnyObject.Type]) -&gt; Self</div></pre></td></tr></table></figure>
<p>嗯，这里有个问题，我在<code>Xcode 7.0 beta 3</code>版本上测试<code>swift</code>版本的这个方法时，把将其放在启动方法里面，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 此处会崩溃，提示EXC_BAD_ACCESS</span></div><div class="line">	<span class="keyword">let</span> barButtonItemAppearance = <span class="type">UIBarButtonItem</span>.appearanceWhenContainedInInstancesOfClasses([<span class="type">UINavigationBar</span>.<span class="keyword">self</span>])</div><div class="line"></div><div class="line">	<span class="keyword">let</span> attributes = [</div><div class="line">	    <span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFontOfSize(<span class="number">13.0</span>),</div><div class="line">	    <span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.whiteColor()</div><div class="line">	]</div><div class="line"></div><div class="line">	barButtonItemAppearance.setTitleTextAttributes(attributes, forState: .<span class="type">Normal</span>)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序崩溃了，在<code>appearanceWhenContainedInInstancesOfClasses</code>这行提示<code>EXC_BAD_ACCESS</code>。既然是内存问题，那就找找吧。我做了如下几个测试：</p>
<p>1.拆分<code>UIBarButtonItem.appearanceWhenContainedInInstancesOfClasses</code>，在其前面加了如下几行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> appearance = <span class="type">UIBarButtonItem</span>.appearance()</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr: [<span class="type">AnyObject</span>.<span class="type">Type</span>] = [<span class="type">UINavigationBar</span>.<span class="keyword">self</span>, <span class="type">UIToolbar</span>.<span class="keyword">self</span>]</div><div class="line"></div><div class="line"><span class="built_in">print</span>(arr)</div></pre></td></tr></table></figure>
<p>可以看到除了<code>appearanceWhenContainedInInstancesOfClasses</code>自身外，其它几个元素都是没问题的。</p>
<p>2.将这段拷贝到默认的<code>ViewController</code>中，运行。同样崩溃了。</p>
<p>3.在相同环境下(<code>Xcode 7.0 beta 3 + iOS 9.0</code>)，用<code>Objective-C</code>对应的方法试了一下，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    </div><div class="line">    [<span class="built_in">UIBarButtonItem</span> appearanceWhenContainedInInstancesOfClasses:@[[<span class="built_in">UINavigationBar</span> <span class="keyword">class</span>]]];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序很愉快地跑起来了。</p>
<p>额，我能把这个归结为版本不稳定的缘故么？等到稳定版出来后再研究一下吧。</p>
<h2 id="支持UIAppearance的组件"><a href="#支持UIAppearance的组件" class="headerlink" title="支持UIAppearance的组件"></a>支持UIAppearance的组件</h2><p>从<code>iOS 5.0</code>后，有很多<code>iOS</code>的<code>API</code>都已经支持<code>UIAppearance</code>的代理方法了，<code>Mattt Thompson</code>在<a href="http://nshipster.com/uiappearance/" target="_blank" rel="external">UIApearance</a>中，给我们提供了以下两行脚本代码，可以获取所有支持<code>UI_APPEARANCE_SELECTOR</code>的方法(我们将在下面介绍<code>UI_APPEARANCE_SELECTOR</code>)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS*.sdk/System/Library/Frameworks/<span class="built_in">UIKit</span>.framework/Headers</div><div class="line"></div><div class="line">$ grep -H <span class="built_in">UI_APPEARANCE_SELECTOR</span> .<span class="comment">/* | sed 's/ __OSX_AVAILABLE_STARTING(__MAC_NA,__IPHONE_5_0) UI_APPEARANCE_SELECTOR;//'</span></div></pre></td></tr></table></figure>
<p>大家可以试一下，我这里列出部分输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">./<span class="built_in">UIActivityIndicatorView</span>.h:<span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">UIColor</span> *color <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line">./<span class="built_in">UIAppearance</span>.h:<span class="comment">/* To participate in the appearance proxy API, tag your appearance property selectors in your header with UI_APPEARANCE_SELECTOR.</span></div><div class="line">./UIAppearance.h:#define UI_APPEARANCE_SELECTOR __attribute__((annotate("ui_appearance_selector")))</div><div class="line">./UIBarButtonItem.h:- (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;</div><div class="line">./UIBarButtonItem.h:- (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;</div><div class="line">./UIBarButtonItem.h:- (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state style:(UIBarButtonItemStyle)style barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</div><div class="line">./UIBarButtonItem.h:- (UIImage *)backgroundImageForState:(UIControlState)state style:(UIBarButtonItemStyle)style barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</div><div class="line">./UIBarButtonItem.h:- (void)setBackgroundVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR; </div><div class="line">......</div></pre></td></tr></table></figure>
<p>大家还可以在<a href="https://gist.github.com/mattt/5135521" target="_blank" rel="external">这里</a>查看<code>iOS 7.0</code>下的清单。</p>
<h2 id="自定义类实现UIAppearance"><a href="#自定义类实现UIAppearance" class="headerlink" title="自定义类实现UIAppearance"></a>自定义类实现UIAppearance</h2><p>我们可以自定义一个类，并让这个类支持<code>UIAppearance</code>。为此，我们需要做两件事：</p>
<ol>
<li>让我们的类实现<code>UIAppearanceContainer</code>协议</li>
<li>如果是在<code>Objective-C</code>中，则将相关的方法用<code>UI_APPEARANCE_SELECTOR</code>来标记。而在<code>Swift</code>中，需要在对应的属性或方法前面加上<code>dynamic</code>。</li>
</ol>
<p>当然，要让我们的类可以使用<code>appearance</code>(或<code>appearanceWhenContainedInInstancesOfClasses</code>)来获取自己的类，则还需要实现<code>UIAppearance</code>协议。</p>
<p>在这里，我们来定义一个带边框的<code>Label</code>，通过<code>UIAppearance</code>来设置它的默认边框。实际上，<code>UIView</code>已经实现了<code>UIAppearance</code>和<code>UIAppearanceContainer</code>协议。因此，我们在其子类中不再需要显式地去声明实现这两个接口。</p>
<p>我们的Label的声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RoundLabel.h</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RoundLabel</span> : <span class="title">UILabel</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> borderWidth <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cornerRadius <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UIColor</span> *borderColor <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>具体的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RoundLabel</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> drawRect:rect];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.layer.borderColor = _borderColor.CGColor;</div><div class="line">    <span class="keyword">self</span>.layer.cornerRadius = _cornerRadius;</div><div class="line">    <span class="keyword">self</span>.layer.borderWidth = _borderWidth;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setBorderWidth:(<span class="built_in">CGFloat</span>)borderWidth &#123;</div><div class="line">    </div><div class="line">    _borderWidth = borderWidth;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setCornerRadius:(<span class="built_in">CGFloat</span>)cornerRadius &#123;</div><div class="line">    </div><div class="line">    _cornerRadius = cornerRadius;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setRectColor:(<span class="built_in">UIColor</span> *)rectColor &#123;</div><div class="line">    </div><div class="line">    _borderColor = rectColor;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们在<code>drawRect:</code>设置<code>Label</code>的边框，这样<code>RoundLabel</code>的所有实例就可以使用默认的边框配置属性了。</p>
<p>然后，我们可以在<code>AppDelegate</code>或者其它某个位置来设置<code>RoundLabel</code>的默认配置，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">104.0</span>/<span class="number">255.0</span> green:<span class="number">224.0</span>/<span class="number">255.0</span> blue:<span class="number">231.0</span>/<span class="number">255.0</span> alpha:<span class="number">1.0</span>f];</div><div class="line"></div><div class="line">[RoundLabel appearance].cornerRadius = <span class="number">5.0</span>f;</div><div class="line">[RoundLabel appearance].borderColor = color;</div><div class="line">[RoundLabel appearance].borderWidth = <span class="number">1.0</span>f;</div></pre></td></tr></table></figure>
<p>当然，我们在使用<code>RoundLabel</code>时，可以根据实际需要再修改这几个属性的值。</p>
<p><code>Swift</code>的实现就简单多了，我们只需要如下处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundLabel</span>: <span class="title">UILabel</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">setBorderColor</span><span class="params">(color: UIColor)</span></span> &#123;</div><div class="line">        layer.borderColor = color.<span class="type">CGColor</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">setBorderWidth</span><span class="params">(width: CGFloat)</span></span> &#123;</div><div class="line">        layer.borderWidth = width</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">setCornerRadius</span><span class="params">(radius: CGFloat)</span></span> &#123;</div><div class="line">        layer.cornerRadius = radius</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>UIAppearanceContainer</code>的官方文档中，有对支持<code>UIAppearance</code>的方法作格式限制，具体要求如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">propertyForAxis1</span><span class="params">(axis1: IntegerType, axis2: IntegerType, axisN: IntegerType)</span></span> -&gt; <span class="type">PropertyType</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setProperty</span><span class="params">(property: PropertyType, forAxis1 axis1: IntegerType, axis2: IntegerType)</span></span></div><div class="line"></div><div class="line"><span class="comment">//objc</span></div><div class="line">- (<span class="type">PropertyType</span>)propertyForAxis1:(<span class="type">IntegerType</span>)axis1 axis2:(<span class="type">IntegerType</span>)axis2 … axisN:(<span class="type">IntegerType</span>)axisN;</div><div class="line">- (void)setProperty:(<span class="type">PropertyType</span>)property forAxis1:(<span class="type">IntegerType</span>)axis1 axis2:(<span class="type">IntegerType</span>)axis2 … axisN:(<span class="type">IntegerType</span>)axisN;</div></pre></td></tr></table></figure>
<p>其中的属性类型可以是<code>iOS</code>的任意类型，包括<code>id</code>, <code>NSInteger</code>, <code>NSUInteger</code>, <code>CGFloat</code>, <code>CGPoint</code>, <code>CGSize</code>, <code>CGRect</code>, <code>UIEdgeInsets</code>或<code>UIOffset</code>。而<code>IntegerType</code>必须是<code>NSInteger</code>或者<code>NSUInteger</code>。如果类型不对，则会抛出异常。</p>
<p>我们可以以<code>UIBarButtonItem</code>为例，它定义了以下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setTitlePositionAdjustment:forBarMetrics:</div><div class="line"></div><div class="line">backButtonBackgroundImageForState:barMetrics:</div><div class="line"></div><div class="line">setBackButtonBackgroundImage:forState:barMetrics:</div></pre></td></tr></table></figure>
<p>这些方法就是满足上面所提到的格式。</p>
<h2 id="Trait-Collection"><a href="#Trait-Collection" class="headerlink" title="Trait Collection"></a>Trait Collection</h2><p>我们查看<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIAppearance_Protocol/" target="_blank" rel="external">UIAppearance</a>的官方文档，可以看到在<code>iOS 8</code>后，这个协议又新增了两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift</span></div><div class="line"><span class="keyword">static</span> func appearanceForTraitCollection(_ trait: <span class="built_in">UITraitCollection</span>) -&gt; Self</div><div class="line"></div><div class="line"><span class="comment">//objc</span></div><div class="line">+ (<span class="keyword">instancetype</span>)appearanceForTraitCollection:(<span class="built_in">UITraitCollection</span> *)trait</div><div class="line">  </div><div class="line">+ (<span class="keyword">instancetype</span>)appearanceForTraitCollection:(<span class="built_in">UITraitCollection</span> *)trait</div><div class="line">                         whenContainedIn:(Class&lt;<span class="built_in">UIAppearanceContainer</span>&gt;)ContainerClass, ...</div></pre></td></tr></table></figure>
<p>这两个方法涉及到<code>Trait Collection</code>，具体的内容我们在此不过多的分析。</p>
<h2 id="一些深入的东西"><a href="#一些深入的东西" class="headerlink" title="一些深入的东西"></a>一些深入的东西</h2><p>了解了怎么去使用<code>UIApearance</code>，现在我们再来了解一下它是怎么运作的。我们跟着<a href="http://petersteinberger.com/blog/2013/uiappearance-for-custom-views/" target="_blank" rel="external">UIAppearance for Custom Views</a>一文的思路来走。</p>
<p>我们在以下实现中打一个断点：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setBorderWidth:(<span class="built_in">CGFloat</span>)borderWidth &#123;</div><div class="line">    </div><div class="line">    _borderWidth = borderWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后运行程序。程序启动时，我们发现虽然在<code>AppDelegate</code>中调用了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[RoundLabel appearance].borderWidth = <span class="number">1.0</span>f;</div></pre></td></tr></table></figure>
<p>但实际上，此时程序没有到在此断住。我们再进到<code>Label</code>所在的视图控制器，这时程序在断点处停住了。在这里，我们可以看看方法的调用栈。</p>
<p><img src="https://raw.githubusercontent.com/southpeak/Blog-images/master/UIAppearance-Example-01.png" alt="image"></p>
<p>在调用栈里面，我们可以看到<code>_UIAppearance</code>这个东东，我们从<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/_UIAppearance.h" target="_blank" rel="external">iOS-Runtime-Headers</a>可以找到这个类的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_UIAppearance</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> *_appearanceInvocations;</div><div class="line">    <span class="built_in">NSArray</span> *_containerList;</div><div class="line">    _UIAppearanceCustomizableClassInfo *_customizableClassInfo;</div><div class="line">    <span class="built_in">NSMapTable</span> *_invocationSources;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *_resettableInvocations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/_UIAppearanceCustomizableClassInfo.h" target="_blank" rel="external">_UIAppearanceCustomizableClassInfo</a>存储的是外观对应的类的信息。我们可以看看这个类的声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_UIAppearanceCustomizableClassInfo</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="built_in">NSString</span> *_appearanceNodeKey;</div><div class="line">    Class _customizableViewClass;</div><div class="line">    Class _guideClass;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _hash;</div><div class="line">    <span class="built_in">BOOL</span> _isCustomizableViewClassRoot;</div><div class="line">    <span class="built_in">BOOL</span> _isGuideClassRoot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *_appearanceNodeKey;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) Class _customizableViewClass;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) Class _guideClass;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">unsigned</span> <span class="keyword">int</span> _hash;</div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>)_customizableClassInfoForViewClass:(Class)arg1 withGuideClass:(Class)arg2;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)_appearanceNodeKey;</div><div class="line">- (Class)_customizableViewClass;</div><div class="line">- (Class)_guideClass;</div><div class="line">- (<span class="keyword">unsigned</span> <span class="keyword">int</span>)_hash;</div><div class="line">- (<span class="keyword">id</span>)_superClassInfo;</div><div class="line">- (<span class="keyword">void</span>)dealloc;</div><div class="line">- (<span class="keyword">id</span>)description;</div><div class="line">- (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hash;</div><div class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)arg1;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在<code>_UIAppearance</code>中，还有一个<code>_appearanceInvocations</code>变量，我们可以在<code>Debug</code>中尝试用以下命令来打印出它的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">po [[<span class="built_in">NSClassFromString</span>(<span class="string">@"_UIAppearance"</span>) _appearanceForClass:[RoundLabel <span class="keyword">class</span>] withContainerList:<span class="literal">nil</span>] valueForKey:<span class="string">@"_appearanceInvocations"</span>]</div></pre></td></tr></table></figure>
<p>我们可以得到以下的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;__NSArrayM <span class="number">0x7fd44a5c1f80</span>&gt;(</div><div class="line">&lt;<span class="built_in">NSInvocation</span>: <span class="number">0x7fd44a5c1d20</span>&gt;</div><div class="line"><span class="keyword">return</span> value: &#123;v&#125; <span class="keyword">void</span></div><div class="line">target: &#123;@&#125; <span class="number">0x10b545ae0</span></div><div class="line">selector: &#123;:&#125; setCornerRadius:</div><div class="line">argument <span class="number">2</span>: &#123;d&#125; <span class="number">0.000000</span></div><div class="line">,</div><div class="line">&lt;<span class="built_in">NSInvocation</span>: <span class="number">0x7fd44a5bf300</span>&gt;</div><div class="line"><span class="keyword">return</span> value: &#123;v&#125; <span class="keyword">void</span></div><div class="line">target: &#123;@&#125; <span class="number">0x10b545ae0</span></div><div class="line">selector: &#123;:&#125; setBorderColor:</div><div class="line">argument <span class="number">2</span>: &#123;@&#125; <span class="number">0x7fd44a5bbb80</span></div><div class="line">,</div><div class="line">&lt;<span class="built_in">NSInvocation</span>: <span class="number">0x7fd44a50b8c0</span>&gt;</div><div class="line"><span class="keyword">return</span> value: &#123;v&#125; <span class="keyword">void</span></div><div class="line">target: &#123;@&#125; <span class="number">0x10b545ae0</span></div><div class="line">selector: &#123;:&#125; setBorderWidth:</div><div class="line">argument <span class="number">2</span>: &#123;d&#125; <span class="number">0.000000</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>可以看到这个数组中存储的实际上是<code>NSInvocation</code>对象，每个对象就是我们在程序中设置的<code>RoundLabel</code>外观的方法信息。</p>
<p>在<code>Peter Steinberger</code>的文章中，有提到当我们设置了一个自定义的外观时，<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/_UIAppearanceRecorder.h" target="_blank" rel="external">_UIAppearanceRecorder</a>会去保存并跟踪这个设置。我们可以看看<code>_UIAppearanceRecorder</code>的声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_UIAppearanceRecorder</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="built_in">NSString</span> *_classNameToRecord;</div><div class="line">    <span class="built_in">NSArray</span> *_containerClassNames;</div><div class="line">    <span class="built_in">NSMutableArray</span> *_customizations;</div><div class="line">    Class _superclassToRecord;</div><div class="line">    <span class="built_in">NSArray</span> *_unarchivedCustomizations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过有点可惜的是，我没有从这里找到太多的信息。我用<code>runtime</code>检查了一下这个类中的数据，貌似没有太多东西。可能是姿势不对，我把代码和结果贴出来，大家帮我看看。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">Class recorderClass = <span class="built_in">NSClassFromString</span>(<span class="string">@"_UIAppearanceRecorder"</span>);</div><div class="line"></div><div class="line"><span class="keyword">id</span> recorder = [recorderClass performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"_sharedAppearanceRecorderForClass::whenContainedIn:"</span>) withObject:[RoundLabel <span class="keyword">class</span>] withObject:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"_UIAppearanceRecorder instance : %@"</span>, recorder);</div><div class="line"></div><div class="line">Ivar *variables = class_copyIvarList(recorderClass, &amp;outCount);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">    Ivar variable = variables[i];</div><div class="line"></div><div class="line">    <span class="keyword">id</span> value = object_getIvar(recorder, variable);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"variable's name: %s, value: %@"</span>, ivar_getName(variable), value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">free(variables);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">UIAppearanceExample2[7600:381708] _UIAppearanceRecorder instance : &lt;_UIAppearanceRecorder: 0x7fa29a718960&gt;</div><div class="line">UIAppearanceExample2[7600:381708] variable's name: _classNameToRecord, value: RoundLabel</div><div class="line">UIAppearanceExample2[7600:381708] variable's name: _superclassToRecord, value: (null)</div><div class="line">UIAppearanceExample2[7600:381708] variable's name: _containerClassNames, value: (null)</div><div class="line">UIAppearanceExample2[7600:381708] variable's name: _customizations, value: (</div><div class="line">)</div><div class="line">UIAppearanceExample2[7600:381708] variable's name: _unarchivedCustomizations, value: (null)</div></pre></td></tr></table></figure>
<p>我们回过头再来看看<code>_UIAppearance的_appearanceInvocations</code>，我们是否可以这样猜测：<code>UIAppearance</code>是否是通过类似于<code>Swizzling Method</code>这种方式，在运行时去更新视图的默认显示呢？求解。</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>这一小篇遗留下了两个问题：</p>
<ol>
<li>在<code>swift</code>中如何正确地使用<code>appearanceWhenContainedInInstancesOfClasses</code>方法？我在<code>stackoverflow</code>中没有找到答案。</li>
<li><code>iOS</code>内部是如何用<code>UIAppearance</code>设置的信息来在运行时替换默认的设置的？</li>
</ol>
<p>如果有答案，还请告知。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用<code>UIAppearance</code>，可以让我们方便地去修改一些视图或控件的默认显示。同样，如果我们打算开发一个视图库，也可能会用到相关的内容。我们可以在库的内部自定义一些<code>UIAppearance</code>的规则来代替手动去修改视图外观。这样，库外部就可以方便的通过<code>UIAppearance</code>来整体修改一个类中视图的外观了。</p>
<p>我在<code>github</code>中搜索<code>UIAppearance</code>相关的实例时，找到了<a href="https://github.com/robertwijas/UISS" target="_blank" rel="external">UISS</a>这个开源库，它提供了一种便捷的方式来定义程序的样式。这个库也是基于<code>UIAppearance</code>的。看其介绍，如果我们想自定义一个<code>UIButton</code>的外观，可以使用以下方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"UIButton"</span>:&#123;</div><div class="line">        <span class="string">"titleColor:normal"</span>:[<span class="string">"white"</span>, <span class="number">0.8</span>],</div><div class="line">        <span class="string">"titleColor:highlighted"</span>:<span class="string">"white"</span>,</div><div class="line">        <span class="string">"backgroundImage:normal"</span>: [<span class="string">"button-background-normal"</span>, [<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">10</span>]],</div><div class="line">        <span class="string">"backgroundImage:highlighted"</span>: [<span class="string">"button-background-highlighted"</span>, [<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">10</span>]],</div><div class="line">        <span class="string">"titleEdgeInsets"</span>: [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</div><div class="line">        <span class="string">"UILabel"</span>:&#123;</div><div class="line">            <span class="string">"font"</span>:[<span class="string">"Copperplate-Bold"</span>, <span class="number">18</span>]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看着像<code>JSON</code>吧？</p>
<p>具体的我也还没有看，回头抽空再研究研究这个库。</p>
<p><em>补充：文章中的示例代码已放到<code>github</code>中，可以在<a href="https://github.com/southpeak/iOS-Dev-Examples/tree/master/UIKit/UIApearance" target="_blank" rel="external">这里</a>查看(不保证在<code>iOS 9.0</code>以下能正常进行，嘿嘿)</em></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/uiappearance/" target="_blank" rel="external">UIApearance</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIAppearance_Protocol/" target="_blank" rel="external">UIAppearance Protocol Reference</a></li>
<li><a href="https://developer.apple.com/library//ios/recipes/UIAppearanceContainer_Protocol/index.html" target="_blank" rel="external">UIAppearanceContainer Protocol Reference</a></li>
<li><a href="http://petersteinberger.com/blog/2013/uiappearance-for-custom-views/" target="_blank" rel="external">UIAppearance for Custom Views</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/30/ios-techset-3/" itemprop="url">
                  iOS知识小集 第3期(2015.06.30)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-30T00:15:14+08:00" content="2015-06-30">
              2015-06-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Swift2</code>出来了，还是得与时俱进啊，不然就成老古董了。再者它开源了，又有事情要做了。当个程序猿真是累啊，一直在追，可从来没追上，刚有那么点念想了，人家又踩了脚油门。</p>
<p>一个月又要过去了，说好的一月两到三篇的，看来希望也是有点渺茫了。本来想好好整理下僵尸对象的内容，看看时间也不多了，也只好放到后面了。这一期没啥好内容，质量也不高，大家凑合着看吧，有疏漏还请大家指出，我一定好好改正。</p>
<p>这一期主要有三个内容：</p>
<ol>
<li>Tint Color</li>
<li>Build Configurations in Swift</li>
<li>键盘事件</li>
</ol>
<h2 id="Tint-Color"><a href="#Tint-Color" class="headerlink" title="Tint Color"></a>Tint Color</h2><p>在<code>iOS 7</code>后，<code>UIView</code>新增加了一个<code>tintColor</code>属性，这个属性定义了一个非默认的着色颜色值，其值的设置会影响到以视图为根视图的整个视图层次结构。它主要是应用到诸如app图标、导航栏、按钮等一些控件上，以获取一些有意思的视觉效果。</p>
<p><code>tintColor</code>属性的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var tintColor: UIColor!</div></pre></td></tr></table></figure>
<p>默认情况下，一个视图的<code>tintColor</code>是为<code>nil</code>的，这意味着视图将使用父视图的<code>tint color</code>值。当我们指定了一个视图的<code>tintColor</code>后，这个色值会自动传播到视图层次结构(以当前视图为根视图)中所有的子视图上。如果系统在视图层次结构中没有找到一个非默认的<code>tintColor</code>值，则会使用系统定义的颜色值(蓝色，<code>RGB</code>值为<code>[0,0.478431,1]</code>，我们可以在IB中看到这个颜色)。因此，这个值总是会返回一个颜色值，即我们没有指定它。</p>
<p>与<code>tintColor</code>属性相关的还有个<code>tintAdjustmentMode</code>属性，它是一个枚举值，定义了<code>tint color</code>的调整模式。其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var tintAdjustmentMode: UIViewTintAdjustmentMode</div></pre></td></tr></table></figure>
<p>枚举UIViewTintAdjustmentMode的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum UIViewTintAdjustmentMode : Int &#123;</div><div class="line">    case Automatic			// 视图的着色调整模式与父视图一致</div><div class="line">    case Normal				// 视图的tintColor属性返回完全未修改的视图着色颜色</div><div class="line">    case Dimmed				// 视图的tintColor属性返回一个去饱和度的、变暗的视图着色颜色</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，当<code>tintAdjustmentMode</code>属性设置为<code>Dimmed</code>时，<code>tintColor</code>的颜色值会自动变暗。而如果我们在视图层次结构中没有找到默认值，则该值默认是<code>Normal</code>。</p>
<p>与<code>tintColor</code>相关的还有一个<code>tintColorDidChange</code>方法，其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func tintColorDidChange()</div></pre></td></tr></table></figure>
<p>这个方法会在视图的<code>tintColor</code>或<code>tintAdjustmentMode</code>属性改变时自动调用。另外，如果当前视图的父视图的<code>tintColor</code>或<code>tintAdjustmentMode</code>属性改变时，也会调用这个方法。我们可以在这个方法中根据需要去刷新我们的视图。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>接下来我们通过示例来看看<code>tintColor</code>的强大功能(示例盗用了<code>Sam Davies</code>写的一个例子，具体可以查看<a href="https://www.shinobicontrols.com/blog/posts/2013/09/27/ios7-day-by-day-day-6-tint-color" target="_blank" rel="external">iOS7 Day-by-Day :: Day 6 :: Tint Color</a>，我就负责搬砖，用swift实现了一下，代码可以在<a href="https://github.com/southpeak/iOS-Dev-Examples/tree/master/UIKit/UIView/1.%20TintColorExample" target="_blank" rel="external">这里</a>下载)。</p>
<p>先来看看最终效果吧(以下都是盗图，请见谅，太懒了)：</p>
<p><img src="https://www.shinobicontrols.com/media/371241/tint_color_image_1_350x621.jpg" alt="image"></p>
<p>这个界面包含的元素主要有<code>UIButton</code>, <code>UISlider</code>, <code>UIProgressView</code>, <code>UIStepper</code>, <code>UIImageView</code>, <code>ToolBar</code>和一个自定义的子视图<code>CustomView</code>。接下来我们便来看看修改视图的<code>tintColor</code>会对这些控件产生什么样的影响。</p>
<p>在<code>ViewController</code>的<code>viewDidLoad</code>方法中，我们做了如下设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">override func viewDidLoad() &#123;</div><div class="line">	super.viewDidLoad()</div><div class="line"></div><div class="line">    println(&quot;\(self.view.tintAdjustmentMode.rawValue)&quot;)         // 输出：1</div><div class="line">    println(&quot;\(self.view.tintColor)&quot;)                           // 输出：UIDeviceRGBColorSpace 0 0.478431 1 1</div><div class="line"></div><div class="line">    self.view.tintAdjustmentMode = .Normal</div><div class="line">    self.dimTintSwitch?.on = false</div><div class="line"></div><div class="line">    // 加载图片</div><div class="line">    var shinobiHead = UIImage(named: &quot;shinobihead&quot;)</div><div class="line">    // 设置渲染模式</div><div class="line">    shinobiHead = shinobiHead?.imageWithRenderingMode(.AlwaysTemplate)</div><div class="line"></div><div class="line">    self.tintedImageView?.image = shinobiHead</div><div class="line">    self.tintedImageView?.contentMode = .ScaleAspectFit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，我们尝试打印默认的<code>tintColor</code>和<code>tintAdjustmentMode</code>，分别输出了<code>[UIDeviceRGBColorSpace 0 0.478431 1 1]</code>和<code>1</code>，这是在我们没有对整个视图层次结构设置任何<code>tint color</code>相关的值的情况下的输出。可以看到，虽然我们没有设置<code>tintColor</code>，但它仍然返回了系统的默认值；而<code>tintAdjustmentMode</code>则默认返回<code>Normal</code>的原始值。</p>
<p>接下来，我们显式设置<code>tintAdjustmentMode</code>的值为<code>Normal</code>，同时设置<code>UIImageView</code>的图片及渲染模式。</p>
<p>当我们点击”<code>Change Color</code>“按钮时，会执行以下的事件处理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@IBAction func changeColorHandler(sender: AnyObject) &#123;</div><div class="line">	let hue = CGFloat(arc4random() % 256) / 256.0</div><div class="line">    let saturation = CGFloat(arc4random() % 128) / 256.0 + 0.5</div><div class="line">    let brightness = CGFloat(arc4random() % 128) / 256.0 + 0.5</div><div class="line"></div><div class="line">    let color = UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: 1.0)</div><div class="line">    self.view.tintColor = color</div><div class="line">    updateViewConstraints()</div><div class="line">&#125;</div><div class="line"></div><div class="line">private func updateProgressViewTint() &#123;</div><div class="line">    self.progressView?.progressTintColor = self.view.tintColor</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码主要是随机生成一个颜色值，并赋值给<code>self.view</code>的<code>tintColor</code>属性，同时去更新进度条的tintColor值。</p>
<p><em>注：有些控件的特定组成部件的tint color由特定的属性控制，例如进度就有2个tint color：一个用于进度条本身，另一个用于背景。</em></p>
<p>点击”<code>Change Color</code>“按钮，可得到以下效果：</p>
<p><img src="https://www.shinobicontrols.com/media/371246/tint_color_image_2_350x621.jpg" alt="image"></p>
<p>可以看到，我们在示例中并有没手动去设置<code>UIButton</code>, <code>UISlider</code>, <code>UIStepper</code>, <code>UIImageView</code>, <code>ToolBar</code>等子视图的颜色值，但随着<code>self.view</code>的<code>tintColor</code>属性颜色值的变化，这些控件的外观也同时跟着改变。也就是说<code>self.view</code>的<code>tintColor</code>属性颜色值的变化，影响到了以<code>self.view</code>为根视图的整个视图层次结果中所有子视图的外观。</p>
<p>看来<code>tintColor</code>还是很强大的嘛。</p>
<p>在界面中还有个<code>UISwitch</code>，这个是用来开启关闭<code>dim tint</code>的功能，其对应处理方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@IBAction func dimTimtHandler(sender: AnyObject) &#123;</div><div class="line">	if let isOn = self.dimTintSwitch?.on &#123;</div><div class="line"></div><div class="line">        self.view.tintAdjustmentMode = isOn ? .Dimmed : .Normal</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    updateViewConstraints()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>tintAdjustmentMode</code>设置<code>Dimmed</code>时，其实际的效果是整个色值都变暗(此处无图可盗)。</p>
<p>另外，我们在子视图<code>CustomView</code>中重写了<code>tintColorDidChange</code>方法，以监听<code>tintColor</code>的变化，以更新我们的自定义视图，其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">override func tintColorDidChange() &#123;</div><div class="line">	tintColorLabel.textColor = self.tintColor</div><div class="line">    tintColorBlock.backgroundColor = self.tintColor</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以方框和”<code>Tint color label</code>“颜色是跟着子视图的<code>tintColor</code>来变化的，而子视图的<code>tintColor</code>又是继承自父视图的。</p>
<p>在这个示例中，比较有意思的是还是对图片的处理。对图像的处理比较简单粗暴，对一个像素而言，如果它的<code>alpha</code>值为<code>1</code>的话，就将它的颜色设置为<code>tint color</code>；如果不为<code>1</code>的话，则设置为透明的。示例中的忍者头像就是这么处理的。不过我们需要设置图片的<code>imageWithRenderingMode</code>属性为<code>AlwaysTemplate</code>，这样渲染图片时会将其渲染为一个模板而忽略它的颜色信息，如代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var shinobiHead = UIImage(named: &quot;shinobihead&quot;)</div><div class="line">// 设置渲染模式</div><div class="line">shinobiHead = shinobiHead?.imageWithRenderingMode(.AlwaysTemplate)</div></pre></td></tr></table></figure>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>插个题外话，跟主题关系不大。</p>
<p>在色彩理论(<code>color theory</code>)中，一个<code>tint color</code>是一种颜色与白色的混合。与之类似的是<code>shade color</code>和<code>tone color</code>。<code>shade color</code>是将颜色与黑色混合，<code>tone color</code>是将颜色与灰色混合。它们都是基于<code>Hues</code>色调的。这几个色值的效果如下图所示：</p>
<p><img src="http://www.craftsy.com/blog/wp-content/uploads/2013/04/Screen-Shot-2013-04-30-at-12.46.43-PM.png" alt="image"></p>
<p>一些基础的理论知识可以参考<a href="http://www.craftsy.com/blog/2013/05/hues-tints-tones-and-shades/" target="_blank" rel="external">Hues, Tints, Tones and Shades: What’s the Difference?</a>或更专业的一些文章。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果我们想指定整个<code>App</code>的<code>tint color</code>，则可以通过设置<code>window</code>的<code>tint color</code>。这样同一个<code>window</code>下的所有子视图都会继承此<code>tint color</code>。</p>
<p>当弹出一个<code>alert</code>或者<code>action sheet</code>时，<code>iOS7</code>会自动将后面视图的<code>tint color</code>变暗。此时，我们可以在自定义视图中重写<code>tintColorDidChange</code>方法来执行我们想要的操作。</p>
<p>有些复杂控件，可以有多个<code>tint color</code>，不同的<code>tint color</code>控件不同的部分。如上面提到的<code>UIProgressView</code>，又如<code>navigation bars</code>, <code>tab bars</code>, <code>toolbars</code>, <code>search bars</code>, <code>scope bars</code>等，这些控件的背景着色颜色可以使用<code>barTintColor</code>属性来处理。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instp/UIView/tintColor" target="_blank" rel="external">UIView Class Reference</a></li>
<li><a href="https://www.shinobicontrols.com/blog/posts/2013/09/27/ios7-day-by-day-day-6-tint-color" target="_blank" rel="external">iOS7 Day-by-Day :: Day 6 :: Tint Color</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/TransitionGuide/AppearanceCustomization.html" target="_blank" rel="external">Appearance and Behavior</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tints_and_shades" target="_blank" rel="external">Tints and shades</a></li>
<li><a href="http://www.craftsy.com/blog/2013/05/hues-tints-tones-and-shades/" target="_blank" rel="external">Hues, Tints, Tones and Shades: What’s the Difference?</a></li>
</ol>
<h2 id="Build-Configurations-in-Swift"><a href="#Build-Configurations-in-Swift" class="headerlink" title="Build Configurations in Swift"></a>Build Configurations in Swift</h2><p>在<code>Objective-C</code>中，我们经常使用预处理指令来帮助我们根据不同的平台执行不同的代码，以让我们的代码支持不同的平台，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if TARGET_OS_IPHONE</div><div class="line">    #define MAS_VIEW UIView	    	    </div><div class="line">#elif TARGET_OS_MAC</div><div class="line">    #define MAS_VIEW NSView</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>在<code>swift</code>中，由于对<code>C</code>语言支持没有<code>Objective-C</code>来得那么友好(暂时不知<code>swift 2</code>到<code>C</code>的支持如何)，所以我们无法像在<code>Objective-C</code>中那样自如而舒坦地使用预处理指令。</p>
<p>不过，<code>swift</code>也提供了自己的方式来支持条件编译，即使用<code>build configurations</code>(构建配置)。<code>Build configurations</code>已经包含了字面量<code>true</code>和<code>false</code>，以及两个平台测试函数<code>os()</code>和<code>arch()</code>。</p>
<p>其中<code>os()</code>用于测试系统类型，可传入的参数包含<code>OSX</code>, <code>iOS</code>, <code>watchOS</code>，所以上面的代码在<code>swift</code>可改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if os(iOS)</div><div class="line">    typealias MAS_VIEW = UIView</div><div class="line">#elseif os(OSX)</div><div class="line">    typealias MAS_VIEW = NSView</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p><em>注：在WWDC 2014的<a href="https://developer.apple.com/videos/wwdc/2014/" target="_blank" rel="external">“Sharing code between iOS and OS X”</a>一节(session 233)中，Elizabeth Reid将这种方式称为Shimming</em></p>
<p>遗憾的是，<code>os()</code>只能检测系统类型，而无法检测系统的版本，所以这些工作只能放在运行时去处理。关于如何检测系统的版本,<code>Mattt Thompson</code>老大在它的<a href="http://nshipster.com/swift-system-version-checking/" target="_blank" rel="external">Swift System Version Checking</a>一文中给了我们答案。</p>
<p>我们再来看看<code>arch()</code>。<code>arch()</code>用于测试<code>CPU</code>的架构，可传入的值包括<code>x86_64</code>, <code>arm</code>, <code>arm64</code>, <code>i386</code>。需要注意的是<code>arch(arm)</code>对于<code>ARM 64</code>的设备来说，不会返回<code>true</code>。而<code>arch(i386)</code>在<code>32</code>位的<code>iOS</code>模拟器上编译时会返回<code>true</code>。</p>
<p>如果我们想自定义一些在调试期间使用的编译配置选项，则可以使用-D标识来告诉编译器，具体操作是在<code>&quot;Build Setting&quot;</code>-&gt;<code>&quot;Swift Compiler-Custom Flags&quot;</code>-&gt;<code>&quot;Other Swift Flags&quot;</code>-&gt;<code>&quot;Debug&quot;</code>中添加所需要的配置选项。如我们想添加常用的<code>DEGUB</code>选项，则可以在此加上<code>&quot;-D DEBUG&quot;</code>。这样我们就可以在代码中来执行一些<code>debug</code>与<code>release</code>时不同的操作，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if DEBUG</div><div class="line">    let totalSeconds = totalMinutes</div><div class="line">#else</div><div class="line">    let totalSeconds = totalMinutes * 60</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>一个简单的条件编译声明如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if build configuration</div><div class="line">    statements</div><div class="line">#else</div><div class="line">    statements</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>当然，<code>statements</code>中可以包含<code>0</code>个或多个有效的<code>swift</code>的<code>statements</code>，其中可以包括表达式、语句、和控制流语句。另外，我们也可以使用<code>&amp;&amp;</code>和<code>||</code>操作符来组合多个<code>build configuration</code>，同时，可以使用!操作符来对<code>build configuration</code>取反，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#if build configuration &amp;&amp; !build configuration</div><div class="line">    statements</div><div class="line">#elseif build configuration</div><div class="line">	statements</div><div class="line">#else</div><div class="line">	statements</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>需要注意的是，在<code>swift</code>中，条件编译语句必须在语法上是有效的，因为即使这些代码不会被编译，<code>swift</code>也会对其进行语法检查。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.giorgiocalderolla.com/cross-platform-swift.html" target="_blank" rel="external">Cross-platform Swift</a></li>
<li><a href="http://stackoverflow.com/questions/24403551/shimming-in-swift" target="_blank" rel="external">Shimming in Swift</a></li>
<li><a href="http://nshipster.com/swift-system-version-checking/" target="_blank" rel="external">Swift System Version Checking</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-XID_21" target="_blank" rel="external">Interacting with C APIs</a></li>
</ol>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p>在涉及到表单输入的界面中，我们通常需要监听一些键盘事件，并根据实际需要来执行相应的操作。如，键盘弹起时，要让我们的<code>UIScrollView</code>自动收缩，以能看到整个<code>UIScrollView</code>的内容。为此，在<code>UIWindow.h</code>中定义了如下<code>6</code>个通知常量，来配合键盘在不同时间点的事件处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">UIKeyboardWillShowNotification			// 键盘显示之前</div><div class="line">UIKeyboardDidShowNotification			// 键盘显示完成后</div><div class="line">UIKeyboardWillHideNotification			// 键盘隐藏之前</div><div class="line">UIKeyboardDidHideNotification			// 键盘消息之后</div><div class="line">UIKeyboardWillChangeFrameNotification	// 键盘大小改变之前</div><div class="line">UIKeyboardDidChangeFrameNotification	// 键盘大小改变之后</div></pre></td></tr></table></figure>
<p>这几个通知的<code>object</code>对象都是<code>nil</code>。而<code>userInfo</code>字典都包含了一些键盘的信息，主要是键盘的位置大小信息，我们可以通过使用以下的<code>key</code>来获取字典中对应的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 键盘在动画开始前的frame</div><div class="line">let UIKeyboardFrameBeginUserInfoKey: String</div><div class="line"></div><div class="line">// 键盘在动画线束后的frame</div><div class="line">let UIKeyboardFrameEndUserInfoKey: String</div><div class="line"></div><div class="line">// 键盘的动画曲线</div><div class="line">let UIKeyboardAnimationCurveUserInfoKey: String</div><div class="line"></div><div class="line">// 键盘的动画时间</div><div class="line">let UIKeyboardAnimationDurationUserInfoKey: String</div></pre></td></tr></table></figure>
<p>在此，我感兴趣的是键盘事件的调用顺序和如何获取键盘的大小，以适当的调整视图的大小。</p>
<p>从定义的键盘通知的类型可以看到，实际上我们关注的是三个阶段的键盘的事件：显示、隐藏、大小改变。在此我们设定两个<code>UITextField</code>，它们的键盘类型不同：一个是普通键盘，一个是数字键盘。我们监听所有的键盘事件，并打印相关日志(在此就不贴代码了)，直接看结果。</p>
<p>1) 当我们让<code>textField1</code>获取输入焦点时，打印的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">keyboard will change</div><div class="line">keyboard will show</div><div class="line">keyboard did change</div><div class="line">keyboard did show</div></pre></td></tr></table></figure>
<p>2) 在不隐藏键盘的情况下，让<code>textField2</code>获取焦点，打印的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">keyboard will change</div><div class="line">keyboard will show</div><div class="line">keyboard did change</div><div class="line">keyboard did show</div></pre></td></tr></table></figure>
<p>3) 再收起键盘，打印的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">keyboard will change</div><div class="line">keyboard will hide</div><div class="line">keyboard did change</div><div class="line">keyboard did hide</div></pre></td></tr></table></figure>
<p>从上面的日志可以看出，不管是键盘的显示还是隐藏，都会发送大小改变的通知，而且是在<code>show</code>和<code>hide</code>的对应事件之前。而在大小不同的键盘之间切换时，除了发送<code>change</code>事件外，还会发送<code>show</code>事件(不发送<code>hide</code>事件)。</p>
<p>另外还有两点需要注意的是：</p>
<ol>
<li>如果是在两个大小相同的键盘之间切换，则不会发送任何消息</li>
<li>如果是普通键盘中类似于中英文键盘的切换，只要大小改变了，都会发送一组或多组与上面2)相同流程的消息</li>
</ol>
<p>了解了事件的调用顺序，我们就可以根据自己的需要来决定在哪个消息处理方法中来执行操作。为此，我们需要获取一些有用的信息。这些信息是封装在通知的<code>userInfo</code>中，通过上面常量<code>key</code>来获取相关的值。通常我们关心的是<code>UIKeyboardFrameEndUserInfoKey</code>，来获取动画完成后，键盘的<code>frame</code>，以此来计算我们的<code>scroll view</code>的高度。另外，我们可能希望<code>scroll view</code>高度的变化也是通过动画来过渡的，此时<code>UIKeyboardAnimationCurveUserInfoKey</code>和<code>UIKeyboardAnimationDurationUserInfoKey</code>就有用了。</p>
<p>我们可以通过以下方式来获取这些值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if let dict = notification.userInfo &#123;</div><div class="line">    var animationDuration: NSTimeInterval = 0</div><div class="line">    var animationCurve: UIViewAnimationCurve = .EaseInOut</div><div class="line">    var keyboardEndFrame: CGRect = CGRectZero</div><div class="line"></div><div class="line">    dict[UIKeyboardAnimationCurveUserInfoKey]?.getValue(&amp;animationCurve)</div><div class="line">    dict[UIKeyboardAnimationDurationUserInfoKey]?.getValue(&amp;animationDuration)</div><div class="line">    dict[UIKeyboardFrameEndUserInfoKey]?.getValue(&amp;keyboardEndFrame)</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，<code>userInfo</code>中还有另外三个值，只不过这几个值从<code>iOS 3.2</code>开始就已经废弃不用了。所以我们不用太关注。</p>
<p>最后说下表单。一个表单界面看着比较简单，但交互和UI总是能想出各种方法来让它变得复杂，而且其实里面设计到的细节还是很多的。像我们金融类的<code>App</code>，通常都会涉及到大量的表单输入，所以如何做好，还是需要花一番心思的。空闲时，打算总结一下，写一篇文章。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIWindow_Class/#//apple_ref/doc/constant_group/Keyboard_Notification_User_Info_Keys" target="_blank" rel="external">UIWindow Class Reference</a></li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="自定义UIPickerView的行"><a href="#自定义UIPickerView的行" class="headerlink" title="自定义UIPickerView的行"></a>自定义UIPickerView的行</h3><p><code>UIPickerView</code>的主要内容实际上并不多，主要是一个<code>UIPickerView</code>类和对应的<code>UIPickerViewDelegate</code>，<code>UIPickerViewDataSource</code>协议，分别表示代理和数据源。在此不细说这些，只是解答我们遇到的一个小需求。</p>
<p>通常，<code>UIPickerView</code>是可以定义多列内容的，比如年、月、日三列，这些列之间相互不干扰，可以自已滚自己的，不碍别人的事。不过，我们有这么一个需求，也是有三列，但这三列需要一起滚。嗯，这个就需要另行处理了。</p>
<p>在<code>UIPickerViewDelegate</code>中，声明了下面这样一个代理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (UIView *)pickerView:(UIPickerView *)pickerView</div><div class="line">        viewForRow:(NSInteger)row</div><div class="line">      forComponent:(NSInteger)component</div><div class="line">       reusingView:(UIView *)view</div></pre></td></tr></table></figure>
<p>我们通过这个方法就可以来自定义行的视图。时间不早，废话就不多说了，直接上代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view &#123;</div><div class="line">    PickerViewCell *pickerCell = (PickerViewCell *)view;</div><div class="line"></div><div class="line">    if (!pickerCell) &#123;</div><div class="line">        NSInteger column = 3;</div><div class="line">        pickerCell = [[PickerViewCell alloc] initWithFrame:(CGRect)&#123;CGPointZero, [UIScreen mainScreen].bounds.size.width, 45.0f&#125; column:column];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [pickerCell setLabelTexts:@[...]];</div><div class="line"></div><div class="line">    return pickerCell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们定义了一个<code>PickerViewCell</code>视图，里面根据我们的传入的<code>column</code>参数来等分放置<code>column</code>个<code>UILabel</code>，并通过<code>setLabelTexts</code>来设置每个<code>UILabel</code>的文本。当然，我们也可以在<code>PickerViewCell</code>去定义<code>UILabel</code>的外观显示。就是这么简单。</p>
<p>不过，还有个需要注意的就是，虽然看上去是显示了<code>3</code>列，但实际上是按<code>1</code>列来处理的，所以下面的实现应该是返回<code>1</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView &#123;</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIPickerViewDelegate_Protocol/" target="_blank" rel="external">UIPickerViewDelegate Protocol Reference</a></li>
</ol>
<h3 id="Swift中”-AnyObject-does-not-have-a-member-named-generator”-问题的处理"><a href="#Swift中”-AnyObject-does-not-have-a-member-named-generator”-问题的处理" class="headerlink" title="Swift中”[AnyObject]? does not have a member named generator” 问题的处理"></a>Swift中”[AnyObject]? does not have a member named generator” 问题的处理</h3><p>有个小需求，需要遍历当前导航控制器栈的所有<code>ViewController</code>。<code>UINavigationController</code>类自身的<code>viewControllers</code>属性返回的是一个<code>[AnyObject]!</code>数组，不过由于我的导航控制器本身有可能是<code>nil</code>，所以我获取到的<code>ViewController</code>数组如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myViewControllers: [AnyObject]? = navigationController?.viewControllers</div></pre></td></tr></table></figure>
<p>获取到的<code>myViewControllers</code>是一个<code>[AnyObject]?</code>可选类型，这时如果我直接去遍历<code>myViewControllers</code>，如下代码所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for controller in myViewControllers &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器会报错，提示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[AnyObject]? does not have a member named &quot;Generator&quot;</div></pre></td></tr></table></figure>
<p>实际上，不管是<code>[AnyObject]?</code>还是其它的诸如<code>[String]?</code>类型，都会报这个错。其原因是可选类型只是个容器，它与其所包装的值是不同的类型，也就是说<code>[AnyObject]</code>是一个数组类型，但<code>[AnyObject]?</code>并不是数组类型。我们可以迭代一个数组，但不是迭代一个非集合类型。</p>
<p>在<a href="http://stackoverflow.com/questions/26852656/loop-through-anyobject-results-in-does-not-have-a-member-named-generator" target="_blank" rel="external">stackoverflow</a>上有这样一个有趣的比方，我犯懒就直接贴出来了：</p>
<blockquote>
<p>To understand the difference, let me make a real life example: you buy a new TV on ebay, the package is shipped to you, the first thing you do is to check if the package (the optional) is empty (nil). Once you verify that the TV is inside, you have to unwrap it, and put the box aside. You cannot use the TV while it’s in the package. Similarly, an optional is a container: it is not the value it contains, and it doesn’t have the same type. It can be empty, or it can contain a valid value.</p>
</blockquote>
<p>所以，这里的处理应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if let controllers = myViewControllers &#123;</div><div class="line">    for controller in controllers &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    </p>
<h4 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://stackoverflow.com/questions/26852656/loop-through-anyobject-results-in-does-not-have-a-member-named-generator" target="_blank" rel="external">Loop through [AnyObject]? results in does not have a member named generator</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/31/ios-techset-2/" itemprop="url">
                  iOS知识小集 第2期(2015.05.31)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-31T23:50:54+08:00" content="2015-05-31">
              2015-05-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>换了个厂子，还不到1个月。哎，着实是累啊，基本上是996.5的节奏，只会更多。加班把我快加吐了，但人在江湖，身不由已啊。为了讨口饭吃，命也不要了。谁让咱只是个臭写代码的呢。不过加班是多，只是长得太丑，所有没办法，没时间也得抽时间来学习。不然，饭都没得吃了，还得养家糊口呢。</p>
<p>本期总结的内容不是很多，主要有以下几个问题：</p>
<ol>
<li>使用<code>UIVisualEffectView</code>为视图添加特殊效果</li>
<li><code>Nullability Annotations</code></li>
<li><code>weak</code>的生命周期</li>
</ol>
<h2 id="使用UIVisualEffectView为视图添加特殊效果"><a href="#使用UIVisualEffectView为视图添加特殊效果" class="headerlink" title="使用UIVisualEffectView为视图添加特殊效果"></a>使用UIVisualEffectView为视图添加特殊效果</h2><p>在<code>iOS 8</code>后，苹果开放了不少创建特效的接口，其中就包括创建毛玻璃(<code>blur</code>)的接口。</p>
<p>通常要想创建一个特殊效果(如<code>blur</code>效果)，可以创建一个<code>UIVisualEffectView</code>视图对象，这个对象提供了一种简单的方式来实现复杂的视觉效果。这个可以把这个对象看作是效果的一个容器，实际的效果会影响到该视图对象底下的内容，或者是添加到该视图对象的<code>contentView</code>中的内容。</p>
<p>我们举个例子来看看如果使用<code>UIVisualEffectView</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let bgView: UIImageView = UIImageView(image: UIImage(named: &quot;visual&quot;))</div><div class="line">bgView.frame = self.view.bounds</div><div class="line">self.view.addSubview(bgView)</div><div class="line"></div><div class="line">let blurEffect: UIBlurEffect = UIBlurEffect(style: .Light)</div><div class="line">let blurView: UIVisualEffectView = UIVisualEffectView(effect: blurEffect)</div><div class="line">blurView.frame = CGRectMake(50.0, 50.0, self.view.frame.width - 100.0, 200.0)</div><div class="line">self.view.addSubview(blurView)</div></pre></td></tr></table></figure>
<p>这段代码是在当前视图控制器上添加了一个<code>UIImageView</code>作为背景图。然后在视图的一小部分中使用了<code>blur</code>效果。其效果如下所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/blur%20effect.png?raw=true" alt="image"></p>
<p>我们可以看到<code>UIVisualEffectView</code>还是非常简单的。需要注意是的，不应该直接添加子视图到<code>UIVisualEffectView</code>视图中，而是应该添加到<code>UIVisualEffectView</code>对象的<code>contentView</code>中。</p>
<p>另外，尽量避免将<code>UIVisualEffectView</code>对象的<code>alpha</code>值设置为小于<code>1.0</code>的值，因为创建半透明的视图会导致系统在离屏渲染时去对<code>UIVisualEffectView</code>对象及所有的相关的子视图做混合操作。这不但消耗<code>CPU/GPU</code>，也可能会导致许多效果显示不正确或者根本不显示。</p>
<p>我们在上面看到，初始化一个<code>UIVisualEffectView</code>对象的方法是<code>UIVisualEffectView(effect: blurEffect)</code>，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init(effect effect: UIVisualEffect)</div></pre></td></tr></table></figure>
<p>这个方法的参数是一个<code>UIVisualEffect</code>对象。我们查看官方文档，可以看到在UIKit中，定义了几个专门用来创建视觉特效的，它们分别是<code>UIVisualEffect</code>、<code>UIBlurEffect</code>和<code>UIVibrancyEffect</code>。它们的继承层次如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSObject</div><div class="line">	| -- UIVisualEffect</div><div class="line">		| -- UIBlurEffect</div><div class="line">		| -- UIVibrancyEffect</div></pre></td></tr></table></figure>
<p><code>UIVisualEffect</code>是一个继承自<code>NSObject</code>的创建视觉效果的基类，然而这个类除了继承自<code>NSObject</code>的属性和方法外，没有提供任何新的属性和方法。其主要目的是用于初始化<code>UIVisualEffectView</code>，在这个初始化方法中可以传入<code>UIBlurEffect</code>或者<code>UIVibrancyEffect</code>对象。</p>
<p>一个<code>UIBlurEffect</code>对象用于将<code>blur</code>(毛玻璃)效果应用于<code>UIVisualEffectView</code>视图下面的内容。如上面的示例所示。不过，这个对象的效果并不影响<code>UIVisualEffectView</code>对象的<code>contentView</code>中的内容。</p>
<p><code>UIBlurEffect</code>主要定义了三种效果，这些效果由枚举<code>UIBlurEffectStyle</code>来确定，该枚举的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum UIBlurEffectStyle : Int &#123;</div><div class="line">    case ExtraLight</div><div class="line">    case Light</div><div class="line">    case Dark</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其主要是根据色调(<code>hue</code>)来确定特效视图与底部视图的混合。</p>
<p>与<code>UIBlurEffect</code>不同的是，<code>UIVibrancyEffect</code>主要用于放大和调整<code>UIVisualEffectView</code>视图下面的内容的颜色，同时让<code>UIVisualEffectView</code>的<code>contentView</code>中的内容看起来更加生动。通常<code>UIVibrancyEffect</code>对象是与<code>UIBlurEffect</code>一起使用，主要用于处理在<code>UIBlurEffect</code>特效上的一些显示效果。接上面的代码，我们看看在blur的视图上添加一些新的特效，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let vibrancyView: UIVisualEffectView = UIVisualEffectView(effect: UIVibrancyEffect(forBlurEffect: blurEffect))</div><div class="line">vibrancyView.setTranslatesAutoresizingMaskIntoConstraints(false)</div><div class="line">blurView.contentView.addSubview(vibrancyView)</div><div class="line"></div><div class="line">var label: UILabel = UILabel()</div><div class="line">label.setTranslatesAutoresizingMaskIntoConstraints(false)</div><div class="line">label.text = &quot;Vibrancy Effect&quot;</div><div class="line">label.font = UIFont(name: &quot;HelveticaNeue-Bold&quot;, size: 30)</div><div class="line">label.textAlignment = .Center</div><div class="line">label.textColor = UIColor.whiteColor()</div><div class="line">vibrancyView.contentView.addSubview(label)</div></pre></td></tr></table></figure>
<p>其效果如下图所示：</p>
<p><img src="https://github.com/southpeak/Blog-images/blob/master/Vibrancy%20effect.png?raw=true" alt="image"></p>
<p><code>vibrancy</code>特效是取决于颜色值的。所有添加到<code>contentView</code>的子视图都必须实现<code>tintColorDidChange</code>方法并更新自己。需要注意的是，我们使用<code>UIVibrancyEffect(forBlurEffect:)</code>方法创建<code>UIVibrancyEffect</code>时，参数<code>blurEffect</code>必须是我们想加效果的那个<code>blurEffect</code>，否则可能不是我们想要的效果。</p>
<p>另外，<code>UIVibrancyEffect</code>还提供了一个类方法<code>notificationCenterVibrancyEffect</code>，其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class func notificationCenterVibrancyEffect() -&gt; UIVibrancyEffect!</div></pre></td></tr></table></figure>
<p>这个方法创建一个用于通知中心的<code>Today</code>扩展的<code>vibrancy</code>特效。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVisualEffectView/" target="_blank" rel="external">UIVisualEffectView Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVisualEffect_class/index.html#//apple_ref/occ/cl/UIVisualEffect" target="_blank" rel="external">UIVisualEffect Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVisualEffect_class/index.html#//apple_ref/occ/cl/UIVisualEffect" target="_blank" rel="external">UIBlurEffect Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVibrancyEffect/" target="_blank" rel="external">UIVibrancyEffect Class Reference</a></li>
<li><a href="http://swiftoverload.com/tag/uivisualeffectview/" target="_blank" rel="external">UIVisualEffect – Swift Tutorial</a></li>
<li><a href="http://idrawcode.tumblr.com/post/101925733632/ios-8-uivisualeffect" target="_blank" rel="external">iOS 8: UIVisualEffect</a></li>
</ol>
<h2 id="Pointer-is-missing-a-nullability-type-specifier-nonnull-or-nullable-问题的处理-–-Nullability-Annotations"><a href="#Pointer-is-missing-a-nullability-type-specifier-nonnull-or-nullable-问题的处理-–-Nullability-Annotations" class="headerlink" title="Pointer is missing a nullability type specifier (nonnull or nullable)问题的处理 – Nullability Annotations"></a>Pointer is missing a nullability type specifier (<strong>nonnull or </strong>nullable)问题的处理 – Nullability Annotations</h2><p>最近在用<code>Xcode 6.3</code>写代码，一些涉及到对象的代码会报如下编译器警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pointer is missing a nullability type specifier (_nonnull or _nullable)</div></pre></td></tr></table></figure>
<p>于是<code>google</code>了一下，发现这是<code>Xcode 6.3</code>的一个新特性，即<strong>nullability annotations</strong>。</p>
<h3 id="Nullability-Annotations"><a href="#Nullability-Annotations" class="headerlink" title="Nullability Annotations"></a>Nullability Annotations</h3><p>我们都知道在<code>swift</code>中，可以使用<code>!</code>和<code>?</code>来表示一个对象是<code>optional</code>的还是<code>non-optional</code>，如<code>view?</code>和<code>view!</code>。而在<code>Objective-C</code>中则没有这一区分，<code>view</code>即可表示这个对象是<code>optional</code>，也可表示是<code>non-optional</code>。这样就会造成一个问题：在<code>Swift</code>与<code>Objective-C</code>混编时，<code>Swift</code>编译器并不知道一个<code>Objective-C</code>对象到底是<code>optional</code>还是<code>non-optional</code>，因此这种情况下编译器会隐式地将<code>Objective-C</code>的对象当成是<code>non-optional</code>。</p>
<p>为了解决这个问题，苹果在<code>Xcode 6.3</code>引入了一个<code>Objective-C</code>的新特性：<code>nullability annotations</code>。这一新特性的核心是两个新的类型注释：<strong>__nullable</strong>和<strong>__nonnull</strong>。从字面上我们可以猜到，<strong>__nullable</strong>表示对象可以是<code>NULL</code>或<code>nil</code>，而<strong>__nonnull</strong>表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。</p>
<p>我们来看看以下的实例，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@interface TestNullabilityClass ()</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSArray * items;</div><div class="line"></div><div class="line">- (id)itemWithName:(NSString * __nonnull)name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TestNullabilityClass</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">- (void)testNullability &#123;</div><div class="line">    [self itemWithName:nil];	// 编译器警告：Null passed to a callee that requires a non-null argument</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)itemWithName:(NSString * __nonnull)name &#123;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>不过这只是一个警告，程序还是能编译通过并运行。</p>
<p>事实上，在任何可以使用<code>const</code>关键字的地方都可以使用<code>__nullable</code>和<code>__nonnull</code>，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的<code>nullable</code>和<code>nonnull</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (nullable id)itemWithName:(NSString * nonnull)name</div></pre></td></tr></table></figure>
<p>在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy, nonnull) NSArray * items;</div></pre></td></tr></table></figure>
<p>当然也可以用以下这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSArray * __nonnull items;</div></pre></td></tr></table></figure>
<p>推荐使用<code>nonnull</code>这种方式，这样可以让属性声明看起来更清晰。</p>
<h3 id="Nonnull区域设置-Audited-Regions"><a href="#Nonnull区域设置-Audited-Regions" class="headerlink" title="Nonnull区域设置(Audited Regions)"></a>Nonnull区域设置(Audited Regions)</h3><p>如果需要每个属性或每个方法都去指定<code>nonnull</code>和<code>nullable</code>，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>。在这两个宏之间的代码，所有简单指针对象都被假定为<code>nonnull</code>，因此我们只需要去指定那些<code>nullable</code>的指针。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NS_ASSUME_NONNULL_BEGIN</div><div class="line"></div><div class="line">@interface TestNullabilityClass ()</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSArray * items;</div><div class="line"></div><div class="line">- (id)itemWithName:(nullable NSString *)name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">NS_ASSUME_NONNULL_END</div></pre></td></tr></table></figure>
<p>在上面的代码中，<code>items</code>属性默认是<code>non null</code>的，<code>itemWithName:</code>方法的返回值也是<code>non null</code>，而参数是指定为<code>nullable</code>的。</p>
<p>不过，为了安全起见，苹果还制定了几条规则：</p>
<ol>
<li>typedef定义的类型的<code>nullability</code>特性通常依赖于上下文，即使是在<code>Audited Regions</code>中，也不能假定它为<code>nonnull</code>。</li>
<li>复杂的指针类型(如id <em>)必须显示去指定是<code>nonnull</code>还是<code>nullable</code>。例如，指定一个指向nullable对象的<code>nonnull</code>指针，可以使用`”__nullable id </em> __nonnull”`。</li>
<li>我们经常使用的<code>NSError **</code>通常是被假定为一个指向<code>nullable NSError</code>对象的<code>nullable</code>指针。</li>
</ol>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>因为<code>Nullability Annotations</code>是<code>Xcode 6.3</code>新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们：</p>
<ol>
<li>老代码仍然能正常工作，即使对<code>nonnull</code>对象使用了<code>nil</code>也没有问题。</li>
<li>老代码在需要和<code>swift</code>混编时，在新的<code>swift</code>编译器下会给出一个警告。</li>
<li><code>nonnull</code>不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为<code>nil</code>。</li>
</ol>
<p>事实上，我们可以将<code>nonnull/nullable</code>与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是<code>nonnull</code>的，则我们不应该返回<code>nil</code>，除非是为了向后兼容。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/swift/blog/?id=25" target="_blank" rel="external">Nullability and Objective-C</a></li>
</ol>
<h2 id="weak的生命周期"><a href="#weak的生命周期" class="headerlink" title="weak的生命周期"></a>weak的生命周期</h2><p>我们都知道<code>weak</code>表示的是一个弱引用，这个引用不会增加对象的引用计数，并且在所指向的对象被释放之后，<code>weak</code>指针会被设置的为<code>nil</code>。<code>weak</code>引用通常是用于处理循环引用的问题，如代理及block的使用中，相对会较多的使用到<code>weak</code>。</p>
<p>之前对weak的实现略有了解，知道它的一个基本的生命周期，但具体是怎么实现的，了解得不是太清晰。今天又翻了翻《Objective-C高级编程》关于<code>__weak</code>的讲解，在此做个笔记。</p>
<p>我们以下面这行代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    id __weak obj1 = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们初始化一个<code>weak</code>变量时，<code>runtime</code>会调用<code>objc_initWeak</code>函数。这个函数在<code>Clang</code>中的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_initWeak(id *object, id value);</div></pre></td></tr></table></figure>
<p>其具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">id objc_initWeak(id *object, id value)</div><div class="line">&#123;</div><div class="line">    *object = 0;</div><div class="line">    return objc_storeWeak(object, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例代码轮换成编译器的模拟代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id obj1;</div><div class="line">objc_initWeak(&amp;obj1, obj);</div></pre></td></tr></table></figure>
<p>因此，这里所做的事是先将<code>obj1</code>初始化为<code>0(nil)</code>，然后将<code>obj1</code>的地址及<code>obj</code>作为参数传递给<code>objc_storeWeak</code>函数。</p>
<p><code>objc_initWeak</code>函数有一个前提条件：就是<code>object</code>必须是一个没有被注册为<code>__weak</code>对象的有效指针。而<code>value</code>则可以是<code>null</code>，或者指向一个有效的对象。</p>
<p>如果<code>value</code>是一个空指针或者其指向的对象已经被释放了，则<code>object</code>是<code>zero-initialized</code>的。否则，<code>object</code>将被注册为一个指向<code>value</code>的<code>__weak</code>对象。而这事应该是<code>objc_storeWeak</code>函数干的。<code>objc_storeWeak</code>的函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_storeWeak(id *location, id value);</div></pre></td></tr></table></figure>
<p>其具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">id objc_storeWeak(id *location, id newObj)</div><div class="line">&#123;</div><div class="line">    id oldObj;</div><div class="line">    SideTable *oldTable;</div><div class="line">    SideTable *newTable;</div><div class="line">    ......</div><div class="line"></div><div class="line">    // Acquire locks for old and new values.</div><div class="line">    // Order by lock address to prevent lock ordering problems. </div><div class="line">    // Retry if the old value changes underneath us.</div><div class="line"> retry:</div><div class="line">    oldObj = *location;</div><div class="line"></div><div class="line">    oldTable = SideTable::tableForPointer(oldObj);</div><div class="line">    newTable = SideTable::tableForPointer(newObj);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    if (*location != oldObj) &#123;</div><div class="line">        OSSpinLockUnlock(lock1);</div><div class="line"></div><div class="line">#if SIDE_TABLE_STRIPE &gt; 1</div><div class="line">        if (lock1 != lock2) OSSpinLockUnlock(lock2);</div><div class="line">#endif</div><div class="line">        goto retry;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (oldObj) &#123;</div><div class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (newObj) &#123;</div><div class="line">        newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);</div><div class="line">        </div><div class="line">        // weak_register_no_lock returns NULL if weak store should be rejected</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Do not set *location anywhere else. That would introduce a race.</div><div class="line">    *location = newObj;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    return newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们撇开源码中各种锁操作，来看看这段代码都做了些什么。在此之前，我们先来了解下<code>weak</code>表和<code>SideTable</code>。</p>
<p><code>weak</code>表是一个弱引用表，实现为一个<code>weak_table_t</code>结构体，存储了某个对象相关的的所有的弱引用信息。其定义如下(具体定义在<a href="http://www.opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h" target="_blank" rel="external">objc-weak.h</a>中)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct weak_table_t &#123;</div><div class="line">    weak_entry_t *weak_entries;</div><div class="line">    size_t    num_entries;</div><div class="line">    ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中<code>weak_entry_t</code>是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用<code>hash</code>表。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct weak_entry_t &#123;</div><div class="line"></div><div class="line">    DisguisedPtr&lt;objc_object&gt; referent;</div><div class="line">    union &#123;</div><div class="line">        struct &#123;</div><div class="line">            weak_referrer_t *referrers;</div><div class="line">            uintptr_t        out_of_line : 1;</div><div class="line">            ......</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        struct &#123;</div><div class="line">            // out_of_line=0 is LSB of one of these (don&apos;t care which)</div><div class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中<code>referent</code>是被引用的对象，即示例代码中的<code>obj</code>对象。下面的<code>union</code>即存储了所有指向该对象的弱引用。由注释可以看到，当<code>out_of_line</code>等于<code>0</code>时，<code>hash</code>表被一个数组所代替。另外，所有的弱引用对象的地址都是存储在<code>weak_referrer_t</code>指针的地址中。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef objc_object ** weak_referrer_t;</div></pre></td></tr></table></figure>
<p><code>SideTable</code>是一个用<code>C++</code>实现的类，它的具体定义在<a href="http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm" target="_blank" rel="external">NSObject.mm</a>中，我们来看看它的一些成员变量的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class SideTable &#123;</div><div class="line"></div><div class="line">private:</div><div class="line">    static uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];</div><div class="line"></div><div class="line">public:</div><div class="line">    RefcountMap refcnts;</div><div class="line">    weak_table_t weak_table;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>RefcountMap refcnts</code>，大家应该能猜到这个做什么用的吧？看着像是引用计数什么的。哈哈，貌似就是啊，这东东存储了一个对象的引用计数的信息。当然，我们在这里不去探究它，我们关注的是<code>weak_table</code>。这个成员变量指向的就是一个对象的<code>weak</code>表。</p>
<p>了解了<code>weak</code>表和<code>SideTable</code>，让我们再回过头来看看<code>objc_storeWeak</code>。首先是根据<code>weak</code>指针找到其指向的老的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">oldObj = *location;</div></pre></td></tr></table></figure>
<p>然后获取到与新旧对象相关的SideTable对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">oldTable = SideTable::tableForPointer(oldObj);</div><div class="line">newTable = SideTable::tableForPointer(newObj);</div></pre></td></tr></table></figure>
<p>下面要做的就是在老对象的<code>weak</code>表中移除指向信息，而在新对象的<code>weak</code>表中建立关联信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (oldObj) &#123;</div><div class="line">    weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</div><div class="line">&#125;</div><div class="line">if (newObj) &#123;</div><div class="line">    newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);</div><div class="line">    // weak_register_no_lock returns NULL if weak store should be rejected</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来让弱引用指针指向新的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*location = newObj;</div></pre></td></tr></table></figure>
<p>最后会返回这个新对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return newObj;</div></pre></td></tr></table></figure>
<p><code>objc_storeWeak</code>的基本实现就是这样。当然，在<code>objc_initWeak</code>中调用<code>objc_storeWeak</code>时，老对象是空的，所有不会执行<code>weak_unregister_no_lock</code>操作。</p>
<p>而当<code>weak</code>引用指向的对象被释放时，又是如何去处理<code>weak</code>指针的呢？当释放对象时，其基本流程如下：</p>
<ol>
<li>调用<code>objc_release</code></li>
<li>因为对象的引用计数为<code>0</code>，所以执行<code>dealloc</code></li>
<li>在<code>dealloc</code>中，调用了<code>_objc_rootDealloc</code>函数</li>
<li>在<code>_objc_rootDealloc</code>中，调用了<code>object_dispose</code>函数</li>
<li>调用<code>objc_destructInstance</code></li>
<li>最后调用<code>objc_clear_deallocating</code></li>
</ol>
<p>我们重点关注一下最后一步，<code>objc_clear_deallocating</code>的具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void objc_clear_deallocating(id obj) </div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    SideTable *table = SideTable::tableForPointer(obj);</div><div class="line">    </div><div class="line">    // clear any weak table items</div><div class="line">    // clear extra retain count and deallocating bit</div><div class="line">    // (fixme warn or abort if extra retain count == 0 ?)</div><div class="line">    OSSpinLockLock(&amp;table-&gt;slock);</div><div class="line"></div><div class="line">    if (seen_weak_refs) &#123;</div><div class="line">        arr_clear_deallocating(&amp;table-&gt;weak_table, obj);</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在这个函数中，首先取出对象对应的<code>SideTable</code>实例，如果这个对象有关联的弱引用，则调用<code>arr_clear_deallocating</code>来清除对象的弱引用信息。我们来看看<code>arr_clear_deallocating</code>具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">PRIVATE_EXTERN void arr_clear_deallocating(weak_table_t *weak_table, id referent) &#123;</div><div class="line">    &#123;</div><div class="line">        weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</div><div class="line"></div><div class="line">        if (entry == NULL) &#123;</div><div class="line">            ......</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // zero out references</div><div class="line">        for (int i = 0; i &lt; entry-&gt;referrers.num_allocated; ++i) &#123;</div><div class="line"></div><div class="line">            id *referrer = entry-&gt;referrers.refs[i].referrer;</div><div class="line">            </div><div class="line">            if (referrer) &#123;</div><div class="line">                if (*referrer == referent) &#123;</div><div class="line">                    *referrer = nil;</div><div class="line">                &#125;</div><div class="line">                else if (*referrer) &#123;</div><div class="line">                    objc_inform(&quot;_weak variable @ %p holds %p instead of %p\n&quot;, referrer, *referrer, referent);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        weak_entry_remove_no_lock(weak_table, entry);</div><div class="line">        weak_table-&gt;num_weak_refs--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数首先是找出对象对应的<code>weak_entry_t</code>链表，然后挨个将弱引用置为<code>nil</code>。最后清理对象的记录。</p>
<p>通过上面的描述，我们基本能了解一个<code>weak</code>引用从生到死的过程。从这个流程可以看出，一个<code>weak</code>引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用<code>__weak</code>变量的话，会对性能造成一定的影响。那么，我们应该在什么时候去使用<code>weak</code>呢？《Objective-C高级编程》给我们的建议是只在避免循环引用的时候使用<code>__weak</code>修饰符。</p>
<p>另外，在<code>clang</code>中，还提供了不少关于<code>weak</code>引用的处理函数。如<code>objc_loadWeak</code>,<code>objc_destroyWeak</code>, <code>objc_moveWeak</code>等，我们可以在苹果的开源代码中找到相关的实现。等有时间，我再好好研究研究。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li>《Objective-C高级编程》1.4: __weak修饰符</li>
<li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="external">Clang 3.7 documentation - Objective-C Automatic Reference Counting (ARC)</a></li>
<li><a href="http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm" target="_blank" rel="external">apple opensource - NSObject.mm</a></li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h3><p><code>CAGradientLayer</code>类是用于在其背景色上绘制一个颜色渐变，以填充层的整个形状，包括圆角。这个类继承自<code>CALayer</code>类，使用起来还是很方便的。</p>
<p>与<code>Quartz 2D</code>中的渐变处理类似，一个渐变有一个起始位置(<code>startPoint</code>)和一个结束位置(<code>endPoint</code>)，在这两个位置之间，我们可以指定一组颜色值(<code>colors</code>，元素是<code>CGColorRef</code>对象)，可以是两个，也可以是多个，每个颜色值会对应一个位置(<code>locations</code>)。另外，渐变还分为轴向渐变和径向渐变。</p>
<p>我们写个实例来看看<code>CAGradientLayer</code>的具体使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CAGradientLayer *layer = [CAGradientLayer layer];</div><div class="line">layer.startPoint = (CGPoint)&#123;0.5f, 0.0f&#125;;</div><div class="line">layer.endPoint = (CGPoint)&#123;0.5f, 1.0f&#125;;</div><div class="line">layer.colors = [NSArray arrayWithObjects:(id)[UIColor blueColor].CGColor, (id)[UIColor redColor].CGColor, (id)[UIColor greenColor].CGColor, nil];</div><div class="line">layer.locations = @[@0.0f, @0.6f, @1.0f];</div><div class="line">layer.frame = self.view.layer.bounds;</div><div class="line"></div><div class="line">[self.view.layer insertSublayer:layer atIndex:0];</div></pre></td></tr></table></figure>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAGradientLayer_class/" target="_blank" rel="external">CAGradientLayer Class Reference</a></li>
</ol>
<h3 id="Xcode中Ineligible-Devices的处理"><a href="#Xcode中Ineligible-Devices的处理" class="headerlink" title="Xcode中Ineligible Devices的处理"></a>Xcode中Ineligible Devices的处理</h3><p>换了台新电脑，装了个<code>Xcode 6.3</code>，整了个新证书和<code>profile</code>，然后打开<code>Xcode</code>，连上手机。额，然后发现设备居然被标识为<code>Ineligible Devices</code>，没认出来。情况类似于下图：</p>
<p><img src="http://i.stack.imgur.com/CFOSG.png" alt="image"></p>
<p>电脑是受信任的，证书和<code>profile</code>也都是<code>OK</code>的。试了几次重启<code>Xcode</code>和重新连接手机，无效。设备就是选不了。最后是在<code>Product</code>-&gt;<code>Destination</code>里面才选中这个设备的。不过在工具栏还是不能选择，郁闷，求解。</p>
<h3 id="iOS-7后隐藏UITextField的光标"><a href="#iOS-7后隐藏UITextField的光标" class="headerlink" title="iOS 7后隐藏UITextField的光标"></a>iOS 7后隐藏UITextField的光标</h3><p>新项目只支持<code>iOS 7</code>后，很多事情变得简单多了，就像隐藏<code>UITextField</code>的光标一样，就简单的一句话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textFiled.tintColor = [UIColor clearColor];</div></pre></td></tr></table></figure>
<p>通常我们用<code>UIPickerView</code>作为我们的<code>UITextField</code>的<code>inputView</code>时，我们是需要隐藏光标的。当然，如果想换个光标颜色，也是这么处理。</p>
<p>这么处理的有个遗留问题是：通常我们使用<code>UIPickerView</code>作为<code>UITextField</code>的<code>inputView</code>时， 并不希望去执行各种菜单操作(全选、复制、粘帖)，但只是去设置<code>UITextField</code>的<code>tintColor</code>时，我们仍然可以执行这边操作，所以需要加额外的处理。这个问题，我们可以这样处理：在<code>textFieldShouldBeginEditing:</code>中，我们把<code>UITextField</code>的<code>userInteractionEnabled</code>设置为<code>NO</code>，然后在<code>textFieldShouldEndEditing:</code>，将将这个值设置回来。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField &#123;</div><div class="line">    textField.userInteractionEnabled = NO;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)textFieldShouldEndEditing:(UITextField *)textField &#123;</div><div class="line">    textField.userInteractionEnabled = YES;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就<code>OK</code>了。当然这只是我们当前使用的一种处理方式，还有其它的方法，直接<code>google</code>或者<code>stackoverflow</code>吧。</p>
<h3 id="iOS-7后UIAlertView中文字左对齐问题"><a href="#iOS-7后UIAlertView中文字左对齐问题" class="headerlink" title="iOS 7后UIAlertView中文字左对齐问题"></a>iOS 7后UIAlertView中文字左对齐问题</h3><p>在<code>iOS 7</code>之前，如果我们想要让<code>UIAlertView</code>中的文字居左显示的话，可以使用以下这段代码来处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (UIView *view in alert.subviews) &#123;</div><div class="line">    if([[view class] isSubclassOfClass:[UILabel class]]) &#123;</div><div class="line">       ((UILabel*)view).textAlignment = NSTextAlignmentLeft;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但很遗憾的是，在<code>iOS 7</code>之后，苹果不让我们这么干了。我们去取<code>UIAlertView</code>的<code>subviews</code>时，获得的只是一个空数组，我们没有办法获取到我们想要的<code>label</code>。怎么办？三条路：告诉产品经理和UED说这个实现不了(当然，这个是会被鄙视的，人家会说你能力差)；自己写；找第三方开源代码。嘿嘿，不过由于最近时间紧，所以我决定跟他们说实现不了，哈哈。不过在<code>github</code>上找了一个开源的，<a href="https://github.com/wimagguc/ios-custom-alertview" target="_blank" rel="external">Custom iOS AlertView</a>，<code>star</code>的数量也不少，看来不错，回头好好研究研究。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/10/ios-techset-1/" itemprop="url">
                  iOS知识小集 第1期(2015.05.10)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-10T22:06:42+08:00" content="2015-05-10">
              2015-05-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/techset/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直想做这样一个小册子，来记录自己平时开发、阅读博客、看书、代码分析和与人交流中遇到的各种问题。之前有过这样的尝试，但都是无疾而终。不过，每天接触的东西多，有些东西不记下来，忘得也是很快，第二次遇到同样的问题时，还得再查一遍。好记性不如烂笔头，所以又决定重拾此事，时不时回头看看，温故而知新。</p>
<p>这里面的每个问题，不会太长。或是读书笔记，或是摘抄，亦或是验证，每个问题的篇幅争取在六七百字的样子。笔记和摘抄的出处会详细标明。问题的个数不限，凑齐<code>3000</code>字左右就发一篇。争取每月至少发两篇吧，权当是对自己学习的一个整理。</p>
<p>本期主要记录了以下几个问题：</p>
<ol>
<li><code>NSString</code>属性什么时候用<code>copy</code>，什么时候用<code>strong?</code></li>
<li><code>Foundation</code>中的断言处理</li>
<li><code>IBOutletCollection</code></li>
<li><code>NSRecursiveLock</code>递归锁的使用</li>
<li><code>NSHashTable</code></li>
</ol>
<h2 id="NSString属性什么时候用copy，什么时候用strong"><a href="#NSString属性什么时候用copy，什么时候用strong" class="headerlink" title="NSString属性什么时候用copy，什么时候用strong?"></a>NSString属性什么时候用copy，什么时候用strong?</h2><p>我们在声明一个<code>NSString</code>属性时，对于其内存相关特性，通常有两种选择(基于<code>ARC</code>环境)：<code>strong</code>与<code>copy</code>。那这两者有什么区别呢？什么时候该用<code>strong</code>，什么时候该用<code>copy</code>呢？让我们先来看个例子。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们定义一个类，并为其声明两个字符串属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface TestStringClass ()</div><div class="line">@property (nonatomic, strong) NSString *strongString;</div><div class="line">@property (nonatomic, copy) NSString *copyedString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的代码声明了两个字符串属性，其中一个内存特性是<code>strong</code>，一个是<code>copy</code>。下面我们来看看它们的区别。</p>
<p>首先，我们用一个不可变字符串来为这两个属性赋值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)test &#123;</div><div class="line">    NSString *string = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class="line">    self.strongString = string;</div><div class="line">    self.copyedString = string;</div><div class="line"></div><div class="line">    NSLog(@&quot;origin string: %p, %p&quot;, string, &amp;string);</div><div class="line">    NSLog(@&quot;strong string: %p, %p&quot;, strongString, &amp;strongString);</div><div class="line">    NSLog(@&quot;copy string: %p, %p&quot;, copyedString, &amp;copyedString);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">origin string: 0x7fe441592e20, 0x7fff57519a48</div><div class="line">strong string: 0x7fe441592e20, 0x7fe44159e1f8</div><div class="line">copy string: 0x7fe441592e20, 0x7fe44159e200</div></pre></td></tr></table></figure>
<p>我们要以看到，这种情况下，不管是<code>strong</code>还是<code>copy</code>属性的对象，其指向的地址都是同一个，即为<code>string</code>指向的地址。如果我们换作<code>MRC</code>环境，打印<code>string</code>的引用计数的话，会看到其引用计数值是<code>3</code>，即<code>strong</code>操作和<code>copy</code>操作都使原字符串对象的引用计数值加了<code>1</code>。</p>
<p>接下来，我们把<code>string</code>由不可变改为可变对象，看看会是什么结果。即将下面这一句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:@&quot;abc&quot;];</div></pre></td></tr></table></figure>
<p>改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div></pre></td></tr></table></figure>
<p>其输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">origin string: 0x7ff5f2e33c90, 0x7fff59937a48</div><div class="line">strong string: 0x7ff5f2e33c90, 0x7ff5f2e2aec8</div><div class="line">copy string: 0x7ff5f2e2aee0, 0x7ff5f2e2aed0</div></pre></td></tr></table></figure>
<p>可以发现，此时<code>copy</code>属性字符串已不再指向<code>string</code>字符串对象，而是深拷贝了<code>string</code>字符串，并让<code>_copyedString</code>对象指向这个字符串。在<code>MRC</code>环境下，打印两者的引用计数，可以看到<code>string</code>对象的引用计数是<code>2</code>，而<code>_copyedString</code>对象的引用计数是<code>1</code>。</p>
<p>此时，我们如果去修改string字符串的话，可以看到：因为_strongString与string是指向同一对象，所以<code>_strongString</code>的值也会跟随着改变(需要注意的是，此时<code>_strongString</code>的类型实际上是<code>NSMutableString</code>，而不是<code>NSString</code>)；而<code>_copyedString</code>是指向另一个对象的，所以并不会改变。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>由于<code>NSMutableString</code>是<code>NSString</code>的子类，所以一个<code>NSString</code>指针可以指向<code>NSMutableString</code>对象，让我们的<code>strongString</code>指针指向一个可变字符串是OK的。</p>
<p>而上面的例子可以看出，当源字符串是<code>NSString</code>时，由于字符串是不可变的，所以，不管是<code>strong</code>还是<code>copy</code>属性的对象，都是指向源对象，<code>copy</code>操作只是做了次<strong>浅拷贝</strong>。</p>
<p>当源字符串是<code>NSMutableString</code>时，<code>strong</code>属性只是增加了源字符串的引用计数，而<code>copy</code>属性则是对源字符串做了次<strong>深拷贝</strong>，产生一个新的对象，且<code>copy</code>属性对象指向这个新的对象。另外需要注意的是，这个<code>copy</code>属性对象的类型始终是<code>NSString</code>，而不是<code>NSMutableString</code>，因此其是不可变的。</p>
<p>这里还有一个性能问题，即在源字符串是<code>NSMutableString</code>，<code>strong</code>是单纯的增加对象的引用计数，而<code>copy</code>操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是<code>NSString</code>时，则没有这个问题。</p>
<p>所以，在声明<code>NSString</code>属性时，到底是选择<code>strong</code>还是<code>copy</code>，可以根据实际情况来定。不过，一般我们将对象声明为<code>NSString</code>时，都不希望它改变，所以大多数情况下，我们建议用<code>copy</code>，以免因可变字符串的修改导致的一些非预期问题。</p>
<p>关于字符串的内存管理，还有些有意思的东西，可以参考<a href="http://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/" target="_blank" rel="external">NSString特性分析学习</a>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://stackoverflow.com/questions/2521468/nsstring-copy-not-copying" target="_blank" rel="external">NSString copy not copying?</a></li>
<li><a href="http://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/" target="_blank" rel="external">NSString特性分析学习</a></li>
<li><a href="http://blog.csdn.net/itianyi/article/details/9018567" target="_blank" rel="external">NSString什么时候用copy，什么时候用strong</a></li>
</ol>
<h2 id="Foundation中的断言处理"><a href="#Foundation中的断言处理" class="headerlink" title="Foundation中的断言处理"></a>Foundation中的断言处理</h2><p>经常在看一些第三方库的代码时，或者自己在写一些基础类时，都会用到断言。所以在此总结一下<code>Objective-C</code>中关于断言的一些问题。</p>
<p><code>Foundation</code>中定义了两组断言相关的宏，分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSAssert / NSCAssert</div><div class="line">NSParameterAssert / NSCParameterAssert</div></pre></td></tr></table></figure>
<p>这两组宏主要在功能和语义上有所差别，这些区别主要有以下两点：</p>
<ol>
<li>如果我们需要确保方法或函数的输入参数的正确性，则应该在方法(函数)的顶部使用<code>NSParameterAssert / NSCParameterAssert</code>；而在其它情况下，使用<code>NSAssert / NSCAssert</code>。</li>
<li>另一个不同是介于<code>C</code>和<code>Objective-C</code>之间。<code>NSAssert / NSParameterAssert</code>应该用于<code>Objective-C</code>的上下文(方法)中，而<code>NSCAssert / NSCParameterAssert</code>应该用于<code>C</code>的上下文(函数)中。</li>
</ol>
<p>当断言失败时，通常是会抛出一个如下所示的异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;true is not equal to false&apos;</div></pre></td></tr></table></figure>
<p><code>Foundation</code>为了处理断言，专门定义了一个<code>NSAssertionHandler</code>来处理断言的失败情况。<code>NSAssertionHandler</code>对象是自动创建的，用于处理失败的断言。当断言失败时，会传递一个字符串给<code>NSAssertionHandler</code>对象来描述失败的原因。<strong>每个线程都有自己的NSAssertionHandler对象</strong>。当调用时，一个断言处理器会打印包含方法和类(或函数)的错误消息，并引发一个<code>NSInternalInconsistencyException</code>异常。就像上面所看到的一样。</p>
<p>我们很少直接去调用<code>NSAssertionHandler</code>的断言处理方法，通常都是自动调用的。</p>
<p><code>NSAssertionHandler</code>提供的方法并不多，就三个，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 返回与当前线程的NSAssertionHandler对象。</div><div class="line">// 如果当前线程没有相关的断言处理器，则该方法会创建一个并指定给当前线程</div><div class="line">+ (NSAssertionHandler *)currentHandler</div><div class="line"></div><div class="line">// 当NSCAssert或NSCParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)object lineNumber:(NSInteger)fileName description:(NSString *)line, format,...</div><div class="line"></div><div class="line">// 当NSAssert或NSParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format, ...</div></pre></td></tr></table></figure>
<p>另外，还定义了一个常量字符串，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString * const NSAssertionHandlerKey;</div></pre></td></tr></table></figure>
<p>主要是用于在线程的<code>threadDictionary</code>字典中获取或设置断言处理器。</p>
<p>关于断言，还需要注意的一点是在<code>Xcode 4.2</code>以后，在<code>release</code>版本中断言是默认关闭的，这是由宏<code>NS_BLOCK_ASSERTIONS</code>来处理的。也就是说，当编译<code>release</code>版本时，所有的断言调用都是无效的。</p>
<p>我们可以自定义一个继承自<code>NSAssertionHandler</code>的断言处理类，来实现一些我们自己的需求。如<code>Mattt Thompson</code>的<a href="http://nshipster.com/nsassertionhandler/" target="_blank" rel="external">NSAssertionHandler</a>实例一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@interface LoggingAssertionHandler : NSAssertionHandler</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation LoggingAssertionHandler</div><div class="line"></div><div class="line">- (void)handleFailureInMethod:(SEL)selector</div><div class="line">                       object:(id)object</div><div class="line">                         file:(NSString *)fileName</div><div class="line">                   lineNumber:(NSInteger)line</div><div class="line">                  description:(NSString *)format, ...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSAssert Failure: Method %@ for object %@ in %@#%i&quot;, NSStringFromSelector(selector), object, fileName, line);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName</div><div class="line">                           file:(NSString *)fileName</div><div class="line">                     lineNumber:(NSInteger)line</div><div class="line">                    description:(NSString *)format, ...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSCAssert Failure: Function (%@) in %@#%i&quot;, functionName, fileName, line);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面说过，每个线程都有自己的断言处理器。我们可以通过为线程的<code>threadDictionary</code>字典中的<code>NSAssertionHandlerKey</code>指定一个新值，来改变线程的断言处理器。</p>
<p>如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application</div><div class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">  NSAssertionHandler *assertionHandler = [[LoggingAssertionHandler alloc] init];</div><div class="line">  [[[NSThread currentThread] threadDictionary] setValue:assertionHandler</div><div class="line">                                                 forKey:NSAssertionHandlerKey];</div><div class="line">  // ...</div><div class="line">  return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而什么时候应该使用断言呢？通常我们期望程序按照我们的预期去运行时，如调用的参数为空时流程就无法继续下去时，可以使用断言。但另一方面，我们也需要考虑，在这加断言确实是需要的么？我们是否可以通过更多的容错处理来使程序正常运行呢？</p>
<p><code>Matt Thompson</code>在<a href="http://nshipster.com/nsassertionhandler/" target="_blank" rel="external">NSAssertionHandler</a>中的倒数第二段说得挺有意思，在此摘抄一下：</p>
<blockquote>
<p>But if we look deeper into NSAssertionHandler—and indeed, into our own hearts, there are lessons to be learned about our capacity for kindness and compassion; about our ability to forgive others, and to recover from our own missteps. We can’t be right all of the time. We all make mistakes. By accepting limitations in ourselves and others, only then are we able to grow as individuals.</p>
</blockquote>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/nsassertionhandler/" target="_blank" rel="external">NSAssertion​Handler</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAssertionHandler_Class/" target="_blank" rel="external">NSAssertionHandler Class Reference</a></li>
</ol>
<h2 id="IBOutletCollection"><a href="#IBOutletCollection" class="headerlink" title="IBOutletCollection"></a>IBOutletCollection</h2><p>在<code>IB</code>与相关文件做连接时，我们经常会用到两个关键字：<code>IBOutlet</code>和<code>IBAction</code>。经常用<code>xib</code>或<code>storyboard</code>的童鞋应该用这两上关键字非常熟悉了。不过<code>UIKit</code>还提供了另一个伪关键字<strong>IBOutletCollection</strong>，我们使用这个关键字，可以将界面上一组相同的控件连接到同一个数组中。</p>
<p>我们先来看看这个伪关键字的定义，可以从<code>UIKit.framework</code>的头文件<code>UINibDeclarations.h</code>找到如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#ifndef IBOutletCollection</div><div class="line">#define IBOutletCollection(ClassName)</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>另外，在<code>Clang</code>源码中，有更安全的定义方式，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define IBOutletCollection(ClassName) attribute((iboutletcollection(ClassName)))</div></pre></td></tr></table></figure>
<p>从上面的定义可以看到，与<code>IBOutlet</code>不同的是，<code>IBOutletCollection</code>带有一个参数，该参数是一个类名。</p>
<p>通常情况下，我们使用一个<code>IBOutletCollection</code>属性时，属性必须是<code>strong</code>的，且类型是<code>NSArray</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong, nonatomic) IBOutletCollection(UIScrollView) NSArray *scrollViews;</div></pre></td></tr></table></figure>
<p>假定我们的<code>xib</code>文件中有三个横向的<code>scrollView</code>，我们便可以将这三个<code>scrollView</code>都连接至<code>scrollViews</code>属性，然后在我们的代码中便可以做一些统一处理，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)setupScrollViewImages</div><div class="line">&#123;</div><div class="line">    for (UIScrollView *scrollView in self.scrollViews) &#123;</div><div class="line">        [self.imagesData enumerateObjectsUsingBlock:^(NSString *imageName, NSUInteger idx, BOOL *stop) &#123;</div><div class="line"></div><div class="line">            UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(CGRectGetWidth(scrollView.frame) * idx, 0, CGRectGetWidth(scrollView.frame), CGRectGetHeight(scrollView.frame))];</div><div class="line">            imageView.contentMode = UIViewContentModeScaleAspectFill;</div><div class="line">            imageView.image = [UIImage imageNamed:imageName];</div><div class="line">            [scrollView addSubview:imageView];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码会影响到三个<code>scrollView</code>。这样做的好处是我们不需要手动通过<code>addObject:</code>方法将<code>scrollView</code>添加到<code>scrollViews</code>中。</p>
<p>不过在使用<code>IBOutletCollection</code>时，需要注意两点：</p>
<ol>
<li><code>IBOutletCollection</code>集合中对象的顺序是不确定的。我们通过调试方法可以看到集合中对象的顺序跟我们连接的顺序是一样的。但是这个顺序可能会因为不同版本的<code>Xcode</code>而有所不同。所以我们不应该试图在代码中去假定这种顺序。</li>
<li>不管<code>IBOutletCollection(ClassName)</code>中的控件是什么，属性的类型始终是<code>NSArray</code>。实际上，我们可以声明是任何类型，如<code>NSSet</code>，<code>NSMutableArray</code>，甚至可以是<code>UIColor</code>，但不管我们在此设置的是什么类，<code>IBOutletCollection</code>属性总是指向一个<code>NSArray</code>数组。</li>
</ol>
<p>关于第二点，我们以上面的<code>scrollViews</code>为例，作如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong, nonatomic) IBOutletCollection(UIScrollView) NSSet *scrollViews;</div></pre></td></tr></table></figure>
<p>实际上我们在控制台打印这个<code>scrollViews</code>时，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) po self.scrollViews</div><div class="line">&lt;__NSArrayI 0x1740573d0&gt;(</div><div class="line">&lt;UIScrollView: 0x12d60d770; frame = (0 0; 320 162); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x1740574f0&gt;; layer = &lt;CALayer: 0x174229480&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;,</div><div class="line">&lt;UIScrollView: 0x12d60dee0; frame = (0 0; 320 161); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x174057790&gt;; layer = &lt;CALayer: 0x1742297c0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;,</div><div class="line">&lt;UIScrollView: 0x12d60e650; frame = (0 0; 320 163); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x1740579a0&gt;; layer = &lt;CALayer: 0x1742298e0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>可以看到，它指向的是一个<code>NSArray</code>数组。</p>
<p>另外，<code>IBOutletCollection</code>实际上在<code>iOS 4</code>版本中就有了。不过，现在的<code>Objective-C</code>已经支持<code>object literals</code>了，所以定义数组可以直接用<code>@[]</code>，方便了许多。而且<code>object literals</code>方式可以添加不在<code>xib</code>中的用代码定义的视图，所以显得更加灵活。当然，两种方式选择哪一种，就看我们自己的实际需要和喜好了。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://nshipster.com/ibaction-iboutlet-iboutletcollection/" target="_blank" rel="external">IBAction / IBOutlet / IBOutlet​Collection</a></li>
<li><a href="http://www.opensource.apple.com/source/clang/clang-318.0.45/src/tools/clang/test/Index/IBOutletCollection.m" target="_blank" rel="external">IBOutletCollection.m</a></li>
</ol>
<h2 id="NSRecursiveLock递归锁的使用"><a href="#NSRecursiveLock递归锁的使用" class="headerlink" title="NSRecursiveLock递归锁的使用"></a>NSRecursiveLock递归锁的使用</h2><p><code>NSRecursiveLock</code>实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。我们先来看一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSLock *lock = [[NSLock alloc] init];</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    static void (^RecursiveMethod)(int);</div><div class="line"></div><div class="line">    RecursiveMethod = ^(int value) &#123;</div><div class="line"></div><div class="line">        [lock lock];</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line"></div><div class="line">            NSLog(@&quot;value = %d&quot;, value);</div><div class="line">            sleep(2);</div><div class="line">            RecursiveMethod(value - 1);</div><div class="line">        &#125;</div><div class="line">        [lock unlock];</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    RecursiveMethod(5);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段代码是一个典型的死锁情况。在我们的线程中，<code>RecursiveMethod</code>是递归调用的。所以每次进入这个<code>block</code>时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">value = 5</div><div class="line">* -[NSLock lock]: deadlock (&lt;NSLock: 0x1700ceee0&gt; &apos;(null)&apos;)	* Break on _NSLockError() to debug.</div></pre></td></tr></table></figure>
<p>在这种情况下，我们就可以使用<code>NSRecursiveLock</code>。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被<code>lock</code>的次数。每次成功的<code>lock</code>都必须平衡调用<code>unlock</code>操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>
<p>所以，对上面的代码进行一下改造，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</div></pre></td></tr></table></figure>
<p>这样，程序就能正常运行了，其输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">value = 5</div><div class="line">value = 4</div><div class="line">value = 3</div><div class="line">value = 2</div><div class="line">value = 1</div></pre></td></tr></table></figure>
<p><code>NSRecursiveLock</code>除了实现<code>NSLocking</code>协议的方法外，还提供了两个方法，分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 在给定的时间之前去尝试请求一个锁</div><div class="line">- (BOOL)lockBeforeDate:(NSDate *)limit</div><div class="line"></div><div class="line">// 尝试去请求一个锁，并会立即返回一个布尔值，表示尝试是否成功</div><div class="line">- (BOOL)tryLock</div></pre></td></tr></table></figure>
<p>这两个方法都可以用于在多线程的情况下，去尝试请求一个递归锁，然后根据返回的布尔值，来做相应的处理。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    static void (^RecursiveMethod)(int);</div><div class="line"></div><div class="line">    RecursiveMethod = ^(int value) &#123;</div><div class="line"></div><div class="line">        [lock lock];</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line"></div><div class="line">            NSLog(@&quot;value = %d&quot;, value);</div><div class="line">            sleep(2);</div><div class="line">            RecursiveMethod(value - 1);</div><div class="line">        &#125;</div><div class="line">        [lock unlock];</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    RecursiveMethod(5);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    sleep(2);</div><div class="line">    BOOL flag = [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:1]];</div><div class="line">    if (flag) &#123;</div><div class="line">        NSLog(@&quot;lock before date&quot;);</div><div class="line"></div><div class="line">        [lock unlock];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;fail to lock before date&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在前面的代码中，我们又添加了一段代码，增加一个线程来获取递归锁。我们在第二个线程中尝试去获取递归锁，当然这种情况下是会失败的，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">value = 5</div><div class="line">value = 4</div><div class="line">fail to lock before date</div><div class="line">value = 3</div><div class="line">value = 2</div><div class="line">value = 1</div></pre></td></tr></table></figure>
<p>另外，<code>NSRecursiveLock</code>还声明了一个<code>name</code>属性，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(copy) NSString *name</div></pre></td></tr></table></figure>
<p>我们可以使用这个字符串来标识一个锁。<code>Cocoa</code>也会使用这个<code>name</code>作为错误描述信息的一部分。</p>
<h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRecursiveLock_Class/" target="_blank" rel="external">NSRecursiveLock Class Reference</a></li>
<li><a href="http://www.tanhao.me/pieces/643.html/" target="_blank" rel="external">Objective-C中不同方式实现锁(二)</a></li>
</ol>
<h2 id="NSHashTable"><a href="#NSHashTable" class="headerlink" title="NSHashTable"></a>NSHashTable</h2><p>在看<code>KVOController</code>的代码时，又看到了<code>NSHashTable</code>这个类，所以就此整理一下。</p>
<p><code>NSHashTable</code>效仿了<code>NSSet(NSMutableSet)</code>，但提供了比<code>NSSet</code>更多的操作选项，尤其是在对弱引用关系的支持上，<code>NSHashTable</code>在对象/内存处理时更加的灵活。相较于<code>NSSet</code>，<code>NSHashTable</code>具有以下特性：</p>
<ol>
<li><code>NSSet(NSMutableSet)</code>持有其元素的强引用，同时这些元素是使用<code>hash</code>值及<code>isEqual:</code>方法来做<code>hash</code>检测及判断是否相等的。</li>
<li><code>NSHashTable</code>是可变的，它没有不可变版本。</li>
<li>它可以持有元素的弱引用，而且在对象被销毁后能正确地将其移除。而这一点在<code>NSSet</code>是做不到的。</li>
<li>它的成员可以在添加时被拷贝。</li>
<li>它的成员可以使用指针来标识是否相等及做<code>hash</code>检测。</li>
<li>它可以包含任意指针，其成员没有限制为对象。我们可以配置一个<code>NSHashTable</code>实例来操作任意的指针，而不仅仅是对象。</li>
</ol>
<p>初始化<code>NSHashTable</code>时，我们可以设置一个初始选项，这个选项确定了这个<code>NSHashTable</code>对象后面所有的行为。这个选项是由<code>NSHashTableOptions</code>枚举来定义的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">    // 默认行为，强引用集合中的对象，等同于NSSet</div><div class="line">    NSHashTableStrongMemory             = 0,</div><div class="line">    </div><div class="line">    // 在将对象添加到集合之前，会拷贝对象</div><div class="line">    NSHashTableCopyIn                   = NSPointerFunctionsCopyIn,</div><div class="line"></div><div class="line">    // 使用移位指针(shifted pointer)来做hash检测及确定两个对象是否相等；</div><div class="line">    // 同时使用description方法来做描述字符串</div><div class="line">    NSHashTableObjectPointerPersonality = NSPointerFunctionsObjectPointerPersonality,</div><div class="line"></div><div class="line">    // 弱引用集合中的对象，且在对象被释放后，会被正确的移除。</div><div class="line">    NSHashTableWeakMemory               = NSPointerFunctionsWeakMemory </div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef NSUInteger NSHashTableOptions;</div></pre></td></tr></table></figure>
<p>当然，我们还可以使用<code>NSPointerFunctions</code>来初始化，但只有使用<code>NSHashTableOptions</code>定义的这些值，才能确保<code>NSHashTable</code>的各个<code>API</code>可以正确的工作–包括拷贝、归档及快速枚举。</p>
<p>个人认为<code>NSHashTable</code>吸引人的地方在于可以持有元素的弱引用，而且在对象被销毁后能正确地将其移除。我们来写个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 具体调用如下</div><div class="line">@implementation TestHashAndMapTableClass &#123;</div><div class="line">    NSMutableDictionary *_dic;</div><div class="line">    NSSet               *_set;</div><div class="line">    NSHashTable         *_hashTable;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    self = [super init];</div><div class="line"></div><div class="line">    if (self) &#123;</div><div class="line">        [self testWeakMemory];</div><div class="line">        NSLog(@&quot;hash table [init]: %@&quot;, _hashTable);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testWeakMemory &#123;</div><div class="line">    if (!_hashTable) &#123;</div><div class="line">        _hashTable = [NSHashTable weakObjectsHashTable];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSObject *obj = [[NSObject alloc] init];</div><div class="line">    [_hashTable addObject:obj];</div><div class="line">    NSLog(@&quot;hash table [testWeakMemory] : %@&quot;, _hashTable);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hash table [testWeakMemory] : NSHashTable &#123;</div><div class="line">[6] &lt;NSObject: 0x7fa2b1562670&gt;</div><div class="line">&#125;</div><div class="line">hash table [init]: NSHashTable &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在离开<code>testWeakMemory</code>方法，<code>obj</code>对象被释放，同时对象在集合中的引用也被安全的删除。</p>
<p>这样看来，<code>NSHashTable</code>似乎比<code>NSSet(NSMutableSet)</code>要好啊。那是不是我们就应用都使用<code>NSHashTable</code>呢？<code>Peter Steinberger</code>在<a href="http://www.objc.io/issue-7/collections.html" target="_blank" rel="external">The Foundation Collection Classes</a>给了我们一组数据，显示在添加对象的操作中，<code>NSHashTable</code>所有的时间差不多是<code>NSMutableSet</code>的<code>2</code>倍，而在其它操作中，性能大体相近。所以，如果我们只需要<code>NSSet</code>的特性，就尽量用<code>NSSet</code>。</p>
<p>另外，<code>Mattt Thompson</code>在<a href="http://nshipster.com/nshashtable-and-nsmaptable/" target="_blank" rel="external">NSHashTable &amp; NSMapTable</a>的结尾也写了段挺有意思的话，在此直接摘抄过来：</p>
<blockquote>
<p>As always, it’s important to remember that programming is not about being clever: always approach a problem from the highest viable level of abstraction. NSSet and NSDictionary are great classes. For 99% of problems, they are undoubtedly the correct tool for the job. If, however, your problem has any of the particular memory management constraints described above, then NSHashTable &amp; NSMapTable may be worth a look.</p>
</blockquote>
<h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSHashTable_class/" target="_blank" rel="external">NSHashTable Class Reference</a></li>
<li><a href="http://nshipster.com/nshashtable-and-nsmaptable/" target="_blank" rel="external">NSHash​Table &amp; NSMap​Table</a></li>
<li><a href="http://billwang1990.github.io/blog/2014/03/31/nshashtable-and-nsmaptable/" target="_blank" rel="external">NSHashTable &amp; NSMapTable</a></li>
<li><a href="http://www.objc.io/issue-7/collections.html" target="_blank" rel="external">The Foundation Collection Classes</a></li>
</ol>
<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><h3 id="一-“Unknown-class-XXViewController-in-Interface-Builder-file-””-问题处理"><a href="#一-“Unknown-class-XXViewController-in-Interface-Builder-file-””-问题处理" class="headerlink" title="(一) “Unknown class XXViewController in Interface Builder file.”” 问题处理"></a>(一) “Unknown class XXViewController in Interface Builder file.”” 问题处理</h3><p>最近在静态库中写了一个<code>XXViewController</code>类，然后在主工程的<code>xib</code>中，将<code>xib</code>的类指定为<code>XXViewController</code>，程序运行时，报了如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unknown class XXViewController in Interface Builder file.</div></pre></td></tr></table></figure>
<p>之前也遇到这个问题，但已记得不太清楚，所以又开始在<code>stackoverflow</code>上找答案。</p>
<p>其实这个问题与<code>Interface Builder</code>无关，最直接的原因还是相关的<code>symbol</code>没有从静态库中加载进来。这种问题的处理就是在<code>Target</code>的<code>&quot;Build Setting&quot;</code>-&gt;<code>&quot;Other Link Flags&quot;</code>中加上<code>&quot;-all_load -ObjC&quot;</code>这两个标识位，这样就OK了。</p>
<h3 id="二-关于Unbalanced-calls-to-begin-end-appearance-transitions-for-…问题的处理"><a href="#二-关于Unbalanced-calls-to-begin-end-appearance-transitions-for-…问题的处理" class="headerlink" title="(二)关于Unbalanced calls to begin/end appearance transitions for …问题的处理"></a>(二)关于Unbalanced calls to begin/end appearance transitions for …问题的处理</h3><p>我们的某个业务有这么一个需求，进入一个列表后需要立马又<code>push</code>一个<code>web</code>页面，做一些活动的推广。在<code>iOS 8</code>上，我们的实现是一切OK的；但到了<code>iOS 7</code>上，就发现这个<code>web</code>页面<code>push</code>不出来了，同时控制台给了一条警告消息，即如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unbalanced calls to begin/end appearance transitions for ...</div></pre></td></tr></table></figure>
<p>在这种情况下，点击导航栏中的返回按钮时，直接显示一个黑屏。</p>
<p>我们到<code>stackoverflow</code>上查了一下，有这么一段提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">occurs when you try and display a new viewcontroller before the current view controller is finished displaying.</div></pre></td></tr></table></figure>
<p>意思是说在当前视图控制器完成显示之前，又试图去显示一个新的视图控制器。</p>
<p>于是我们去排查代码，果然发现，在<code>viewDidLoad</code>里面去做了次网络请求操作，且请求返回后就去<code>push</code>这个<code>web</code>活动推广页。此时，当前的视图控制器可能并未显示完成(即未完成<code>push</code>操作)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Basically you are trying to push two view controllers onto the stack at almost the same time.</div></pre></td></tr></table></figure>
<p>当几乎同时将两个视图控制器<code>push</code>到当前的导航控制器栈中时，或者同时<code>pop</code>两个不同的视图控制器，就会出现不确定的结果。所以我们应该确保同一时间，对同一个导航控制器栈只有一个操作，即便当前的视图控制器正在动画过程中，也不应该再去<code>push</code>或<code>pop</code>一个新的视图控制器。</p>
<p>所以最后我们把<code>web</code>活动的数据请求放到了<code>viewDidAppear</code>里面，并做了些处理，这样问题就解决了。</p>
<h4 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://stackoverflow.com/questions/9088465/unbalanced-calls-to-begin-end-appearance-transitions-for-detailviewcontroller" target="_blank" rel="external">“Unbalanced calls to begin/end appearance transitions for DetailViewController” when pushing more than one detail view controller</a></li>
<li><a href="http://stackoverflow.com/questions/8563473/unbalanced-calls-to-begin-end-appearance-transitions-for-uitabbarcontroller" target="_blank" rel="external">Unbalanced calls to begin/end appearance transitions for UITabBarController</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="南峰子" />
          <p class="site-author-name" itemprop="name">南峰子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">85</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南峰子</span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
  </script>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  

  <div style="display: none;">
    <script src="http://s95.cnzz.com/z_stat.php?id=1000523916&web_id=1000523916" language="JavaScript"></script>
  </div>




</body>
</html>
