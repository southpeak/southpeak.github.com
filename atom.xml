<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[南峰子的技术博客]]></title>
  <link href="http://southpeak.github.io/atom.xml" rel="self"/>
  <link href="http://southpeak.github.io/"/>
  <updated>2015-05-31T23:52:04+08:00</updated>
  <id>http://southpeak.github.io/</id>
  <author>
    <name><![CDATA[南峰子]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集 第二期(2015.05.31)]]></title>
    <link href="http://southpeak.github.io/blog/2015/05/31/ioszhi-shi-xiao-ji-di-er-qi-2015-dot-05-dot-31/"/>
    <updated>2015-05-31T23:50:54+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/05/31/ioszhi-shi-xiao-ji-di-er-qi-2015-dot-05-dot-31</id>
    <content type="html"><![CDATA[<p>换了个厂子，还不到1个月。哎，着实是累啊，基本上是996.5的节奏，只会更多。加班把我快加吐了，但人在江湖，身不由已啊。为了讨口饭吃，命也不要了。谁让咱只是个臭写代码的呢。不过加班是多，只是长得太丑，所有没办法，没时间也得抽时间来学习。不然，饭都没得吃了，还得养家糊口呢。</p>

<p>本期总结的内容不是很多，主要有以下几个问题：</p>

<ol>
<li>使用UIVisualEffectView为视图添加特殊效果</li>
<li>Nullability Annotations</li>
<li>weak的生命周期</li>
</ol>


<h2>使用UIVisualEffectView为视图添加特殊效果</h2>

<p>在iOS 8后，苹果开放了不少创建特效的接口，其中就包括创建毛玻璃(blur)的接口。</p>

<p>通常要想创建一个特殊效果(如blur效果)，可以创建一个UIVisualEffectView视图对象，这个对象提供了一种简单的方式来实现复杂的视觉效果。这个可以把这个对象看作是效果的一个容器，实际的效果会影响到该视图对象底下的内容，或者是添加到该视图对象的contentView中的内容。</p>

<p>我们举个例子来看看如果使用UIVisualEffectView：</p>

<pre><code>let bgView: UIImageView = UIImageView(image: UIImage(named: "visual"))
bgView.frame = self.view.bounds
self.view.addSubview(bgView)

let blurEffect: UIBlurEffect = UIBlurEffect(style: .Light)
let blurView: UIVisualEffectView = UIVisualEffectView(effect: blurEffect)
blurView.frame = CGRectMake(50.0, 50.0, self.view.frame.width - 100.0, 200.0)
self.view.addSubview(blurView)
</code></pre>

<p>这段代码是在当前视图控制器上添加了一个UIImageView作为背景图。然后在视图的一小部分中使用了blur效果。其效果如下所示：</p>

<p><img src="http://d.pcs.baidu.com/thumbnail/09b0f2cc826eda249faa3c323a0ace53?fid=742964286-250528-1028873691191491&amp;time=1433084400&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-c2ezBV5xH9W7KlZF3li%2B12fJtgc%3D&amp;rt=sh&amp;expires=2h&amp;r=567337996&amp;sharesign=unknown&amp;size=c710_u500&amp;quality=100" alt="image" /></p>

<p>我们可以看到UIVisualEffectView还是非常简单的。需要注意是的，不应该直接添加子视图到UIVisualEffectView视图中，而是应该添加到UIVisualEffectView对象的contentView中。</p>

<p>另外，尽量避免将UIVisualEffectView对象的alpha值设置为小于1.0的值，因为创建半透明的视图会导致系统在离屏渲染时去对UIVisualEffectView对象及所有的相关的子视图做混合操作。这不但消耗CPU/GPU，也可能会导致许多效果显示不正确或者根本不显示。</p>

<p>我们在上面看到，初始化一个UIVisualEffectView对象的方法是UIVisualEffectView(effect: blurEffect)，其定义如下：</p>

<pre><code>init(effect effect: UIVisualEffect)
</code></pre>

<p>这个方法的参数是一个UIVisualEffect对象。我们查看官方文档，可以看到在UIKit中，定义了几个专门用来创建视觉特效的，它们分别是UIVisualEffect、UIBlurEffect和UIVibrancyEffect。它们的继承层次如下所示：</p>

<pre><code>NSObject
| -- UIVisualEffect
    | -- UIBlurEffect
    | -- UIVibrancyEffect
</code></pre>

<p>UIVisualEffect是一个继承自NSObject的创建视觉效果的基类，然而这个类除了继承自NSObject的属性和方法外，没有提供任何新的属性和方法。其主要目的是用于初始化UIVisualEffectView，在这个初始化方法中可以传入UIBlurEffect或者UIVibrancyEffect对象。</p>

<p>一个UIBlurEffect对象用于将blur(毛玻璃)效果应用于UIVisualEffectView视图下面的内容。如上面的示例所示。不过，这个对象的效果并不影响UIVisualEffectView对象的contentView中的内容。</p>

<p>UIBlurEffect主要定义了三种效果，这些效果由枚举UIBlurEffectStyle来确定，该枚举的定义如下：</p>

<pre><code>enum UIBlurEffectStyle : Int {
    case ExtraLight
    case Light
    case Dark
}
</code></pre>

<p>其主要是根据色调(hue)来确定特效视图与底部视图的混合。</p>

<p>与UIBlurEffect不同的是，UIVibrancyEffect主要用于放大和调整UIVisualEffectView视图下面的内容的颜色，同时让UIVisualEffectView的contentView中的内容看起来更加生动。通常UIVibrancyEffect对象是与UIBlurEffect一起使用，主要用于处理在UIBlurEffect特效上的一些显示效果。接上面的代码，我们看看在blur的视图上添加一些新的特效，如下代码所示：</p>

<pre><code>let vibrancyView: UIVisualEffectView = UIVisualEffectView(effect: UIVibrancyEffect(forBlurEffect: blurEffect))
vibrancyView.setTranslatesAutoresizingMaskIntoConstraints(false)
blurView.contentView.addSubview(vibrancyView)

var label: UILabel = UILabel()
label.setTranslatesAutoresizingMaskIntoConstraints(false)
label.text = "Vibrancy Effect"
label.font = UIFont(name: "HelveticaNeue-Bold", size: 30)
label.textAlignment = .Center
label.textColor = UIColor.whiteColor()
vibrancyView.contentView.addSubview(label)
</code></pre>

<p>其效果如下图所示：</p>

<p><img src="http://d.pcs.baidu.com/thumbnail/a4b788b4c24154d2b5919f714c945d18?fid=742964286-250528-985603568872796&amp;time=1433084400&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-bm2CevqtZpV0v9tRi%2F%2BuovzF78w%3D&amp;rt=sh&amp;expires=2h&amp;r=516566080&amp;sharesign=unknown&amp;size=c710_u500&amp;quality=100" alt="image" /></p>

<p>vibrancy特效是取决于颜色值的。所有添加到contentView的子视图都必须实现tintColorDidChange方法并更新自己。需要注意的是，我们使用UIVibrancyEffect(forBlurEffect:)方法创建UIVibrancyEffect时，参数blurEffect必须是我们想加效果的那个blurEffect，否则可能不是我们想要的效果。</p>

<p>另外，UIVibrancyEffect还提供了一个类方法notificationCenterVibrancyEffect，其声明如下：</p>

<pre><code>class func notificationCenterVibrancyEffect() -&gt; UIVibrancyEffect!
</code></pre>

<p>这个方法创建一个用于通知中心的Today扩展的vibrancy特效。</p>

<h3>参考</h3>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVisualEffectView/">UIVisualEffectView Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVisualEffect_class/index.html#//apple_ref/occ/cl/UIVisualEffect">UIVisualEffect Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVisualEffect_class/index.html#//apple_ref/occ/cl/UIVisualEffect">UIBlurEffect Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIVibrancyEffect/">UIVibrancyEffect Class Reference</a></li>
<li><a href="http://swiftoverload.com/tag/uivisualeffectview/">UIVisualEffect – Swift Tutorial</a></li>
<li><a href="http://idrawcode.tumblr.com/post/101925733632/ios-8-uivisualeffect">iOS 8: UIVisualEffect</a></li>
</ol>


<h2>Pointer is missing a nullability type specifier (<strong>nonnull or </strong>nullable)问题的处理 &mdash; Nullability Annotations</h2>

<p>最近在用Xcode 6.3写代码，一些涉及到对象的代码会报如下编译器警告：</p>

<pre><code>Pointer is missing a nullability type specifier (__nonnull or __nullable)
</code></pre>

<p>于是google了一下，发现这是Xcode 6.3的一个新特性，即<strong>nullability annotations</strong>。</p>

<h3>Nullability Annotations</h3>

<p>我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在Objective-C中则没有这一区分，view即可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。</p>

<p>为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：nullability annotations。这一新特性的核心是两个新的类型注释：<strong>__nullable</strong>和<strong>__nonnull</strong>。从字面上我们可以猜到，<strong>__nullable</strong>表示对象可以是NULL或nil，而<strong>__nonnull</strong>表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。</p>

<p>我们来看看以下的实例，</p>

<pre><code>@interface TestNullabilityClass ()

@property (nonatomic, copy) NSArray * items;

- (id)itemWithName:(NSString * __nonnull)name;

@end

@implementation TestNullabilityClass

...

- (void)testNullability {

    [self itemWithName:nil];    // 编译器警告：Null passed to a callee that requires a non-null argument
}

- (id)itemWithName:(NSString * __nonnull)name {
    return nil;
}

@end
</code></pre>

<p>不过这只是一个警告，程序还是能编译通过并运行。</p>

<p>事实上，在任何可以使用const关键字的地方都可以使用__nullable和__nonnull，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的nullable和nonnull，如下所示：</p>

<pre><code>- (nullable id)itemWithName:(NSString * nonnull)name
</code></pre>

<p>在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明：</p>

<pre><code>@property (nonatomic, copy, nonnull) NSArray * items;
</code></pre>

<p>当然也可以用以下这种方式：</p>

<pre><code>@property (nonatomic, copy) NSArray * __nonnull items;
</code></pre>

<p>推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。</p>

<h3>Nonnull区域设置(Audited Regions)</h3>

<p>如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。在这两个宏之间的代码，所有简单指针对象都被假定为nonnull，因此我们只需要去指定那些nullable的指针。如下代码所示：</p>

<pre><code>NS_ASSUME_NONNULL_BEGIN

@interface TestNullabilityClass ()

@property (nonatomic, copy) NSArray * items;


- (id)itemWithName:(nullable NSString *)name;

@end

NS_ASSUME_NONNULL_END
</code></pre>

<p>在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。</p>

<p>不过，为了安全起见，苹果还制定了几条规则：</p>

<ol>
<li>typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。</li>
<li>复杂的指针类型(如id *)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用&#8221;__nullable id * __nonnull&#8221;。</li>
<li>我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。</li>
</ol>


<h3>兼容性</h3>

<p>因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们：</p>

<ol>
<li>老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。</li>
<li>老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。</li>
<li>nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。</li>
</ol>


<p>事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。</p>

<h3>参考</h3>

<ol>
<li><a href="https://developer.apple.com/swift/blog/?id=25">Nullability and Objective-C</a></li>
</ol>


<h2>weak的生命周期</h2>

<p>我们都知道weak表示的是一个弱引用，这个引用不会增加对象的引用计数，并且在所指向的对象被释放之后，weak指针会被设置的为nil。weak引用通常是用于处理循环引用的问题，如代理及block的使用中，相对会较多的使用到weak。</p>

<p>之前对weak的实现略有了解，知道它的一个基本的生命周期，但具体是怎么实现的，了解得不是太清晰。今天又翻了翻《Objective-C高级编程》关于__weak的讲解，在此做个笔记。</p>

<p>我们以下面这行代码为例：</p>

<p><strong>代码清单1：示例代码</strong></p>

<pre><code>{
    id __weak obj1 = obj;
}
</code></pre>

<p>当我们初始化一个weak变量时，runtime会调用objc_initWeak函数。这个函数在Clang中的声明如下：</p>

<pre><code>id objc_initWeak(id *object, id value);
</code></pre>

<p>其具体实现如下：</p>

<pre><code>id objc_initWeak(id *object, id value)
{
    *object = 0;
    return objc_storeWeak(object, value);
}
</code></pre>

<p>示例代码轮换成编译器的模拟代码如下：</p>

<pre><code>id obj1;
objc_initWeak(&amp;obj1, obj);
</code></pre>

<p>因此，这里所做的事是先将obj1初始化为0(nil)，然后将obj1的地址及obj作为参数传递给objc_storeWeak函数。</p>

<p>objc_initWeak函数有一个前提条件：就是object必须是一个没有被注册为__weak对象的有效指针。而value则可以是null，或者指向一个有效的对象。</p>

<p>如果value是一个空指针或者其指向的对象已经被释放了，则object是zero-initialized的。否则，object将被注册为一个指向value的__weak对象。而这事应该是objc_storeWeak函数干的。objc_storeWeak的函数声明如下：</p>

<pre><code>id objc_storeWeak(id *location, id value);
</code></pre>

<p>其具体实现如下：</p>

<pre><code>id objc_storeWeak(id *location, id newObj)
{
    id oldObj;
    SideTable *oldTable;
    SideTable *newTable;

    ......

    // Acquire locks for old and new values.
    // Order by lock address to prevent lock ordering problems. 
    // Retry if the old value changes underneath us.
 retry:
    oldObj = *location;

    oldTable = SideTable::tableForPointer(oldObj);
    newTable = SideTable::tableForPointer(newObj);

    ......

    if (*location != oldObj) {
        OSSpinLockUnlock(lock1);
#if SIDE_TABLE_STRIPE &gt; 1
        if (lock1 != lock2) OSSpinLockUnlock(lock2);
#endif
        goto retry;
    }

    if (oldObj) {
        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);
    }
    if (newObj) {
        newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);
        // weak_register_no_lock returns NULL if weak store should be rejected
    }
    // Do not set *location anywhere else. That would introduce a race.
    *location = newObj;

    ......

    return newObj;
}
</code></pre>

<p>我们撇开源码中各种锁操作，来看看这段代码都做了些什么。在此之前，我们先来了解下weak表和SideTable。</p>

<p>weak表是一个弱引用表，实现为一个weak_table_t结构体，存储了某个对象相关的的所有的弱引用信息。其定义如下(具体定义在<a href="http://www.opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h">objc-weak.h</a>中)：</p>

<pre><code>struct weak_table_t {
    weak_entry_t *weak_entries;
    size_t    num_entries;
    ......
};
</code></pre>

<p>其中weak_entry_t是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用hash表。其定义如下：</p>

<pre><code>struct weak_entry_t {
    DisguisedPtr&lt;objc_object&gt; referent;
    union {
        struct {
            weak_referrer_t *referrers;
            uintptr_t        out_of_line : 1;
            ......
        };
        struct {
            // out_of_line=0 is LSB of one of these (don't care which)
            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };
};
</code></pre>

<p>其中referent是被引用的对象，即示例代码中的obj对象。下面的union即存储了所有指向该对象的弱引用。由注释可以看到，当out_of_line等于0时，hash表被一个数组所代替。另外，所有的弱引用对象的地址都是存储在weak_referrer_t指针的地址中。其定义如下：</p>

<pre><code>typedef objc_object ** weak_referrer_t;
</code></pre>

<p>SideTable是一个用C++实现的类，它的具体定义在<a href="http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm">NSObject.mm</a>中，我们来看看它的一些成员变量的定义：</p>

<pre><code>class SideTable {
private:
    static uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];

public:

    RefcountMap refcnts;
    weak_table_t weak_table;

    ......

}
</code></pre>

<p>RefcountMap refcnts，大家应该能猜到这个做什么用的吧？看着像是引用计数什么的。哈哈，貌似就是啊，这东东存储了一个对象的引用计数的信息。当然，我们在这里不去探究它，我们关注的是weak_table。这个成员变量指向的就是一个对象的weak表。</p>

<p>了解了weak表和SideTable，让我们再回过头来看看objc_storeWeak。首先是根据weak指针找到其指向的老的对象：</p>

<pre><code>oldObj = *location;
</code></pre>

<p>然后获取到与新旧对象相关的SideTable对象：</p>

<pre><code>oldTable = SideTable::tableForPointer(oldObj);
newTable = SideTable::tableForPointer(newObj);
</code></pre>

<p>下面要做的就是在老对象的weak表中移除指向信息，而在新对象的weak表中建立关联信息：</p>

<pre><code>if (oldObj) {
    weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);
}
if (newObj) {
    newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);
    // weak_register_no_lock returns NULL if weak store should be rejected
}
</code></pre>

<p>接下来让弱引用指针指向新的对象：</p>

<pre><code>*location = newObj;
</code></pre>

<p>最后会返回这个新对象：</p>

<pre><code>return newObj;
</code></pre>

<p>objc_storeWeak的基本实现就是这样。当然，在objc_initWeak中调用objc_storeWeak时，老对象是空的，所有不会执行weak_unregister_no_lock操作。</p>

<p>而当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下：</p>

<ol>
<li>调用objc_release</li>
<li>因为对象的引用计数为0，所以执行dealloc</li>
<li>在dealloc中，调用了_objc_rootDealloc函数</li>
<li>在_objc_rootDealloc中，调用了object_dispose函数</li>
<li>调用objc_destructInstance</li>
<li>最后调用objc_clear_deallocating</li>
</ol>


<p>我们重点关注一下最后一步，objc_clear_deallocating的具体实现如下：</p>

<pre><code>void objc_clear_deallocating(id obj) 
{
    ......

    SideTable *table = SideTable::tableForPointer(obj);

    // clear any weak table items
    // clear extra retain count and deallocating bit
    // (fixme warn or abort if extra retain count == 0 ?)
    OSSpinLockLock(&amp;table-&gt;slock);
    if (seen_weak_refs) {
        arr_clear_deallocating(&amp;table-&gt;weak_table, obj);
    }
    ......
}
</code></pre>

<p>我们可以看到，在这个函数中，首先取出对象对应的SideTable实例，如果这个对象有关联的弱引用，则调用arr_clear_deallocating来清除对象的弱引用信息。我们来看看arr_clear_deallocating具体实现：</p>

<pre><code>PRIVATE_EXTERN void arr_clear_deallocating(weak_table_t *weak_table, id referent) {
    {
        weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);
        if (entry == NULL) {
            ......
            return;
        }
        // zero out references
        for (int i = 0; i &lt; entry-&gt;referrers.num_allocated; ++i) {
            id *referrer = entry-&gt;referrers.refs[i].referrer;
            if (referrer) {
                if (*referrer == referent) {
                    *referrer = nil;
                }
                else if (*referrer) {
                    _objc_inform("__weak variable @ %p holds %p instead of %p\n", referrer, *referrer, referent);
                }
            }
        }

        weak_entry_remove_no_lock(weak_table, entry);
        weak_table-&gt;num_weak_refs--;
    }
}
</code></pre>

<p>这个函数首先是找出对象对应的weak_entry_t链表，然后挨个将弱引用置为nil。最后清理对象的记录。</p>

<p>通过上面的描述，我们基本能了解一个weak引用从生到死的过程。从这个流程可以看出，一个weak引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用__weak变量的话，会对性能造成一定的影响。那么，我们应该在什么时候去使用weak呢？《Objective-C高级编程》给我们的建议是只在避免循环引用的时候使用__weak修饰符。</p>

<p>另外，在clang中，还提供了不少关于weak引用的处理函数。如objc_loadWeak, objc_destroyWeak, objc_moveWeak等，我们可以在苹果的开源代码中找到相关的实现。等有时间，我再好好研究研究。</p>

<h3>参考</h3>

<ol>
<li>《Objective-C高级编程》1.4: __weak修饰符</li>
<li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">Clang 3.7 documentation &ndash; Objective-C Automatic Reference Counting (ARC)</a></li>
<li><a href="http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm">apple opensource &ndash; NSObject.mm</a></li>
</ol>


<h2>零碎</h2>

<h3>CAGradientLayer</h3>

<p>CAGradientLayer类是用于在其背景色上绘制一个颜色渐变，以填充层的整个形状，包括圆角。这个类继承自CALayer类，使用起来还是很方便的。</p>

<p>与Quartz 2D中的渐变处理类似，一个渐变有一个起始位置(startPoint)和一个结束位置(endPoint)，在这两个位置之间，我们可以指定一组颜色值(colors，元素是CGColorRef对象)，可以是两个，也可以是多个，每个颜色值会对应一个位置(locations)。另外，渐变还分为轴向渐变和径向渐变。</p>

<p>我们写个实例来看看CAGradientLayer的具体使用：</p>

<pre><code>CAGradientLayer *layer = [CAGradientLayer layer];
layer.startPoint = (CGPoint){0.5f, 0.0f};
layer.endPoint = (CGPoint){0.5f, 1.0f};
layer.colors = [NSArray arrayWithObjects:(id)[UIColor blueColor].CGColor, (id)[UIColor redColor].CGColor, (id)[UIColor greenColor].CGColor, nil];
layer.locations = @[@0.0f, @0.6f, @1.0f];
layer.frame = self.view.layer.bounds;

[self.view.layer insertSublayer:layer atIndex:0];
</code></pre>

<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAGradientLayer_class/">CAGradientLayer Class Reference</a></li>
</ol>


<h3>Xcode中Ineligible Devices的处理</h3>

<p>换了台新电脑，装了个Xcode 6.3，整了个新证书和profile，然后打开Xcode，连上手机。额，然后发现设备居然被标识为Ineligible Devices，没认出来。情况类似于下图：</p>

<p><img src="http://i.stack.imgur.com/CFOSG.png" alt="image" /></p>

<p>电脑是受信任的，证书和profile也都是OK的。试了几次重启Xcode和重新连接手机，无效。设备就是选不了。最后是在Product->Destination里面才选中这个设备的。不过在工具栏还是不能选择，郁闷，求解。</p>

<h3>iOS 7后隐藏UITextField的光标</h3>

<p>新项目只支持iOS 7后，很多事情变得简单多了，就像隐藏UITextField的光标一样，就简单的一句话：</p>

<pre><code>textFiled.tintColor = [UIColor clearColor];
</code></pre>

<p>通常我们用UIPickerView作为我们的UITextField的inputView时，我们是需要隐藏光标的。当然，如果想换个光标颜色，也是这么处理。</p>

<p>这么处理的有个遗留问题是：通常我们使用UIPickerView作为UITextField的inputView时， 并不希望去执行各种菜单操作(全选、复制、粘帖)，但只是去设置UITextField的tintColor时，我们仍然可以执行这边操作，所以需要加额外的处理。这个问题，我们可以这样处理：在textFieldShouldBeginEditing:中，我们把UITextField的userInteractionEnabled设置为NO，然后在textFieldShouldEndEditing:，将将这个值设置回来。如下：</p>

<pre><code>- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField {

    textField.userInteractionEnabled = NO;

    return YES;
}

- (BOOL)textFieldShouldEndEditing:(UITextField *)textField {

    textField.userInteractionEnabled = YES;

    return YES;
}
</code></pre>

<p>这样就OK了。当然这只是我们当前使用的一种处理方式，还有其它的方法，直接google或者stackoverflow吧。</p>

<h3>iOS 7后UIAlertView中文字左对齐问题</h3>

<p>在iOS 7之前，如果我们想要让UIAlertView中的文字居左显示的话，可以使用以下这段代码来处理：</p>

<pre><code>for (UIView *view in alert.subviews) {
    if([[view class] isSubclassOfClass:[UILabel class]]) {
       ((UILabel*)view).textAlignment = NSTextAlignmentLeft;
    }
}
</code></pre>

<p>但很遗憾的是，在iOS 7之后，苹果不让我们这么干了。我们去取UIAlertView的subviews时，获得的只是一个空数组，我们没有办法获取到我们想要的label。怎么办？三条路：告诉产品经理和UED说这个实现不了(当然，这个是会被鄙视的，人家会说你能力差)；自己写；找第三方开源代码。嘿嘿，不过由于最近时间紧，所以我决定跟他们说实现不了，哈哈。不过在github上找了一个开源的，<a href="https://github.com/wimagguc/ios-custom-alertview">Custom iOS AlertView</a>，star的数量也不少，看来不错，回头好好研究研究。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集 第一期(2015.05.10)]]></title>
    <link href="http://southpeak.github.io/blog/2015/05/10/ioszhi-shi-xiao-ji-di-%5B%3F%5D-qi-2015-dot-05-dot-10/"/>
    <updated>2015-05-10T22:06:42+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/05/10/ioszhi-shi-xiao-ji-di-[?]-qi-2015-dot-05-dot-10</id>
    <content type="html"><![CDATA[<p>一直想做这样一个小册子，来记录自己平时开发、阅读博客、看书、代码分析和与人交流中遇到的各种问题。之前有过这样的尝试，但都是无疾而终。不过，每天接触的东西多，有些东西不记下来，忘得也是很快，第二次遇到同样的问题时，还得再查一遍。好记性不如烂笔头，所以又决定重拾此事，时不时回头看看，温故而知新。</p>

<p>这里面的每个问题，不会太长。或是读书笔记，或是摘抄，亦或是验证，每个问题的篇幅争取在六七百字的样子。笔记和摘抄的出处会详细标明。问题的个数不限，凑齐3500字左右就发一篇。争取每月至少发两篇吧，权当是对自己学习的一个整理。</p>

<p>本期主要记录了以下几个问题：</p>

<ol>
<li>NSString属性什么时候用copy，什么时候用strong?</li>
<li>Foundation中的断言处理</li>
<li>IBOutletCollection</li>
<li>NSRecursiveLock递归锁的使用</li>
<li>NSHashTable</li>
</ol>


<h2>NSString属性什么时候用copy，什么时候用strong?</h2>

<p>我们在声明一个NSString属性时，对于其内存相关特性，通常有两种选择(基于ARC环境)：strong与copy。那这两者有什么区别呢？什么时候该用strong，什么时候该用copy呢？让我们先来看个例子。</p>

<h3>示例</h3>

<p>我们定义一个类，并为其声明两个字符串属性，如下所示：</p>

<pre><code>@interface TestStringClass ()

@property (nonatomic, strong) NSString *strongString;
@property (nonatomic, copy) NSString *copyedString;

@end
</code></pre>

<p>上面的代码声明了两个字符串属性，其中一个内存特性是strong，一个是copy。下面我们来看看它们的区别。</p>

<p>首先，我们用一个不可变字符串来为这两个属性赋值，</p>

<pre><code>- (void)test {

    NSString *string = [NSString stringWithFormat:@"abc"];
    self.strongString = string;
    self.copyedString = string;

    NSLog(@"origin string: %p, %p", string, &amp;string);
    NSLog(@"strong string: %p, %p", _strongString, &amp;_strongString);
    NSLog(@"copy string: %p, %p", _copyedString, &amp;_copyedString);
}
</code></pre>

<p>其输出结果是：</p>

<pre><code>origin string: 0x7fe441592e20, 0x7fff57519a48
strong string: 0x7fe441592e20, 0x7fe44159e1f8
copy string: 0x7fe441592e20, 0x7fe44159e200
</code></pre>

<p>我们要以看到，这种情况下，不管是strong还是copy属性的对象，其指向的地址都是同一个，即为string指向的地址。如果我们换作MRC环境，打印string的引用计数的话，会看到其引用计数值是3，即strong操作和copy操作都使原字符串对象的引用计数值加了1。</p>

<p>接下来，我们把string由不可变改为可变对象，看看会是什么结果。即将下面这一句</p>

<pre><code>NSString *string = [NSString stringWithFormat:@"abc"];
</code></pre>

<p>改成：</p>

<pre><code>NSMutableString *string = [NSMutableString stringWithFormat:@"abc"];
</code></pre>

<p>其输出结果是：</p>

<pre><code>origin string: 0x7ff5f2e33c90, 0x7fff59937a48
strong string: 0x7ff5f2e33c90, 0x7ff5f2e2aec8
copy string: 0x7ff5f2e2aee0, 0x7ff5f2e2aed0
</code></pre>

<p>可以发现，此时copy属性字符串已不再指向string字符串对象，而是深拷贝了string字符串，并让_copyedString对象指向这个字符串。在MRC环境下，打印两者的引用计数，可以看到string对象的引用计数是2，而_copyedString对象的引用计数是1。</p>

<p>此时，我们如果去修改string字符串的话，可以看到：因为_strongString与string是指向同一对象，所以_strongString的值也会跟随着改变(需要注意的是，此时_strongString的类型实际上是NSMutableString，而不是NSString)；而_copyedString是指向另一个对象的，所以并不会改变。</p>

<h3>结论</h3>

<p>由于NSMutableString是NSString的子类，所以一个NSString指针可以指向NSMutableString对象，让我们的strongString指针指向一个可变字符串是OK的。</p>

<p>而上面的例子可以看出，当源字符串是NSString时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次<strong>浅拷贝</strong>。</p>

<p>当源字符串是NSMutableString时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次<strong>深拷贝</strong>，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString，而不是NSMutableString，因此其是不可变的。</p>

<p>这里还有一个性能问题，即在源字符串是NSMutableString，strong是单纯的增加对象的引用计数，而copy操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是NSString时，则没有这个问题。</p>

<p>所以，在声明NSString属性时，到底是选择strong还是copy，可以根据实际情况来定。不过，一般我们将对象声明为NSString时，都不希望它改变，所以大多数情况下，我们建议用copy，以免因可变字符串的修改导致的一些非预期问题。</p>

<p>关于字符串的内存管理，还有些有意思的东西，可以参考<a href="http://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/">NSString特性分析学习</a>。</p>

<h3>参考</h3>

<ol>
<li><a href="http://stackoverflow.com/questions/2521468/nsstring-copy-not-copying">NSString copy not copying?</a></li>
<li><a href="http://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/">NSString特性分析学习</a></li>
<li><a href="http://blog.csdn.net/itianyi/article/details/9018567">NSString什么时候用copy，什么时候用strong</a></li>
</ol>


<h2>Foundation中的断言处理</h2>

<p>经常在看一些第三方库的代码时，或者自己在写一些基础类时，都会用到断言。所以在此总结一下Objective-C中关于断言的一些问题。</p>

<p>Foundation中定义了两组断言相关的宏，分别是：</p>

<pre><code>NSAssert / NSCAssert
NSParameterAssert / NSCParameterAssert
</code></pre>

<p>这两组宏主要在功能和语义上有所差别，这些区别主要有以下两点：</p>

<ol>
<li>如果我们需要确保方法或函数的输入参数的正确性，则应该在方法(函数)的顶部使用NSParameterAssert / NSCParameterAssert；而在其它情况下，使用NSAssert / NSCAssert。</li>
<li>另一个不同是介于C和Objective-C之间。NSAssert / NSParameterAssert应该用于Objective-C的上下文(方法)中，而NSCAssert / NSCParameterAssert应该用于C的上下文(函数)中。</li>
</ol>


<p>当断言失败时，通常是会抛出一个如下所示的异常：</p>

<pre><code>*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'true is not equal to false'
</code></pre>

<p>Foundation为了处理断言，专门定义了一个NSAssertionHandler来处理断言的失败情况。NSAssertionHandler对象是自动创建的，用于处理失败的断言。当断言失败时，会传递一个字符串给NSAssertionHandler对象来描述失败的原因。<strong>每个线程都有自己的NSAssertionHandler对象</strong>。当调用时，一个断言处理器会打印包含方法和类(或函数)的错误消息，并引发一个NSInternalInconsistencyException异常。就像上面所看到的一样。</p>

<p>我们很少直接去调用NSAssertionHandler的断言处理方法，通常都是自动调用的。</p>

<p>NSAssertionHandler提供的方法并不多，就三个，如下所示：</p>

<pre><code>// 返回与当前线程的NSAssertionHandler对象。
// 如果当前线程没有相关的断言处理器，则该方法会创建一个并指定给当前线程
+ (NSAssertionHandler *)currentHandler

// 当NSCAssert或NSCParameterAssert断言失败时，会调用这个方法
- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)object lineNumber:(NSInteger)fileName description:(NSString *)line, format,...

// 当NSAssert或NSParameterAssert断言失败时，会调用这个方法
- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format, ...
</code></pre>

<p>另外，还定义了一个常量字符串，</p>

<pre><code>NSString * const NSAssertionHandlerKey;
</code></pre>

<p>主要是用于在线程的threadDictionary字典中获取或设置断言处理器。</p>

<p>关于断言，还需要注意的一点是在Xcode 4.2以后，在release版本中断言是默认关闭的，这是由宏NS_BLOCK_ASSERTIONS来处理的。也就是说，当编译release版本时，所有的断言调用都是无效的。</p>

<p>我们可以自定义一个继承自NSAssertionHandler的断言处理类，来实现一些我们自己的需求。如Mattt Thompson的<a href="http://nshipster.com/nsassertionhandler/">NSAssertion​Handler</a>实例一样：</p>

<pre><code>@interface LoggingAssertionHandler : NSAssertionHandler
@end

@implementation LoggingAssertionHandler

- (void)handleFailureInMethod:(SEL)selector
                       object:(id)object
                         file:(NSString *)fileName
                   lineNumber:(NSInteger)line
                  description:(NSString *)format, ...
{
    NSLog(@"NSAssert Failure: Method %@ for object %@ in %@#%i", NSStringFromSelector(selector), object, fileName, line);
}

- (void)handleFailureInFunction:(NSString *)functionName
                           file:(NSString *)fileName
                     lineNumber:(NSInteger)line
                    description:(NSString *)format, ...
{
    NSLog(@"NSCAssert Failure: Function (%@) in %@#%i", functionName, fileName, line);
}

@end
</code></pre>

<p>上面说过，每个线程都有自己的断言处理器。我们可以通过为线程的threadDictionary字典中的NSAssertionHandlerKey指定一个新值，来改变线程的断言处理器。</p>

<p>如下代码所示：</p>

<pre><code>- (BOOL)application:(UIApplication *)application
didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  NSAssertionHandler *assertionHandler = [[LoggingAssertionHandler alloc] init];
  [[[NSThread currentThread] threadDictionary] setValue:assertionHandler
                                                 forKey:NSAssertionHandlerKey];
  // ...

  return YES;
}
</code></pre>

<p>而什么时候应该使用断言呢？通常我们期望程序按照我们的预期去运行时，如调用的参数为空时流程就无法继续下去时，可以使用断言。但另一方面，我们也需要考虑，在这加断言确实是需要的么？我们是否可以通过更多的容错处理来使程序正常运行呢？</p>

<p>Mattt Thompson在<a href="http://nshipster.com/nsassertionhandler/">NSAssertion​Handler</a>中的倒数第二段说得挺有意思，在此摘抄一下：</p>

<pre><code>But if we look deeper into NSAssertionHandler—and indeed, into our own hearts, there are lessons to be learned about our capacity for kindness and compassion; about our ability to forgive others, and to recover from our own missteps. We can't be right all of the time. We all make mistakes. By accepting limitations in ourselves and others, only then are we able to grow as individuals.
</code></pre>

<h3>参考</h3>

<ol>
<li><a href="http://nshipster.com/nsassertionhandler/">NSAssertion​Handler</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAssertionHandler_Class/">NSAssertionHandler Class Reference</a></li>
</ol>


<h2>IBOutletCollection</h2>

<p>在IB与相关文件做连接时，我们经常会用到两个关键字：IBOutlet和IBAction。经常用xib或storyboard的童鞋应该用这两上关键字非常熟悉了。不过UIKit还提供了另一个伪关键字<strong>IBOutletCollection</strong>，我们使用这个关键字，可以将界面上一组相同的控件连接到同一个数组中。</p>

<p>我们先来看看这个伪关键字的定义，可以从UIKit.framework的头文件UINibDeclarations.h找到如下定义：</p>

<pre><code>#ifndef IBOutletCollection
#define IBOutletCollection(ClassName)
#endif
</code></pre>

<p>另外，在Clang源码中，有更安全的定义方式，如下所示：</p>

<pre><code>#define IBOutletCollection(ClassName) __attribute__((iboutletcollection(ClassName)))
</code></pre>

<p>从上面的定义可以看到，与IBOutlet不同的是，IBOutletCollection带有一个参数，该参数是一个类名。</p>

<p>通常情况下，我们使用一个IBOutletCollection属性时，属性必须是strong的，且类型是NSArray，如下所示：</p>

<pre><code>@property (strong, nonatomic) IBOutletCollection(UIScrollView) NSArray *scrollViews;
</code></pre>

<p>假定我们的xib文件中有三个横向的scrollView，我们便可以将这三个scrollView都连接至scrollViews属性，然后在我们的代码中便可以做一些统一处理，如下所示：</p>

<pre><code>- (void)setupScrollViewImages
{
    for (UIScrollView *scrollView in self.scrollViews) {
        [self.imagesData enumerateObjectsUsingBlock:^(NSString *imageName, NSUInteger idx, BOOL *stop) {
            UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(CGRectGetWidth(scrollView.frame) * idx, 0, CGRectGetWidth(scrollView.frame), CGRectGetHeight(scrollView.frame))];
            imageView.contentMode = UIViewContentModeScaleAspectFill;
            imageView.image = [UIImage imageNamed:imageName];
            [scrollView addSubview:imageView];
        }];
    }
}
</code></pre>

<p>这段代码会影响到三个scrollView。这样做的好处是我们不需要手动通过addObject:方法将scrollView添加到scrollViews中。</p>

<p>不过在使用IBOutletCollection时，需要注意两点：</p>

<ol>
<li>IBOutletCollection集合中对象的顺序是不确定的。我们通过调试方法可以看到集合中对象的顺序跟我们连接的顺序是一样的。但是这个顺序可能会因为不同版本的Xcode而有所不同。所以我们不应该试图在代码中去假定这种顺序。</li>
<li>不管IBOutletCollection(ClassName)中的控件是什么，属性的类型始终是NSArray。实际上，我们可以声明是任何类型，如NSSet，NSMutableArray，甚至可以是UIColor，但不管我们在此设置的是什么类，IBOutletCollection属性总是指向一个NSArray数组。</li>
</ol>


<p>关于第二点，我们以上面的scrollViews为例，作如下修改：</p>

<pre><code>@property (strong, nonatomic) IBOutletCollection(UIScrollView) NSSet *scrollViews;
</code></pre>

<p>实际上我们在控制台打印这个scrollViews时，结果如下所示：</p>

<pre><code>(lldb) po self.scrollViews
&lt;__NSArrayI 0x1740573d0&gt;(
&lt;UIScrollView: 0x12d60d770; frame = (0 0; 320 162); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x1740574f0&gt;; layer = &lt;CALayer: 0x174229480&gt;; contentOffset: {0, 0}; contentSize: {0, 0}&gt;,
&lt;UIScrollView: 0x12d60dee0; frame = (0 0; 320 161); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x174057790&gt;; layer = &lt;CALayer: 0x1742297c0&gt;; contentOffset: {0, 0}; contentSize: {0, 0}&gt;,
&lt;UIScrollView: 0x12d60e650; frame = (0 0; 320 163); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x1740579a0&gt;; layer = &lt;CALayer: 0x1742298e0&gt;; contentOffset: {0, 0}; contentSize: {0, 0}&gt;
)
</code></pre>

<p>可以看到，它指向的是一个NSArray数组。</p>

<p>另外，IBOutletCollection实际上在iOS 4版本中就有了。不过，现在的Objective-C已经支持object literals了，所以定义数组可以直接用@[]，方便了许多。而且object literals方式可以添加不在xib中的用代码定义的视图，所以显得更加灵活。当然，两种方式选择哪一种，就看我们自己的实际需要和喜好了。</p>

<h3>参考</h3>

<ol>
<li><a href="http://nshipster.com/ibaction-iboutlet-iboutletcollection/">IBAction / IBOutlet / IBOutlet​Collection</a></li>
<li><a href="http://www.opensource.apple.com/source/clang/clang-318.0.45/src/tools/clang/test/Index/IBOutletCollection.m">IBOutletCollection.m</a></li>
</ol>


<h2>NSRecursiveLock递归锁的使用</h2>

<p>NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。我们先来看一个示例：</p>

<pre><code>NSLock *lock = [[NSLock alloc] init];

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

    static void (^RecursiveMethod)(int);

    RecursiveMethod = ^(int value) {

        [lock lock];
        if (value &gt; 0) {

            NSLog(@"value = %d", value);
            sleep(2);
            RecursiveMethod(value - 1);
        }
        [lock unlock];
    };

    RecursiveMethod(5);
});
</code></pre>

<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>

<pre><code>value = 5
*** -[NSLock lock]: deadlock (&lt;NSLock: 0x1700ceee0&gt; '(null)')   *** Break on _NSLockError() to debug.   
</code></pre>

<p>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>

<p>所以，对上面的代码进行一下改造，</p>

<pre><code>NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
</code></pre>

<p>这样，程序就能正常运行了，其输出如下所示：</p>

<pre><code>value = 5
value = 4
value = 3
value = 2
value = 1
</code></pre>

<p>NSRecursiveLock除了实现NSLocking协议的方法外，还提供了两个方法，分别如下：</p>

<pre><code>// 在给定的时间之前去尝试请求一个锁
- (BOOL)lockBeforeDate:(NSDate *)limit

// 尝试去请求一个锁，并会立即返回一个布尔值，表示尝试是否成功
- (BOOL)tryLock
</code></pre>

<p>这两个方法都可以用于在多线程的情况下，去尝试请求一个递归锁，然后根据返回的布尔值，来做相应的处理。如下代码所示：</p>

<pre><code>NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

    static void (^RecursiveMethod)(int);

    RecursiveMethod = ^(int value) {

        [lock lock];
        if (value &gt; 0) {

            NSLog(@"value = %d", value);
            sleep(2);
            RecursiveMethod(value - 1);
        }
        [lock unlock];
    };

    RecursiveMethod(5);
});

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

    sleep(2);
    BOOL flag = [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:1]];
    if (flag) {
        NSLog(@"lock before date");

        [lock unlock];
    } else {
        NSLog(@"fail to lock before date");
    }
});
</code></pre>

<p>在前面的代码中，我们又添加了一段代码，增加一个线程来获取递归锁。我们在第二个线程中尝试去获取递归锁，当然这种情况下是会失败的，输出结果如下：</p>

<pre><code>value = 5
value = 4
fail to lock before date
value = 3
value = 2
value = 1
</code></pre>

<p>另外，NSRecursiveLock还声明了一个name属性，如下：</p>

<pre><code>@property(copy) NSString *name
</code></pre>

<p>我们可以使用这个字符串来标识一个锁。Cocoa也会使用这个name作为错误描述信息的一部分。</p>

<h3>参考</h3>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRecursiveLock_Class/">NSRecursiveLock Class Reference</a></li>
<li><a href="http://www.tanhao.me/pieces/643.html/">Objective-C中不同方式实现锁(二)</a></li>
</ol>


<h2>NSHashTable</h2>

<p>在看KVOController的代码时，又看到了NSHashTable这个类，所以就此整理一下。</p>

<p>NSHashTable效仿了NSSet(NSMutableSet)，但提供了比NSSet更多的操作选项，尤其是在对弱引用关系的支持上，NSHashTable在对象/内存处理时更加的灵活。相较于NSSet，NSHashTable具有以下特性：</p>

<ol>
<li>NSSet(NSMutableSet)持有其元素的强引用，同时这些元素是使用hash值及isEqual:方法来做hash检测及判断是否相等的。</li>
<li>NSHashTable是可变的，它没有不可变版本。</li>
<li>它可以持有元素的弱引用，而且在对象被销毁后能正确地将其移除。而这一点在NSSet是做不到的。</li>
<li>它的成员可以在添加时被拷贝。</li>
<li>它的成员可以使用指针来标识是否相等及做hash检测。</li>
<li>它可以包含任意指针，其成员没有限制为对象。我们可以配置一个NSHashTable实例来操作任意的指针，而不仅仅是对象。</li>
</ol>


<p>初始化NSHashTable时，我们可以设置一个初始选项，这个选项确定了这个NSHashTable对象后面所有的行为。这个选项是由NSHashTableOptions枚举来定义的，如下所示：</p>

<pre><code>enum {

    // 默认行为，强引用集合中的对象，等同于NSSet
    NSHashTableStrongMemory             = 0,

    // 在将对象添加到集合之前，会拷贝对象
    NSHashTableCopyIn                   = NSPointerFunctionsCopyIn,

    // 使用移位指针(shifted pointer)来做hash检测及确定两个对象是否相等；
    // 同时使用description方法来做描述字符串
    NSHashTableObjectPointerPersonality = NSPointerFunctionsObjectPointerPersonality,

    // 弱引用集合中的对象，且在对象被释放后，会被正确的移除。
    NSHashTableWeakMemory               = NSPointerFunctionsWeakMemory 
};
typedef NSUInteger NSHashTableOptions;
</code></pre>

<p>当然，我们还可以使用NSPointerFunctions来初始化，但只有使用NSHashTableOptions定义的这些值，才能确保NSHashTable的各个API可以正确的工作&mdash;包括拷贝、归档及快速枚举。</p>

<p>个人认为NSHashTable吸引人的地方在于可以持有元素的弱引用，而且在对象被销毁后能正确地将其移除。我们来写个示例：</p>

<pre><code>// 具体调用如下
@implementation TestHashAndMapTableClass {

    NSMutableDictionary *_dic;
    NSSet               *_set;

    NSHashTable         *_hashTable;
}

- (instancetype)init {

    self = [super init];

    if (self) {

        [self testWeakMemory];

        NSLog(@"hash table [init]: %@", _hashTable);
    }

    return self;
}

- (void)testWeakMemory {

    if (!_hashTable) {
        _hashTable = [NSHashTable weakObjectsHashTable];
    }

    NSObject *obj = [[NSObject alloc] init];

    [_hashTable addObject:obj];

    NSLog(@"hash table [testWeakMemory] : %@", _hashTable);
}
</code></pre>

<p>这段代码的输出结果如下：</p>

<pre><code>hash table [testWeakMemory] : NSHashTable {
[6] &lt;NSObject: 0x7fa2b1562670&gt;
}
hash table [init]: NSHashTable {
}
</code></pre>

<p>可以看到，在离开testWeakMemory方法，obj对象被释放，同时对象在集合中的引用也被安全的删除。</p>

<p>这样看来，NSHashTable似乎比NSSet(NSMutableSet)要好啊。那是不是我们就应用都使用NSHashTable呢？Peter Steinberger在<a href="http://www.objc.io/issue-7/collections.html">The Foundation Collection Classes</a>给了我们一组数据，显示在添加对象的操作中，NSHashTable所有的时间差不多是NSMutableSet的2倍，而在其它操作中，性能大体相近。所以，如果我们只需要NSSet的特性，就尽量用NSSet。</p>

<p>另外，Mattt Thompson在<a href="http://nshipster.com/nshashtable-and-nsmaptable/">NSHash​Table &amp; NSMap​Table</a>的结尾也写了段挺有意思的话，在此直接摘抄过来：</p>

<pre><code>As always, it's important to remember that programming is not about being clever: always approach a problem from the highest viable level of abstraction. NSSet and NSDictionary are great classes. For 99% of problems, they are undoubtedly the correct tool for the job. If, however, your problem has any of the particular memory management constraints described above, then NSHashTable &amp; NSMapTable may be worth a look.
</code></pre>

<h3>参考</h3>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSHashTable_class/">NSHashTable Class Reference</a></li>
<li><a href="http://nshipster.com/nshashtable-and-nsmaptable/">NSHash​Table &amp; NSMap​Table</a></li>
<li><a href="http://billwang1990.github.io/blog/2014/03/31/nshashtable-and-nsmaptable/">NSHashTable &amp; NSMapTable</a></li>
<li><a href="http://www.objc.io/issue-7/collections.html">The Foundation Collection Classes</a></li>
</ol>


<h2>零碎</h2>

<h3>(一) &ldquo;Unknown class XXViewController in Interface Builder file.&rdquo;&ldquo; 问题处理</h3>

<p>最近在静态库中写了一个XXViewController类，然后在主工程的xib中，将xib的类指定为XXViewController，程序运行时，报了如下错误：</p>

<pre><code>Unknown class XXViewController in Interface Builder file.
</code></pre>

<p>之前也遇到这个问题，但已记得不太清楚，所以又开始在stackoverflow上找答案。</p>

<p>其实这个问题与Interface Builder无关，最直接的原因还是相关的symbol没有从静态库中加载进来。这种问题的处理就是在Target的&#8221;Build Setting&#8221;&ndash;>&ldquo;Other Link Flags&#8221;中加上&rdquo;-all_load -ObjC&#8221;这两个标识位，这样就OK了。</p>

<h3>(二)关于Unbalanced calls to begin/end appearance transitions for &hellip;问题的处理</h3>

<p>我们的某个业务有这么一个需求，进入一个列表后需要立马又push一个web页面，做一些活动的推广。在iOS 8上，我们的实现是一切OK的；但到了iOS 7上，就发现这个web页面push不出来了，同时控制台给了一条警告消息，即如下：</p>

<pre><code>Unbalanced calls to begin/end appearance transitions for ...
</code></pre>

<p>在这种情况下，点击导航栏中的返回按钮时，直接显示一个黑屏。</p>

<p>我们到stackoverflow上查了一下，有这么一段提示：</p>

<pre><code>occurs when you try and display a new viewcontroller before the current view controller is finished displaying.
</code></pre>

<p>意思是说在当前视图控制器完成显示之前，又试图去显示一个新的视图控制器。</p>

<p>于是我们去排查代码，果然发现，在viewDidLoad里面去做了次网络请求操作，且请求返回后就去push这个web活动推广页。此时，当前的视图控制器可能并未显示完成(即未完成push操作)。</p>

<pre><code>Basically you are trying to push two view controllers onto the stack at almost the same time. 
</code></pre>

<p>当几乎同时将两个视图控制器push到当前的导航控制器栈中时，或者同时pop两个不同的视图控制器，就会出现不确定的结果。所以我们应该确保同一时间，对同一个导航控制器栈只有一个操作，即便当前的视图控制器正在动画过程中，也不应该再去push或pop一个新的视图控制器。</p>

<p>所以最后我们把web活动的数据请求放到了viewDidAppear里面，并做了些处理，这样问题就解决了。</p>

<h4>参考</h4>

<ol>
<li><p><a href="http://stackoverflow.com/questions/9088465/unbalanced-calls-to-begin-end-appearance-transitions-for-detailviewcontroller">“Unbalanced calls to begin/end appearance transitions for DetailViewController” when pushing more than one detail view controller</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/8563473/unbalanced-calls-to-begin-end-appearance-transitions-for-uitabbarcontroller">Unbalanced calls to begin/end appearance transitions for UITabBarController</a></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSKeyValueObserving(KVO)]]></title>
    <link href="http://southpeak.github.io/blog/2015/04/23/nskeyvalueobserving-kvo/"/>
    <updated>2015-04-23T17:31:16+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/04/23/nskeyvalueobserving-kvo</id>
    <content type="html"><![CDATA[<p>NSKeyValueObserving非正式协议定义了一种机制，它允许对象去监听其它对象的某个属性的修改。</p>

<p>我们可以监听一个对象的属性，包括简单属性，一对一的关系，和一对多的关系。一对多关系的监听者会被告知集合变更的类型，以及哪些对象参与了变化。</p>

<p>NSObject提供了一个NSKeyValueObserving协议的默认实现，它为所有对象提供了一种自动发送修改通知的能力。我们可以通过禁用自动发送通知并使用这个协议提供的方法来手动实现通知的发送，以便更精确地去处理通知。</p>

<p>在这里，我们将通过具体的实例来看看NSKeyValueObserving提供了哪些方法。我们的基础代码如代码清单1所示：</p>

<p><strong>代码清单1：示例基础代码</strong></p>

<pre><code>#pragma mark - PersonObject

@interface PersonObject : NSObject

@end

@implementation PersonObject

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {

    NSLog(@"keyPath = %@, change = %@, context = %s", keyPath, change, (char *)context);
}

@end

#pragma mark - BankObject

@interface BankObject : NSObject

@property (nonatomic, assign) int accountBalance;
@property (nonatomic, copy) NSString *bankCodeEn;
@property (nonatomic, strong) NSMutableArray *departments;

@end
</code></pre>

<p>在这段代码中，我们定义一两个类，一个是PersonObject类，这个类的对象在下面将充当观察者的角色。另一个是BankObject类，我们在这个类中定义了三个属性，作为被监听的属性。由于NSObject类已经实现了NSKeyValueObserving协议，所以我们不需要再显式地去让我们的类实现这个协议。</p>

<p>接下来，我们便来看看NSKeyValueObserving协议有哪些功能。</p>

<h2>注册/移除观察者</h2>

<p>要让一个对象监听另一个对象的属性的变化，首先需要将这个对象注册为相关属性的观察者，我们可以使用以下方法来实现：</p>

<pre><code>- (void)addObserver:(NSObject *)anObserver
         forKeyPath:(NSString *)keyPath
            options:(NSKeyValueObservingOptions)options
            context:(void *)context
</code></pre>

<p>这个方法带有四个参数，描述如下：</p>

<ol>
<li>anObserver：观察者对象，这个对象必须实现observeValueForKeyPath:ofObject:change:context:方法，以响应属性的修改通知。</li>
<li>keyPath：被监听的属性。这个值不能为nil。</li>
<li>options：监听选项，这个值可以是NSKeyValueObservingOptions选项的组合。关于监听选项，我们会在下面介绍。</li>
<li>context：任意的额外数据，我们可以将这些数据作为上下文数据，它会传递给观察者对象的observeValueForKeyPath:ofObject:change:context:方法。这个参数的意义在于用于区分同一对象监听同一属性(从属于同一对象)的多个不同的监听。我们将在下面看到。</li>
</ol>


<p>监听选项是由枚举NSKeyValueObservingOptions定义的，是传入-addObserver:forKeyPath:options:context:方法中以确定哪些值将被传到-observeValueForKeyPath:ofObject:change:context:方法中。这个枚举的定义如下：</p>

<pre><code>enum {
    // 提供属性的新值
    NSKeyValueObservingOptionNew = 0x01,

    // 提供属性的旧值
    NSKeyValueObservingOptionOld = 0x02,

    // 如果指定，则在添加观察者的时候立即发送一个通知给观察者，
    // 并且是在注册观察者方法返回之前
    NSKeyValueObservingOptionInitial = 0x04,

    // 如果指定，则在每次修改属性时，会在修改通知被发送之前预先发送一条通知给观察者，
    // 这与-willChangeValueForKey:被触发的时间是相对应的。
    // 这样，在每次修改属性时，实际上是会发送两条通知。
    NSKeyValueObservingOptionPrior = 0x08 
};
typedef NSUInteger NSKeyValueObservingOptions;
</code></pre>

<p>需要注意的是，当设定了NSKeyValueObservingOptionPrior选项时，第一条通知不会包含NSKeyValueChangeNewKey。当观察者自身的KVO需要为自己的某个属性调用-willChange&hellip;方法，而这个属性的值又依赖于被观察对象的属性时，我们可以使用这个选项。</p>

<p>另外，在添加观察者时还有两点需要注意的是：</p>

<ol>
<li>调用这个方法时，两个对象(即观察者对象及属性所属的对象)都不会被retain。</li>
<li>可以多次调用这个方法，将同一个对象注册为同一属性的观察者(所有参数可以完全相同)。这时，即便在所有参数一致的情况下，新注册的观察者并不会替换原来观察者，而是会并存。这样，当属性被修改时，两次监听都会响应。</li>
</ol>


<p>对于第2点，我们在代码清单2中来验证一下：</p>

<p><strong>代码清单2：验证多次使用相同参数来添加观察者的实际效果</strong></p>

<pre><code>PersonObject *personInstance = [[PersonObject alloc] init];
BankObject *bankInstance = [[BankObject alloc] init];

[bankInstance addObserver:personInstance forKeyPath:@"accountBalance" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];
[bankInstance addObserver:personInstance forKeyPath:@"accountBalance" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];

[bankInstance addObserver:personInstance forKeyPath:@"accountBalance" options:NSKeyValueObservingOptionNew context:"person instance"];
[bankInstance addObserver:personInstance forKeyPath:@"accountBalance" options:NSKeyValueObservingOptionNew context:"person instance 2"];

bankInstance.accountBalance = 10;
</code></pre>

<p>(注，以上代码为在MRC环境下调用，确保personInstance和bankInstance不会被释放。)</p>

<p>这段代码的输出如下所示：</p>

<pre><code>keyPath = accountBalance, change = {
    kind = 1;
    new = 10;
}, context = person instance 2
keyPath = accountBalance, change = {
    kind = 1;
    new = 10;
}, context = person instance
keyPath = accountBalance, change = {
    kind = 1;
    new = 10;
    old = 0;
}, context = (null)
keyPath = accountBalance, change = {
    kind = 1;
    new = 10;
    old = 0;
}, context = (null)
</code></pre>

<p>可以看到KVO为每次注册都调用了一次监听处理操作。所以多次调用同样的注册操作会产生多个观察者。另外，多个观察者之间的observeValueForKeyPath:ofObject:change:context:方法调用顺序是按照先进后出的顺序来的(所有的监听信息都是放在一个数组中的，我们将在下面了解到)。</p>

<p>一个良好的实践是在观察者不再需要监听属性变化时，必须调用removeObserver:forKeyPath:或removeObserver:forKeyPath:context:方法来移除观察者，这两个方法的声明如下：</p>

<pre><code>- (void)removeObserver:(NSObject *)anObserver
            forKeyPath:(NSString *)keyPath

- (void)removeObserver:(NSObject *)observer
            forKeyPath:(NSString *)keyPath
               context:(void *)context
</code></pre>

<p>这两个方法会根据传入的参数(主要是keyPath和context)来移除观察者。如果observer没有监听keyPath属性，则调用这两个方法会抛出异常。大家可以试一下，程序会果断的崩溃。并报类似于以下的错误：</p>

<pre><code>*** Terminating app due to uncaught exception 'NSRangeException', reason: 'Cannot remove an observer &lt;PersonObject 0x7ff541534e20&gt; for the key path "accountBalance" from &lt;BankObject 0x7ff541528430&gt; because it is not registered as an observer.'
</code></pre>

<p>所以，我们必须确保先注册了观察者，才能调用移除方法。</p>

<p>那如果我们忘记调用移除观察者方法，会怎么样呢？我们来制造一个场景，看看会是什么结果。还是使用上面的代码，只不过这次我们在ARC下来测试：</p>

<p><strong>代码清单3：未移除观察者的影响</strong></p>

<pre><code>- (void)testKVO {

    PersonObject *personInstance = [[PersonObject alloc] init];
    BankObject *bankInstance = [[BankObject alloc] init];

    [bankInstance addObserver:personInstance forKeyPath:@"accountBalance" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];

    bankInstance.accountBalance = 20;
}
</code></pre>

<p>其输出结果如下所示：</p>

<pre><code>keyPath = accountBalance, change = {
    kind = 1;
    new = 20;
    old = 0;
}, context = (null)
*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'An instance 0x7fc88047e7e0 of class BankObject was deallocated while key value observers were still registered with it. Current observation info: &lt;NSKeyValueObservationInfo 0x7fc880770fa0&gt; (
&lt;NSKeyValueObservance 0x7fc880771850: Observer: 0x7fc8804737a0, Key path: accountBalance, Options: &lt;New: YES, Old: YES, Prior: NO&gt; Context: 0x0, Property: 0x7fc88076edd0&gt;
)'
......
</code></pre>

<p>程序在调用一次KVO后，很爽快地崩溃了。给我们的解释是bankInstance被释放了，但KVO中仍然还有关于它的注册信息。实际上，我们上面说过，在添加观察者的时候，观察者对象与被观察属性所属的对象都不会被retain，然而在这些对象被释放后，相关的监听信息却还存在，KVO做的处理是直接让程序崩溃。</p>

<h2>处理属性修改通知</h2>

<p>当被监听的属性修改时，KVO会发出一个通知以告知所有监听这个属性的观察者对象。而观察者对象必须实现
-observeValueForKeyPath:ofObject:change:context:方法，来对属性修改通知做相应的处理。这个方法的声明如下：</p>

<pre><code>- (void)observeValueForKeyPath:(NSString *)keyPath
                      ofObject:(id)object
                        change:(NSDictionary *)change
                       context:(void *)context
</code></pre>

<p>这个方法有四个参数，描述如下：</p>

<ol>
<li>keyPath：即被观察的属性，与参数object相关。</li>
<li>object：keyPath所属的对象。</li>
<li>change：这是一个字典，它包含了属性被修改的一些信息。这个字典中包含的值会根据我们在添加观察者时设置的options参数的不同而有所不同。</li>
<li>context：这个值即是添加观察者时提供的上下文信息。</li>
</ol>


<p>在我们的示例中，这个方法的实现是打印一些基本的信息。如代码清单1所示。</p>

<p>对于第三个参数，我们通常称之为<strong>变化字典(Change Dictionary)</strong>，它记录了被监听属性的变化情况。我们可以通过以下key来获取我们想要的信息：</p>

<pre><code>// 属性变化的类型，是一个NSNumber对象，包含NSKeyValueChange枚举相关的值
NSString *const NSKeyValueChangeKindKey;

// 属性的新值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，
// 且添加观察的方法设置了NSKeyValueObservingOptionNew时，我们能获取到属性的新值。
// 如果NSKeyValueChangeKindKey是NSKeyValueChangeInsertion或者NSKeyValueChangeReplacement，
// 且指定了NSKeyValueObservingOptionNew时，则我们能获取到一个NSArray对象，包含被插入的对象或
// 用于替换其它对象的对象。
NSString *const NSKeyValueChangeNewKey;

// 属性的旧值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，
// 且添加观察的方法设置了NSKeyValueObservingOptionOld时，我们能获取到属性的旧值。
// 如果NSKeyValueChangeKindKey是NSKeyValueChangeRemoval或者NSKeyValueChangeReplacement，
// 且指定了NSKeyValueObservingOptionOld时，则我们能获取到一个NSArray对象，包含被移除的对象或
// 被替换的对象。
NSString *const NSKeyValueChangeOldKey;

// 如果NSKeyValueChangeKindKey的值是NSKeyValueChangeInsertion、NSKeyValueChangeRemoval
// 或者NSKeyValueChangeReplacement，则这个key对应的值是一个NSIndexSet对象，
// 包含了被插入、移除或替换的对象的索引
NSString *const NSKeyValueChangeIndexesKey;

// 当指定了NSKeyValueObservingOptionPrior选项时，在属性被修改的通知发送前，
// 会先发送一条通知给观察者。我们可以使用NSKeyValueChangeNotificationIsPriorKey
// 来获取到通知是否是预先发送的，如果是，获取到的值总是@(YES)
NSString *const NSKeyValueChangeNotificationIsPriorKey;
</code></pre>

<p>其中，NSKeyValueChangeKindKey的值取自于NSKeyValueChange，它的值是由以下枚举定义的：</p>

<pre><code>enum {

    // 设置一个新值。被监听的属性可以是一个对象，也可以是一对一关系的属性或一对多关系的属性。
    NSKeyValueChangeSetting = 1,

    // 表示一个对象被插入到一对多关系的属性。
    NSKeyValueChangeInsertion = 2,

    // 表示一个对象被从一对多关系的属性中移除。
    NSKeyValueChangeRemoval = 3,

    // 表示一个对象在一对多的关系的属性中被替换
    NSKeyValueChangeReplacement = 4
};
typedef NSUInteger NSKeyValueChange;
</code></pre>

<h2>通知观察者属性的变化</h2>

<p>通知观察者的方式有自动与手动两种方式。</p>

<p>默认情况下是自动发送通知，在这种模式下，当我们修改属性的值时，KVO会自动调用以下两个方法：</p>

<pre><code>- (void)willChangeValueForKey:(NSString *)key
- (void)didChangeValueForKey:(NSString *)key
</code></pre>

<p>这两个方法的任务是告诉接收者给定的属性将要或已经被修改。需要注意的是不应该在子类中去重写这两个方法。</p>

<p>但如果我们希望自己控制通知发送的一些细节，则可以启用手动控制模式。手动控制通知提供了对KVO更精确控制，它可以控制通知如何以及何时被发送给观察者。采用这种方式可以减少不必要的通知，或者可以将多个修改组合到一个修改中。</p>

<p>实现手动通知的类必须重写NSObject中对automaticallyNotifiesObserversForKey:方法的实现。这个方法是在NSKeyValueObserving协议中声明的，其声明如下：</p>

<pre><code>+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key
</code></pre>

<p>这个方法返回一个布尔值(默认是返回YES)，以标识参数key指定的属性是否支持自动KVO。如果我们希望手动去发送通知，则针对指定的属性返回NO。</p>

<p>假设我们希望PersonObject对象去监听BankObject对象的bankCodeEn属性，并希望执行手动通知，则可以如下处理：</p>

<p><strong>代码清单4：关闭属性的自动通知发送</strong></p>

<pre><code>@implementation BankObject

+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key {

    BOOL automatic = YES;
    if ([key isEqualToString:@"bankCodeEn"]) {
        automatic = NO;
    } else {
        automatic = [super automaticallyNotifiesObserversForKey:key];
    }

    return automatic;
}

@end
</code></pre>

<p>这样我们便可以手动去发送属性修改通知了。需要注意的是，对于对象中其它没有处理的属性，我们需要调用[super automaticallyNotifiesObserversForKey:key]，以避免无意中修改了父类的属性的处理方式。</p>

<p>现在我们已经通过+automaticallyNotifiesObserversForKey:方法设置了对象中哪些属性需要手动处理。接下来就是实际操作了。为了实现手动发送通知，我们需要在修改属性值前调用willChangeValueForKey:，然后在修改属性值之后调用didChangeValueForKey:方法。继续上面的示例，我们需要对bankCodeEn属性做如下处理：</p>

<p><strong>代码清单5：手动控制通知发送</strong></p>

<pre><code>@implementation BankObject

- (void)setBankCodeEn:(NSString *)bankCodeEn {

    [self willChangeValueForKey:@"bankCodeEn"];
    _bankCodeEn = bankCodeEn;
    [self didChangeValueForKey:@"bankCodeEn"];
}

@end
</code></pre>

<p>如果我们希望只有当bankCodeEn实际被修改时发送通知，以尽量减少不必要的通知，则可以如下实现：</p>

<p><strong>代码清单6：在发送通知前测试值是否修改</strong></p>

<pre><code>- (void)setBankCodeEn:(NSString *)bankCodeEn {

    if (bankCodeEn != _bankCodeEn) {
        [self willChangeValueForKey:@"bankCodeEn"];
        _bankCodeEn = bankCodeEn;
        [self didChangeValueForKey:@"bankCodeEn"];
    }
}
</code></pre>

<p>我们来测试一下上面这段代码的实际效果：</p>

<p><strong>代码清单7：测试避免属性未实际修改下不发送通知</strong></p>

<pre><code>PersonObject    *personInstance = [[PersonObject alloc] init];
BankObject      *bankInstance = [[BankObject alloc] init];

[bankInstance addObserver:personInstance forKeyPath:@"bankCodeEn" options:NSKeyValueObservingOptionNew context:NULL];

NSString *bankCodeEn = @"CCB";
bankInstance.bankCodeEn = bankCodeEn;
bankInstance.bankCodeEn = bankCodeEn;
</code></pre>

<p>这段代码的输出结果如下所示：</p>

<pre><code>keyPath = bankCodeEn, change = {
    kind = 1;
    new = CCB;
}, context = (null)
</code></pre>

<p>我们可以看到只输出了一次，而不是两次。</p>

<p>如果我们在setter方法之外改变了实例变量(如_bankCodeEn)，且希望这种修改被观察者监听到，则需要像在setter方法里面做一样的处理。这也涉及到我们通常会遇到的一个问题，在类的内部，对于一个属性值，何时用属性(self.bankCodeEn)访问而何时用实例变量(_bankCodeEn)访问。一般的建议是，在获取属性值时，可以用实例变量，在设置属性值时，尽量用setter方法，以保证属性的KVO特性。当然，性能也是一个考量，在设置值时，使用实例变量比使用属性设置值的性能高不少。</p>

<p>另外，对于一对多关系的属性，如果想手动处理通知，则可以使用以下几个方法：</p>

<pre><code>// 有序的一对多关系
- (void)willChange:(NSKeyValueChange)change valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key
- (void)didChange:(NSKeyValueChange)change valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key

// 无序的一对多关系
- (void)willChangeValueForKey:(NSString *)key withSetMutation:(NSKeyValueSetMutationKind)mutationKind usingObjects:(NSSet *)objects
- (void)didChangeValueForKey:(NSString *)key withSetMutation:(NSKeyValueSetMutationKind)mutationKind usingObjects:(NSSet *)objects
</code></pre>

<p>同样，在子类中也不应该去重写这几个方法。</p>

<h2>计算属性(注册依赖键)</h2>

<p>有时候，我们的监听的某个属性可能会依赖于其它多个属性的变化(类似于swift，可以称之为计算属性)，不管所依赖的哪个属性发生了变化，都会导致计算属性的变化。对于这种一对一(To-one)的关系，我们需要做两步操作，首先是确定计算属性与所依赖属性的关系。如我们在BankObject类中定义一个accountForBank属性，其get方法定义如下：</p>

<p><strong>代码清单8：计算属性</strong></p>

<pre><code>@implementation BankObject

- (NSString *)accountForBank {

    return [NSString stringWithFormat:@"account for %@ is %d", self.bankCodeEn, self.accountBalance];
}

@end
</code></pre>

<p>定义了这种依赖关系后，我们就需要以某种方式告诉KVO，当我们的被依赖属性修改时，会发送accountForBank属性被修改的通知。此时，我们需要重写NSKeyValueObserving协议的keyPathsForValuesAffectingValueForKey:方法，该方法声明如下：</p>

<pre><code>+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key
</code></pre>

<p>这个方法返回的是一个集合对象，包含了那些影响key指定的属性依赖的属性所对应的字符串。所以对于accountForBank属性，该方法的实现如下：</p>

<p><strong>代码清单9：accountForBank属性的keyPathsForValuesAffectingValueForKey方法的实现</strong></p>

<pre><code>@implementation BankObject

+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key {

    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];

    if ([key isEqualToString:@"accountForBank"]) {

        keyPaths = [keyPaths setByAddingObjectsFromArray:@[@"accountBalance", @"bankCodeEn"]];
    }

    return keyPaths;
}

@end
</code></pre>

<p>我们来再来看看监听accountForBank属性是什么效果：</p>

<p><strong>代码清单10：监听accountForBank属性</strong></p>

<pre><code>PersonObject    *personInstance = [[PersonObject alloc] init];
BankObject      *bankInstance = [[BankObject alloc] init];

[bankInstance addObserver:personInstance forKeyPath:@"accountForBank" options:NSKeyValueObservingOptionNew context:NULL];

bankInstance.accountBalance = 10;
bankInstance.bankCodeEn = @"CCB";
</code></pre>

<p>其输出结果为：</p>

<pre><code>keyPath = accountForBank, change = {
    kind = 1;
    new = "account for (null) is 10";
}, context = (null)
keyPath = accountForBank, change = {
    kind = 1;
    new = "account for CCB is 10";
}, context = (null)
</code></pre>

<p>可以看到，不管是accountBalance还是bankCodeEn被修改了，都会发送accountForBank属性被修改的通知。</p>

<p>需要注意的就是当我们重写+keyPathsForValuesAffectingValueForKey:时，需要去调用super的对应方法，并返回一个包含父类中可能会对key指定属性产生影响的属性集合。</p>

<p>另外，我们还可以实现一个命名为keyPathsForValuesAffecting&lt;Key>的类方法来达到同样的目的，其中<Key>是我们计算属性的名称。所以对于accountForBank属性，还可以如下实现：</p>

<pre><code>+ (NSSet *)keyPathsForValuesAffectingAccountForBank {

    return [NSSet setWithObjects:@"accountBalance", @"bankCodeEn", nil];
}
</code></pre>

<p>两种方法的实现效果是一样的。不过更建议使用后面一种方法，这种方法让依赖关系更加清晰明了。</p>

<h2>集合属性的监听</h2>

<p>keyPathsForValuesAffectingValueForKey:只支持一对一的关系，而不支持一对多的关系，即不支持对集合的处理。</p>

<p>对于集合的KVO，我们需要了解的一点是，KVO旨在观察关系(relationship)而不是集合。对于不可变集合属性，我们更多的是把它当成一个整体来监听，而无法去监听集合中的某个元素的变化；对于可变集合属性，实际上也是当成一个整体，去监听它整体的变化，如添加、删除和替换元素。</p>

<p>在KVC中，我们可以使用<strong>集合代理对象(collection proxy object)</strong>来处理集合相关的操作。我们以数组为例，在我们的BankObject类中有一个departments数组属性，如果我们希望通过集合代理对象来负责响应departments所有的方法，则需要实现以下方法：</p>

<pre><code>-countOf&lt;Key&gt;

// 以下两者二选一
-objectIn&lt;Key&gt;AtIndex:
-&lt;key&gt;AtIndexes:

// 可选（增强性能）
-get&lt;Key&gt;:range:
</code></pre>

<p>因此，我们的实现以下几个方法：</p>

<p><strong>代码清单11：集合代码对象的实现</strong></p>

<pre><code>@implementation BankObject

#pragma mark - 集合代理对象

- (NSUInteger)countOfDepartments {

    return [_departments count];
}

- (id)objectInDepartmentsAtIndex:(NSUInteger)index {

    return [_departments objectAtIndex:index];
}

@end
</code></pre>

<p>实现以上方法之后，对于不可变数组，当我们调用[bankInstance valueForKey:@&ldquo;departments”]的时候，便会返回一个由以上方法来代理所有调用方法的NSArray对象。这个代理数组对象支持所有正常的NSArray调用。换句话说，调用者并不知道返回的是一个真正的NSArray，还是一个代理的数组。</p>

<p>另外，对于可变数组的代理对象，我们需要实现以下几个方法：</p>

<pre><code>// 至少实现一个插入方法和一个删除方法
-insertObject:in&lt;Key&gt;AtIndex:
-removeObjectFrom&lt;Key&gt;AtIndex:
-insert&lt;Key&gt;:atIndexes:
-remove&lt;Key&gt;AtIndexes:

// 可选（增强性能）以下方法二选一
-replaceObjectIn&lt;Key&gt;AtIndex:withObject:
-replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:
</code></pre>

<p>这些方法分别对应插入、删除和替换，有批量操作的，也有只改变一个对象的方法。可以根据实际需要来实现。</p>

<p>另外，对于可变集合，我们通常不使用valueForKey:来获取代理对象，而是使用以下方法：</p>

<pre><code>- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;
</code></pre>

<p>通过这个方法，我们便可以将可变数组与强大的KVO结合在一起。KVO机制能在集合改变的时候把详细的变化放进change字典中。</p>

<p>我们先来看看下面的代码：</p>

<p><strong>代码清单12：使用真正的数组对象监听可变数组属性</strong></p>

<pre><code>BankObject *bankInstance = [[BankObject alloc] init];

PersonObject    *personInstance = [[PersonObject alloc] init];
[bankInstance addObserver:personInstance forKeyPath:@"departments" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];

bankInstance.departments = [[NSMutableArray alloc] init];

[bankInstance.departments addObject:@"departments"];
</code></pre>

<p>其输出为：</p>

<pre><code>keyPath = departments, change = {
    kind = 1;
    new =     (
    );
    old =     (
    );
}, context = (null)
</code></pre>

<p>可以看到通过这种方法，我们获取的是真正的数组，只在departments属性整体被修改时，才会触发KVO，而在添加元素时，并没有触发KVO。</p>

<p>现在我们通过代理集合对象来看看：</p>

<p><strong>代码清单13：使用代理集合对象监听可变数组属性</strong></p>

<pre><code>BankObject *bankInstance = [[BankObject alloc] init];

PersonObject    *personInstance = [[PersonObject alloc] init];
[bankInstance addObserver:personInstance forKeyPath:@"departments" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];

bankInstance.departments = [[NSMutableArray alloc] init];

NSMutableArray *departments = [bankInstance mutableArrayValueForKey:@"departments"];
[departments insertObject:@"departments 0" atIndex:0];
</code></pre>

<p>其输出是：</p>

<pre><code>keyPath = departments, change = {
    kind = 1;
    new =     (
    );
    old =     (
    );
}, context = (null)
keyPath = departments, change = {
    indexes = "&lt;NSIndexSet: 0x7fcd18673150&gt;[number of indexes: 1 (in 1 ranges), indexes: (0)]";
    kind = 2;
    new =     (
        "departments 0"
    );
}, context = (null)
</code></pre>

<p>可以看到，在往数组中添加对象时，也触发了KVO，并将改变的详细信息也写进了change字典。在第二个消息中，kind的值为2，即表示这是一次插入操作。同样，可变数组的删除，替换操作也是一样的。</p>

<p>集合(Set)也有一套对应的方法来实现集合代理对象，包括无序集合与有序集合；而字典则没有，对于字典属性的监听，还是只能作为一个整理来处理。</p>

<p>如果我们想到手动控制集合属性消息的发送，则可以使用上面提到的几个方法，即：</p>

<pre><code>-willChange:valuesAtIndexes:forKey:
-didChange:valuesAtIndexes:forKey:

或

-willChangeValueForKey:withSetMutation:usingObjects:
-didChangeValueForKey:withSetMutation:usingObjects:
</code></pre>

<p>不过得先保证把自动通知关闭，否则每次改变KVO都会被发送两次。</p>

<h2>监听信息</h2>

<p>如果我们想获取一个对象上有哪些观察者正在监听其属性的修改，则可以查看对象的observationInfo属性，其声明如下：</p>

<pre><code>@property void *observationInfo
</code></pre>

<p>可以看到它是一个void指针，指向一个包含所有观察者的一个标识信息对象，这些信息包含了每个监听的观察者，注册时设定的选项等等。我们还是用示例来看看。</p>

<p><strong>代码清单14：observationInfo的使用</strong></p>

<pre><code>PersonObject    *personInstance = [[PersonObject alloc] init];
BankObject      *bankInstance = [[BankObject alloc] init];

[bankInstance addObserver:personInstance forKeyPath:@"bankCodeEn" options:NSKeyValueObservingOptionNew context:NULL];
[bankInstance addObserver:personInstance forKeyPath:@"accountBalance" options:NSKeyValueObservingOptionOld context:NULL];

NSLog(@"%p", personInstance);
NSLog(@"%p", bankInstance);

id info = bankInstance.observationInfo;
NSLog(@"%@", [info description]);
</code></pre>

<p>其输出结果如下：</p>

<pre><code>personInstance = 0x7fdc2369e5e0
bankInstance = 0x7fdc2369d8f0
&lt;NSKeyValueObservationInfo 0x7fdc236a19d0&gt; (
&lt;NSKeyValueObservance 0x7fdc236a17a0: Observer: 0x7fdc2369e5e0, Key path: bankCodeEn, Options: &lt;New: YES, Old: NO, Prior: NO&gt; Context: 0x0, Property: 0x7fdc236a15c0&gt;
&lt;NSKeyValueObservance 0x7fdc236a1960: Observer: 0x7fdc2369e5e0, Key path: accountBalance, Options: &lt;New: NO, Old: YES, Prior: NO&gt; Context: 0x0, Property: 0x7fdc236a1880&gt;
)
</code></pre>

<p>我们可以看到observationInfo指针实际上是指向一个NSKeyValueObservationInfo对象，它包含了指定对象上的所有的监听信息。而每条监听信息而是封装在一个NSKeyValueObservance对象中，从上面可以看到，这个对象中包含消息的观察者、被监听的属性、添加观察者时所设置的一些选项、上下文信息等。</p>

<p>NSKeyValueObservationInfo类及NSKeyValueObservance类都是私有类，我们无法在官方文档中找到这两个类的实现。不过从一些对系统库dump出来的头文件，我们可以对这两个类有一些初步的了解。<a href="https://github.com/a1anyip/iOS-SDK-4.3-Framework-Header-Dump/tree/master/Frameworks/Foundation.framework">这里</a>有一个对iOS SKD 4.3的Foundation.framework的dump头文件，可以找到这两个类的头文件，其中NSKeyValueObservationInfo的头文件信息如下所示：</p>

<pre><code>#import &lt;XXUnknownSuperclass.h&gt; // Unknown library

@class NSArray, NSHashTable;

__attribute__((visibility("hidden")))
@interface NSKeyValueObservationInfo : XXUnknownSuperclass {
@private
    int _retainCountMinusOne;
    NSArray* _observances;
    unsigned _cachedHash;
    BOOL _cachedIsShareable;
    NSHashTable* _observables;
}
-(id)_initWithObservances:(id*)observances count:(unsigned)count;
-(id)retain;
-(oneway void)release;
-(unsigned)retainCount;
-(void)dealloc;
-(unsigned)hash;
-(BOOL)isEqual:(id)equal;
-(id)description;
@end
</code></pre>

<p>可以看到其中有一个数组来存储NSKeyValueObservance对象。</p>

<p>NSKeyValueObservance类的头文件信息如下：</p>

<pre><code>#import "Foundation-Structs.h"
#import &lt;XXUnknownSuperclass.h&gt; // Unknown library

@class NSPointerArray, NSKeyValueProperty, NSObject;

__attribute__((visibility("hidden")))
@interface NSKeyValueObservance : XXUnknownSuperclass {
@private
    int _retainCountMinusOne;
    NSObject* _observer;
    NSKeyValueProperty* _property;
    unsigned _options;
    void* _context;
    NSObject* _originalObservable;
    unsigned _cachedUnrotatedHashComponent;
    BOOL _cachedIsShareable;
    NSPointerArray* _observationInfos;
    auto_weak_callback_block _observerWentAwayCallback;
}
-(id)_initWithObserver:(id)observer property:(id)property options:(unsigned)options context:(void*)context originalObservable:(id)observable;
-(id)retain;
-(oneway void)release;
-(unsigned)retainCount;
-(void)dealloc;
-(unsigned)hash;
-(BOOL)isEqual:(id)equal;
-(id)description;
-(void)observeValueForKeyPath:(id)keyPath ofObject:(id)object change:(id)change context:(void*)context;
@end
</code></pre>

<p>可以看到其中包含了一个监听的基本要素。在此不再做深入分析(没有源代码，深入不下去了啊)。</p>

<p>我们再回到observationInfo属性本身来。在文档中，对这个属性的描述有这样一段话：</p>

<pre><code>The default implementation of this method retrieves the information from a global
dictionary keyed by the receiver’s pointers.
</code></pre>

<p>即这个方法的默认实现是以对象的指针作为key，从一个全局的字典中获取信息。由此，我们可以理解为，KVO的信息是存储在一个全局字典中，而不是存储在对象本身。这类似于Notification，所有关于通知的信息都是放在NSNotificationCenter中。</p>

<p>不过，为了提高效率，我们可以重写observationInfo属性的set和get方法，以将这个不透明的数据指针存储到一个实例变量中。但是，在重写时，我们不应该尝试去向这些数据发送一个Objective-C消息，包括retain和release。</p>

<h2>KVO的实现机制</h2>

<p>【本来这一小节是想放在另一篇总结中来写的，但后来觉得还是放在这里比较合适，所以就此添加上】</p>

<p>了解了NSKeyValueObserving所提供的功能后，我们再来看看KVO的实现机制，以便更深入地的理解KVO。</p>

<p>KVO据我所查还没有开源(若哪位大大有查到源代码，还烦请告知)，所以我们无法从源代码的层面来分析它的实现。不过<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html">Mike Ash</a>的博文(译文见参考文献4)为我们解开了一些谜团。</p>

<p>基本的思路是：Objective-C依托于强大的run time机制来实现KVO。当我们第一次观察某个对象的属性时，run time会创建一个新的继承自这个对象的class的subclass。在这个新的subclass中，它会重写所有被观察的key的setter，然后将object的isa指针指向新创建的class(这个指针告诉Objective-C运行时某个object到底是什么类型的)。所以object神奇地变成了新的子类的实例。</p>

<p>嗯，让我们通过代码来看看实际的实现：</p>

<p><strong>代码清单15：探究KVO的实现机制</strong></p>

<pre><code>// 辅助方法
static NSArray *ClassMethodNames(Class c) {

    NSMutableArray *array = [NSMutableArray array];

    unsigned int methodCount = 0;
    Method *methodList = class_copyMethodList(c, &amp;methodCount);
    unsigned int i;
    for (i = 0; i &lt; methodCount; i++) {
        [array addObject:NSStringFromSelector(method_getName(methodList[i]))];
    }

    free(methodList);

    return array;
}

static void PrintDescription(NSString *name, id obj) {

    struct objc_object *objcet = (__bridge struct objc_object *)obj;

    Class cls = objcet-&gt;isa;

    NSString *str = [NSString stringWithFormat:@"%@: %@\n\tNSObject class %s\n\tlibobjc class %s : super class %s\n\timplements methods &lt;%@&gt;",
                     name,
                     obj,
                     class_getName([obj class]),
                     class_getName(cls),
                     class_getName(class_getSuperclass(cls)),
                     [ClassMethodNames(cls) componentsJoinedByString:@", "]];
    printf("%s\n", [str UTF8String]);
}

// 测试代码
BankObject *bankInstance1 = [[BankObject alloc] init];
BankObject *bankInstance2 = [[BankObject alloc] init];

PersonObject *personInstance = [[PersonObject alloc] init];

[bankInstance2 addObserver:personInstance forKeyPath:@"accountBalance" options:NSKeyValueObservingOptionNew context:NULL];

PrintDescription(@"bankInstance1", bankInstance1);
PrintDescription(@"bankInstance2", bankInstance2);

printf("Using libobjc functions, normal setAccountBalance: is %p, overridden setAccountBalance: is %p", method_getImplementation(class_getInstanceMethod(object_getClass(bankInstance2), @selector(setAccountBalance:))),
       method_getImplementation(class_getInstanceMethod(object_getClass(bankInstance1), @selector(setAccountBalance:))));
</code></pre>

<p>这段代码的输出如下：</p>

<pre><code>bankInstance1: &lt;BankObject: 0x7f9e8ae3cf60&gt;
    NSObject class BankObject
    libobjc class BankObject : super class NSObject
    implements methods &lt;accountBalance, setAccountBalance:, bankCodeEn, setBankCodeEn:, departments, setDepartments:&gt;

bankInstance2: &lt;BankObject: 0x7f9e8ae3cfc0&gt;
    NSObject class BankObject
    libobjc class NSKVONotifying_BankObject : super class BankObject
    implements methods &lt;setAccountBalance:, class, dealloc, _isKVOA&gt;

Using libobjc functions, normal setAccountBalance: is 0x1013cec17, overridden setAccountBalance: is 0x10129fe50
</code></pre>

<p>从输出中可以看到，bankInstance2监听accountBalance属性后，其实际上所属的类已经不是BankObject了，而是继承自BankObject的NSKVONotifying_BankObject类。同时，NSKVONotifying_BankObject类重写了setAccountBalance方法，这个方法将实现如何通知观察者们的操作。当改变accountBalance属性时，就会调用被重写的setAccountBalance方法，并通过这个方法来发送通知。</p>

<p>另外我们也可以看到bankInstance2对象的打印[bankInstance2 class]时，返回的仍然是BankObject。这是苹果故意而为之，他们不希望这个机制暴露在外面。所以除了重写相应的setter，所以动态生成的NSKVONotifying_BankObject类还重写了class方法，让它返回原先的类。</p>

<h2>小结</h2>

<p>KVO作为Objective-C中两个对象间通信机制中的一种，提供了一种非常强大的机制。在经典的MVC架构中，控制器需要确保视图与模型的同步，当model对象改变时，视图应该随之改变以反映模型的变化；当用户和控制器交互的时候，模型也应该做出相应的改变。而KVO便为我们提供了这样一种同步机制：我们让控制器去监听一个model对象属性的改变，并根据这种改变来更新我们的视图。所有，有效地使用KVO，对我们应用的开发意义重大。</p>

<p>别话：对KVO的总结感觉还是意犹未尽，总感觉缺少点什么，特别是在对集合这一块的处理。还请大家多多提供指点。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/#//apple_ref/occ/instm/NSObject/observationInfo">NSKeyValueObserving Protocol Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">Key-Value Observing Programming Guide</a></li>
<li><a href="https://github.com/a1anyip/iOS-SDK-4.3-Framework-Header-Dump">iOS-SDK-4.3-Framework-Header-Dump</a></li>
<li><a href="http://objccn.io/issue-7-3/">KVC 和 KVO</a></li>
<li><a href="http://www.appcoda.com/understanding-key-value-observing-coding/">Understanding Key-Value Observing and Coding</a></li>
<li><a href="http://www.cocoachina.com/ios/20140107/7667.html">KVO的内部实现</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[源码篇：MBProgressHUD]]></title>
    <link href="http://southpeak.github.io/blog/2015/03/24/yuan-ma-pian-:mbprogresshud/"/>
    <updated>2015-03-24T20:41:51+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/03/24/yuan-ma-pian-:mbprogresshud</id>
    <content type="html"><![CDATA[<p>源码来源：<a href="https://github.com/jdg/MBProgressHUD">https://github.com/jdg/MBProgressHUD</a></p>

<p>版本：0.9.1</p>

<p>MBProgressHUD是一个显示HUD窗口的第三方类库，用于在执行一些后台任务时，在程序中显示一个表示进度的loading视图和两个可选的文本提示的HUD窗口。我想最多是应用在加载网络数据的时候。其实苹果官方自己有一个带有此功能的类UIProgressHUD，只不过它是私有的，现在不让用。至于实际的效果，可以看看github上工程给出的几张图例(貌似我这经常无法单独打开图片，所以就不在这贴图片了)，也可以运行一下Demo。</p>

<p>具体用法我们就不多说了，参考github上的说明就能用得很顺的。本文主要还是从源码的角度来分析一下它的具体实现。</p>

<h2>模式</h2>

<p>在分析实现代码之前，我们先来看看MBProgressHUD中定义的MBProgressHUDMode枚举。它用来表示HUD窗口的模式，即我们从效果图中看到的几种显示样式。其具体定义如下：</p>

<pre><code>typedef enum {
    // 使用UIActivityIndicatorView来显示进度，这是默认值
    MBProgressHUDModeIndeterminate,

    // 使用一个圆形饼图来作为进度视图
    MBProgressHUDModeDeterminate,

    // 使用一个水平进度条
    MBProgressHUDModeDeterminateHorizontalBar,

    // 使用圆环作为进度条
    MBProgressHUDModeAnnularDeterminate,

    // 显示一个自定义视图，通过这种方式，可以显示一个正确或错误的提示图
    MBProgressHUDModeCustomView,

    // 只显示文本
    MBProgressHUDModeText

} MBProgressHUDMode;
</code></pre>

<p>通过设置MBProgressHUD的模式，我们可以使用MBProgressHUD自定义的表示进度的视图来满足我们的需求，也可以自定义这个进度视图，当然还可以只显示文本。在下面我们会讨论源码中是如何使用这几个值的。</p>

<h2>外观</h2>

<p>我们先来了解一下MBProgressHUD的基本组成。一个MBProgressHUD视图主要由四个部分组成：</p>

<ol>
<li>loading动画视图(在此做个统称，当然这个区域可以是自定义的一个UIImageView视图)。这个视图由我们设定的模式值决定，可以是菊花、进度条，也可以是我们自定义的视图；</li>
<li>标题文本框(label)：主要用于显示提示的主题信息。这个文本框是可选的，通常位于loading动画视图的下面，且它是单行显示。它会根据labelText属性来自适应文本的大小(有一个长度上限)，如果过长，则超出的部分会显示为&#8221;&hellip;&ldquo;；</li>
<li>详情文本框(detailsLabel)。如果觉得标题不够详细，或者有附属信息，就可以将详细信息放在这里面显示。该文本框对应的是显示detailsLabelText属性的值，它是可以多行显示的。另外，详情的显示还依赖于labelText属性的设置，只有labelText属性被设置了，且不为空串，才会显示detailsLabel；</li>
<li>HUD背景框。主要是作为上面三个部分的一个背景，用来突出上面三部分。</li>
</ol>


<p>为了让我们更好地自定义这几个部分，MBProgressHUD还提供了一些属性，我们简单了解一下：</p>

<pre><code>// 背景框的透明度，默认值是0.8
@property (assign) float opacity;

// 背景框的颜色
// 需要注意的是如果设置了这个属性，则opacity属性会失效，即不会有半透明效果
@property (MB_STRONG) UIColor *color;

// 背景框的圆角半径。默认值是10.0
@property (assign) float cornerRadius;

// 标题文本的字体及颜色
@property (MB_STRONG) UIFont* labelFont;
@property (MB_STRONG) UIColor* labelColor;

// 详情文本的字体及颜色
@property (MB_STRONG) UIFont* detailsLabelFont;
@property (MB_STRONG) UIColor* detailsLabelColor;

// 菊花的颜色，默认是白色
@property (MB_STRONG) UIColor *activityIndicatorColor;
</code></pre>

<p>通过以上属性，我们可以根据自己的需要来设置这几个部分的外观。</p>

<p>另外还有一个比较有意思的属性是dimBackground，用于为HUD窗口的视图区域覆盖上一层径向渐变(radial gradient)层，其定义如下：</p>

<pre><code>@property (assign) BOOL dimBackground;
</code></pre>

<p>让我们来看看通过它，MBProgressHUD都做了些什么。代码如下：</p>

<pre><code>- (void)drawRect:(CGRect)rect {

    ...

    if (self.dimBackground) {
        //Gradient colours
        size_t gradLocationsNum = 2;
        CGFloat gradLocations[2] = {0.0f, 1.0f};
        CGFloat gradColors[8] = {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.75f}; 
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, gradColors, gradLocations, gradLocationsNum);
        CGColorSpaceRelease(colorSpace);

        //Gradient center
        CGPoint gradCenter= CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2);
        //Gradient radius
        float gradRadius = MIN(self.bounds.size.width , self.bounds.size.height) ;

        // 由中心向四周绘制渐变
        CGContextDrawRadialGradient (context, gradient, gradCenter,
                                     0, gradCenter, gradRadius,
                                     kCGGradientDrawsAfterEndLocation);
        CGGradientRelease(gradient);
    }
    ... 
}
</code></pre>

<p>这段代码由中心向MBProgressHUD视图的四周绘制了一个渐变层。当然，这里的颜色值是写死的，我们无法自行定义。有兴趣的话，大家可以将这个属性设置为YES，看看实际的效果。</p>

<h2>创建、布局与绘制</h2>

<p>除了继承自UIView的-initWithFrame:初始化方法，MBProgressHUD还为我们提供了两个初始化方法，如下所示：</p>

<pre><code>- (id)initWithWindow:(UIWindow *)window;

- (id)initWithView:(UIView *)view;
</code></pre>

<p>这两个方法分别传入一个UIWindow对象和一个UIView对象。传入的视图对象仅仅是做为MBProgressHUD视图定义其frame属性的参照，而不会直接将MBProgressHUD视图添加到传入的视图对象上。这个添加操作还得我们自行处理(当然，MBProgressHUD还提供了几个便捷的类方法，我们下面会说明)。</p>

<p>MBProgressHUD提供了几个属性，可以让我们控制HUD的布局，这些属性主要有以下几个：</p>

<pre><code>// HUD相对于父视图中心点的x轴偏移量和y轴偏移量
@property (assign) float xOffset;
@property (assign) float yOffset;

// HUD各元素与HUD边缘的间距
@property (assign) float margin;

// HUD背景框的最小大小
@property (assign) CGSize minSize;

// HUD的实际大小
@property (atomic, assign, readonly) CGSize size;

// 是否强制HUD背景框宽高相等
@property (assign, getter = isSquare) BOOL square;
</code></pre>

<p>需要注意的是，MBProgressHUD视图会充满其父视图的frame内，为此，在MBProgressHUD的layoutSubviews方法中，还专门做了处理，如下代码所示：</p>

<pre><code>- (void)layoutSubviews {
    [super layoutSubviews];

    // Entirely cover the parent view
    UIView *parent = self.superview;
    if (parent) {
        self.frame = parent.bounds;
    }

    ...
}
</code></pre>

<p>也因此，当MBProgressHUD显示时，它也会屏蔽父视图的各种交互操作。</p>

<p>在布局的过程中，会先根据我们要显示的视图计算出容纳这些视图所需要的总的宽度和高度。当然，会设置一个最大值。我们截取其中一段来看看：</p>

<pre><code>CGRect bounds = self.bounds;

...

CGFloat remainingHeight = bounds.size.height - totalSize.height - kPadding - 4 * margin; 
CGSize maxSize = CGSizeMake(maxWidth, remainingHeight);
CGSize detailsLabelSize = MB_MULTILINE_TEXTSIZE(detailsLabel.text, detailsLabel.font, maxSize, detailsLabel.lineBreakMode);
totalSize.width = MAX(totalSize.width, detailsLabelSize.width);
totalSize.height += detailsLabelSize.height;
if (detailsLabelSize.height &gt; 0.f &amp;&amp; (indicatorF.size.height &gt; 0.f || labelSize.height &gt; 0.f)) {
    totalSize.height += kPadding;
}

totalSize.width += 2 * margin;
totalSize.height += 2 * margin;
</code></pre>

<p>之后，就开始从上到下放置各个视图。在布局代码的最后，计算了一个size值，这是为后面绘制背景框做准备的。</p>

<p>在上面的布局代码中，主要是处理了loading动画视图、标题文本框和详情文本框，而HUD背景框主要是在drawRect:中来绘制的。背景框的绘制代码如下：</p>

<pre><code>// Center HUD
CGRect allRect = self.bounds;
// Draw rounded HUD backgroud rect
CGRect boxRect = CGRectMake(round((allRect.size.width - size.width) / 2) + self.xOffset,
                            round((allRect.size.height - size.height) / 2) + self.yOffset, size.width, size.height);
float radius = self.cornerRadius;
CGContextBeginPath(context);
CGContextMoveToPoint(context, CGRectGetMinX(boxRect) + radius, CGRectGetMinY(boxRect));
CGContextAddArc(context, CGRectGetMaxX(boxRect) - radius, CGRectGetMinY(boxRect) + radius, radius, 3 * (float)M_PI / 2, 0, 0);
CGContextAddArc(context, CGRectGetMaxX(boxRect) - radius, CGRectGetMaxY(boxRect) - radius, radius, 0, (float)M_PI / 2, 0);
CGContextAddArc(context, CGRectGetMinX(boxRect) + radius, CGRectGetMaxY(boxRect) - radius, radius, (float)M_PI / 2, (float)M_PI, 0);
CGContextAddArc(context, CGRectGetMinX(boxRect) + radius, CGRectGetMinY(boxRect) + radius, radius, (float)M_PI, 3 * (float)M_PI / 2, 0);
CGContextClosePath(context);
CGContextFillPath(context);
</code></pre>

<p>这是最平常的绘制操作，在此不多做解释。</p>

<p>我们上面讲过MBProgressHUD提供了几种窗口模式，这几种模式的主要区别在于loading动画视图的展示。默认情况下，使用的是菊花(MBProgressHUDModeIndeterminate)。我们可以通过设置以下属性，来改变loading动画视图：</p>

<pre><code>@property (assign) MBProgressHUDMode mode;
</code></pre>

<p>对于其它几种模式，MBProgressHUD专门我们提供了几个视图类。如果是进度条模式(MBProgressHUDModeDeterminateHorizontalBar)，则使用的是MBBarProgressView类；如果是饼图模式(MBProgressHUDModeDeterminate)或环形模式(MBProgressHUDModeAnnularDeterminate)，则使用的是MBRoundProgressView类。上面这两个类的主要操作就是在drawRect:中根据一些进度参数来绘制形状，大家可以自己详细看一下。</p>

<p>当然，我们还可以自定义loading动画视图，此时选择的模式是MBProgressHUDModeCustomView。或者不显示loading动画视图，而只显示文本框(MBProgressHUDModeText)。</p>

<p>具体显示哪一种loading动画视图，是在-updateIndicators方法中来处理的，其实现如下所示：</p>

<pre><code>- (void)updateIndicators {

    BOOL isActivityIndicator = [indicator isKindOfClass:[UIActivityIndicatorView class]];
    BOOL isRoundIndicator = [indicator isKindOfClass:[MBRoundProgressView class]];

    if (mode == MBProgressHUDModeIndeterminate) {
        ...
    }
    else if (mode == MBProgressHUDModeDeterminateHorizontalBar) {
        // Update to bar determinate indicator
        [indicator removeFromSuperview];
        self.indicator = MB_AUTORELEASE([[MBBarProgressView alloc] init]);
        [self addSubview:indicator];
    }
    else if (mode == MBProgressHUDModeDeterminate || mode == MBProgressHUDModeAnnularDeterminate) {
        if (!isRoundIndicator) {
            ...
        }
        if (mode == MBProgressHUDModeAnnularDeterminate) {
            [(MBRoundProgressView *)indicator setAnnular:YES];
        }
    } 
    else if (mode == MBProgressHUDModeCustomView &amp;&amp; customView != indicator) {
        ...
    } else if (mode == MBProgressHUDModeText) {
        ...
    }
}
</code></pre>

<h2>显示与隐藏</h2>

<p>MBRoundProgressView为我们提供了丰富的显示与隐藏HUD窗口的。在分析这些方法之前，我们先来看看MBProgressHUD为显示与隐藏提供的一些属性：</p>

<pre><code>// HUD显示和隐藏的动画类型
@property (assign) MBProgressHUDAnimation animationType;

// HUD显示的最短时间。设置这个值是为了避免HUD显示后立即被隐藏。默认值为0
@property (assign) float minShowTime;

// 这个属性设置了一个宽限期，它是在没有显示HUD窗口前被调用方法可能运行的时间。
// 如果被调用方法在宽限期内执行完，则HUD不会被显示。
// 这主要是为了避免在执行很短的任务时，去显示一个HUD窗口。
// 默认值是0。只有当任务状态是已知时，才支持宽限期。具体我们看实现代码。
@property (assign) float graceTime;

// 这是一个标识位，标明执行的操作正在处理中。这个属性是配合graceTime使用的。
// 如果没有设置graceTime，则这个标识是没有太大意义的。在使用showWhileExecuting:onTarget:withObject:animated:方法时，
// 会自动去设置这个属性为YES，其它情况下都需要我们自己手动设置。
@property (assign) BOOL taskInProgress;

// 隐藏时是否将HUD从父视图中移除，默认是NO。
@property (assign) BOOL removeFromSuperViewOnHide;

// 进度指示器，从0.0到1.0，默认值为0.0
@property (assign) float progress;

// 在HUD被隐藏后的回调
@property (copy) MBProgressHUDCompletionBlock completionBlock;
</code></pre>

<p>以上这些属性都还好理解，可能需要注意的就是graceTime和taskInProgress的配合使用。在下面我们将会看看这两个属性的用法。</p>

<p>对于显示操作，最基本的就是-show:方法(其它几个显示方法都会调用该方法来显示HUD窗口)，我们先来看看它的实现，</p>

<pre><code>- (void)show:(BOOL)animated {
    useAnimation = animated;
    // If the grace time is set postpone the HUD display
    if (self.graceTime &gt; 0.0) {
        self.graceTimer = [NSTimer scheduledTimerWithTimeInterval:self.graceTime target:self 
                           selector:@selector(handleGraceTimer:) userInfo:nil repeats:NO];
    } 
    // ... otherwise show the HUD imediately 
    else {
        [self showUsingAnimation:useAnimation];
    }
}
</code></pre>

<p>可以看到，如果我们没有设置graceTime属性，则会立即显示HUD；而如果设置了graceTime，则会创建一个定时器，并让显示操作延迟到graceTime所设定的时间再执行，而-handleGraceTimer:实现如下：</p>

<pre><code>- (void)handleGraceTimer:(NSTimer *)theTimer {
    // Show the HUD only if the task is still running
    if (taskInProgress) {
        [self showUsingAnimation:useAnimation];
    }
}
</code></pre>

<p>可以看到，只有在设置了taskInProgress标识位为YES的情况下，才会去显示HUD窗口。所以，如果我们要自己调用-show:方法的话，需要酌情考虑设置taskInProgress标识位。</p>

<p>除了-show:方法以外，MBProgressHUD还为我们提供了一组显示方法，可以让我们在显示HUD的同时，执行一些后台任务，我们在此主要介绍两个。其中一个是-showWhileExecuting:onTarget:withObject:animated:，它是基于target-action方式的调用，在执行一个后台任务时显示HUD，等后台任务执行完成后再隐藏HUD，具体实现如下所示：</p>

<pre><code>- (void)showWhileExecuting:(SEL)method onTarget:(id)target withObject:(id)object animated:(BOOL)animated {
    methodForExecution = method;
    targetForExecution = MB_RETAIN(target);
    objectForExecution = MB_RETAIN(object); 
    // Launch execution in new thread
    self.taskInProgress = YES;
    [NSThread detachNewThreadSelector:@selector(launchExecution) toTarget:self withObject:nil];
    // Show HUD view
    [self show:animated];
}

- (void)launchExecution {
    @autoreleasepool {
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        // Start executing the requested task
        [targetForExecution performSelector:methodForExecution withObject:objectForExecution];
#pragma clang diagnostic pop
        // Task completed, update view in main thread (note: view operations should
        // be done only in the main thread)
        [self performSelectorOnMainThread:@selector(cleanUp) withObject:nil waitUntilDone:NO];
    }
}
</code></pre>

<p>可以看到，-showWhileExecuting:onTarget:withObject:animated:首先将taskInProgress属性设置为YES，这样在调用-show:方法时，即使设置了graceTime，也确保能在任务完成之前显示HUD。然后开启一个新线程，来异步执行我们的后台任务，最后去显示HUD。</p>

<p>而在异步调用方法-launchExecution中，线程首先是维护了自己的一个@autoreleasepool，所以在我们自己的方法中，就不需要再去维护一个@autoreleasepool了。之后是去执行我们的任务，在任务完成之后，再回去主线程去执行清理操作，并隐藏HUD窗口。</p>

<p>另一个显示方法是-showAnimated:whileExecutingBlock:onQueue:completionBlock:，它是基于GCD的调用，当block中的任务在指定的队列中执行时，显示HUD窗口，任务完成之后执行completionBlock操作，最后隐藏HUD窗口。我们来看看它的具体实现：</p>

<pre><code>- (void)showAnimated:(BOOL)animated whileExecutingBlock:(dispatch_block_t)block onQueue:(dispatch_queue_t)queue
     completionBlock:(MBProgressHUDCompletionBlock)completion {
    self.taskInProgress = YES;
    self.completionBlock = completion;
    dispatch_async(queue, ^(void) {
        block();
        dispatch_async(dispatch_get_main_queue(), ^(void) {
            [self cleanUp];
        });
    });
    [self show:animated];
}
</code></pre>

<p>这个方法也是首先将taskInProgress属性设置为YES，然后开启一个线程去执行block任务，最后主线程去执行清理操作，并隐藏HUD窗口。</p>

<p>对于HUD的隐藏，MBProgressHUD提供了两个方法，一个是-hide:，另一个是-hide:afterDelay:，后者基于前者，所以我们主要来看看-hide:的实现：</p>

<pre><code>- (void)hide:(BOOL)animated {
    useAnimation = animated;
    // If the minShow time is set, calculate how long the hud was shown,
    // and pospone the hiding operation if necessary
    if (self.minShowTime &gt; 0.0 &amp;&amp; showStarted) {
        NSTimeInterval interv = [[NSDate date] timeIntervalSinceDate:showStarted];
        if (interv &lt; self.minShowTime) {
            self.minShowTimer = [NSTimer scheduledTimerWithTimeInterval:(self.minShowTime - interv) target:self 
                                selector:@selector(handleMinShowTimer:) userInfo:nil repeats:NO];
            return;
        } 
    }
    // ... otherwise hide the HUD immediately
    [self hideUsingAnimation:useAnimation];
}
</code></pre>

<p>我们可以看到，在设置了minShowTime属性并且已经显示了HUD窗口的情况下，会去判断显示的时间是否小于minShowTime指定的时间，如果是，则会开启一个定时器，等到显示的时间到了minShowTime所指定的时间，才会去隐藏HUD窗口；否则会直接去隐藏HUD窗口。</p>

<p>隐藏的实际操作主要是去做了些清理操作，包括根据设定的removeFromSuperViewOnHide值来执行是否从父视图移除HUD窗口，以及执行completionBlock操作，还有就是执行代理的hudWasHidden:方法。这些操作是在私有方法-done里面执行的，实现如下：</p>

<pre><code>- (void)done {
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    isFinished = YES;
    self.alpha = 0.0f;
    if (removeFromSuperViewOnHide) {
        [self removeFromSuperview];
    }
#if NS_BLOCKS_AVAILABLE
    if (self.completionBlock) {
        self.completionBlock();
        self.completionBlock = NULL;
    }
#endif
    if ([delegate respondsToSelector:@selector(hudWasHidden:)]) {
        [delegate performSelector:@selector(hudWasHidden:) withObject:self];
    }
}
</code></pre>

<h2>其它</h2>

<p>MBProgressHUD的一些主要的代码差不多已经分析完了，最后还有些边边角角的地方，一起来看看。</p>

<h3>显示和隐藏的便捷方法</h3>

<p>除了上面描述的实例方法之外，MBProgressHUD还为我们提供了几个便捷显示和隐藏HUD窗口的方法，如下所示：</p>

<pre><code>+ (MB_INSTANCETYPE)showHUDAddedTo:(UIView *)view animated:(BOOL)animated

+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated

+ (NSUInteger)hideAllHUDsForView:(UIView *)view animated:(BOOL)animated
</code></pre>

<p>方法的签名已经很能说明问题了，在此不多描述。</p>

<h3>部分属性值的设置</h3>

<p>对于部分属性(主要是&#8221;外观&#8221;一节中针对菊花、标题文本框和详情文本框的几个属性值)，为了在设置将这些属性时修改对应视图的属性，并没有直接为每个属性生成一个setter，而是通过KVO来监听这些属性值的变化，再将这些值赋值给视图的对应属性，如下所示：</p>

<pre><code>// 监听的属性数组
- (NSArray *)observableKeypaths {
    return [NSArray arrayWithObjects:@"mode", @"customView", @"labelText", @"labelFont", @"labelColor", ..., nil];
}

// 注册KVO
- (void)registerForKVO {
    for (NSString *keyPath in [self observableKeypaths]) {
        [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:NULL];
    }
}

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
    if (![NSThread isMainThread]) {
        [self performSelectorOnMainThread:@selector(updateUIForKeypath:) withObject:keyPath waitUntilDone:NO];
    } else {
        [self updateUIForKeypath:keyPath];
    }
}

- (void)updateUIForKeypath:(NSString *)keyPath {
    if ([keyPath isEqualToString:@"mode"] || [keyPath isEqualToString:@"customView"] ||
        [keyPath isEqualToString:@"activityIndicatorColor"]) {
        [self updateIndicators];
    } else if ([keyPath isEqualToString:@"labelText"]) {
        label.text = self.labelText;
    } 

    ...

    [self setNeedsLayout];
    [self setNeedsDisplay];
}
</code></pre>

<h3>代理</h3>

<p>MBProgressHUD还为我们提供了一个代理MBProgressHUDDelegate，这个代理中只提供了一个方法，即：</p>

<pre><code>- (void)hudWasHidden:(MBProgressHUD *)hud;
</code></pre>

<p>这个代理方法是在隐藏HUD窗口后调用，如果此时我们需要在我们自己的实现中执行某些操作，则可以实现这个方法。</p>

<h2>问题</h2>

<p>MBProgressHUD为我们提供了一个HUD窗口的很好的实现，不过个人在使用过程中，觉得它给我们提供的交互功能太少。其代理只提供了一个-hudWasHidden:方法，而且我们也无法通过点击HUD来执行一些操作。在现实的需求中，可能存在这种情况：比如一个网络操作，在发送请求等待响应的过程中，我们会显示一个HUD窗口以显示一个loading框。但如果我们想在等待响应的过程中，在当前视图中取消这个网络请求，就没有相应的处理方式，MBProgressHUD没有为我们提供这样的交互操作。当然这时候，我们可以根据自己的需求来修改源码。</p>

<h2>与SVProgressHUD的对比</h2>

<p>与MBProgressHUD类似，SVProgressHUD类库也为我们提供了在视图中显示一个HUD窗口的功能。两者的基本思路是差不多的，差别更多的是在实现细节上。相对于MBProgressHUD来说，SVProgressHUD的实现有以下几点不同：</p>

<ol>
<li>SVProgressHUD类对外提供的都是类方法，包括显示、隐藏、和视图属性设置都是使用类方法来操作。其内部实现为一个单例对象，类方法实际是针对这个单例对象来操作的。</li>
<li>SVProgressHUD主要包含三部分：loading视图、提示文本框和背景框，没有详情文本框。</li>
<li>SVProgressHUD默认提供了正确、错误和信息三种状态视图(与loading视图同一位置，根据需要来设置)。当然MBProgressHUD中，也可以自定义视图(customView)来显示相应的状态视图。</li>
<li>SVProgressHUD为我们提供了更多的交互操作，包括点击事件、显示事件及隐藏事件。不过这些都是通过通知的形式向外发送，所以我们需要自己去监听这些事件。</li>
<li>SVProgressHUD中一些loading动画是以Layer动画的形式来实现的。</li>
</ol>


<p>SVProgressHUD的实现细节还未详细去看，有兴趣的读者可以去研究一下。这两个HUD类库各有优点，大家在使用时，可根据自己的需要和喜好来选择。</p>

<h2>小结</h2>

<p>总体来说，MBProgressHUD的代码相对朴实，简单易懂，没有什么花哨难懂的东西。就技术点而言，也没有太多复杂的技术，都是我们常用的一些东西。就使用而言，也是挺方便的，参考一下github上的使用指南就能很快上手。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSNotificationCenter]]></title>
    <link href="http://southpeak.github.io/blog/2015/03/20/nsnotificationcenter/"/>
    <updated>2015-03-20T17:45:28+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/03/20/nsnotificationcenter</id>
    <content type="html"><![CDATA[<p>一个NSNotificationCenter对象(通知中心)提供了在程序中广播消息的机制，它实质上就是一个通知分发表。这个分发表负责维护为各个通知注册的观察者，并在通知到达时，去查找相应的观察者，将通知转发给他们进行处理。</p>

<p>本文主要了整理了一下NSNotificationCenter的使用及需要注意的一些问题，并提出了一些未解决的问题，希望能在此得到解答。</p>

<h2>获取通知中心</h2>

<p>每个程序都会有一个默认的通知中心。为此，NSNotificationCenter提供了一个类方法来获取这个通知中心：</p>

<pre><code>+ (NSNotificationCenter *)defaultCenter
</code></pre>

<p>获取了这个默认的通知中心对象后，我们就可以使用它来处理通知相关的操作了，包括注册观察者，移除观察者、发送通知等。</p>

<p>通常如果不是出于必要，我们一般都使用这个默认的通知中心，而不自己创建维护一个通知中心。</p>

<h2>添加观察者</h2>

<p>如果想让对象监听某个通知，则需要在通知中心中将这个对象注册为通知的观察者。早先，NSNotificationCenter提供了以下方法来添加观察者：</p>

<pre><code>- (void)addObserver:(id)notificationObserver
           selector:(SEL)notificationSelector
               name:(NSString *)notificationName
             object:(id)notificationSender
</code></pre>

<p>这个方法带有4个参数，分别指定了通知的观察者、处理通知的回调、通知名及通知的发送对象。这里需要注意几个问题：</p>

<ol>
<li>notificationObserver不能为nil。</li>
<li>notificationSelector回调方法有且只有一个参数(NSNotification对象)。</li>
<li>如果notificationName为nil，则会接收所有的通知(如果notificationSender不为空，则接收所有来自于notificationSender的所有通知)。如代码清单1所示。</li>
<li>如果notificationSender为nil，则会接收所有notificationName定义的通知；否则，接收由notificationSender发送的通知。</li>
<li>监听同一条通知的多个观察者，在通知到达时，它们执行回调的顺序是不确定的，所以我们不能去假设操作的执行会按照添加观察者的顺序来执行。</li>
</ol>


<p>对于以上几点，我们来重点关注一下第3条。以下代码演示了当我们的notificationName设置为nil时，通知的监听情况。</p>

<p><strong>代码清单1：添加一个Observer，其中notificationName为nil</strong></p>

<pre><code>@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:nil object:nil];

    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"notification = %@", notification.name);
}

@end
</code></pre>

<p>运行后的输出结果如下：</p>

<pre><code>notification = TestNotification
notification = UIWindowDidBecomeVisibleNotification
notification = UIWindowDidBecomeKeyNotification
notification = UIApplicationDidFinishLaunchingNotification
notification = _UIWindowContentWillRotateNotification
notification = _UIApplicationWillAddDeactivationReasonNotification
notification = _UIApplicationDidRemoveDeactivationReasonNotification
notification = UIDeviceOrientationDidChangeNotification
notification = _UIApplicationDidRemoveDeactivationReasonNotification
notification = UIApplicationDidBecomeActiveNotification
</code></pre>

<p>可以看出，我们的对象基本上监听了测试程序启动后的所示消息。当然，我们很少会去这么做。</p>

<p>而对于第4条，使用得比较多的场景是监听UITextField的修改事件，通常我们在一个ViewController中，只希望去监听当前视图中的UITextField修改事件，而不希望监听所有UITextField的修改事件，这时我们就可以将当前页面的UITextField对象指定为notificationSender。</p>

<p>在iOS 4.0之后，NSNotificationCenter为了跟上时代，又提供了一个以block方式实现的添加观察者的方法，如下所示：</p>

<pre><code>- (id&lt;NSObject&gt;)addObserverForName:(NSString *)name
                            object:(id)obj
                             queue:(NSOperationQueue *)queue
                        usingBlock:(void (^)(NSNotification *note))block
</code></pre>

<p>大家第一次看到这个方法时是否会有这样的疑问：观察者呢？参数中并没有指定具体的观察者，那谁是观察者呢？实际上，与前一个方法不同的是，前者使用一个现存的对象作为观察者，而这个方法会创建一个匿名的对象作为观察者(即方法返回的id&lt;NSObject>对象)，这个匿名对象会在指定的队列(queue)上去执行我们的block。</p>

<p>这个方法的优点在于添加观察者的操作与回调处理操作的代码更加紧凑，不需要拼命滚动鼠标就能直接找到处理代码，简单直观。这个方法也有几个地方需要注意：</p>

<ol>
<li>name和obj为nil时的情形与前面一个方法是相同的。</li>
<li>如果queue为nil，则消息是默认在post线程中同步处理，即通知的post与转发是在同一线程中；但如果我们指定了操作队列，情况就变得有点意思了，我们一会再讲。</li>
<li>block块会被通知中心拷贝一份(执行copy操作)，以在堆中维护一个block对象，直到观察者被从通知中心中移除。所以，应该特别注意在block中使用外部对象，避免出现对象的循环引用，这个我们在下面将举例说明。</li>
<li>如果一个给定的通知触发了多个观察者的block操作，则这些操作会在各自的Operation Queue中被并发执行。所以我们不能去假设操作的执行会按照添加观察者的顺序来执行。</li>
<li>该方法会返回一个表示观察者的对象，记得在不用时释放这个对象。</li>
</ol>


<p>下面我们重点说明一下第2点和第3点。</p>

<p>关于第2点，当我们指定一个Operation Queue时，不管通知是在哪个线程中post的，都会在Operation Queue所属的线程中进行转发，如代码清单2所示：</p>

<p><strong>代码清单2：在指定队列中接收通知</strong></p>

<pre><code>@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [[NSNotificationCenter defaultCenter] addObserverForName:TEST_NOTIFICATION object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *note) {

        NSLog(@"receive thread = %@", [NSThread currentThread]);
    }];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        NSLog(@"post thread = %@", [NSThread currentThread]);
        [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
    });
}

@end
</code></pre>

<p>在这里，我们在主线程里添加了一个观察者，并指定在主线程队列中去接收处理这个通知。然后我们在一个全局队列中post了一个通知。我们来看下输出结果：</p>

<pre><code>post thread = &lt;NSThread: 0x7ffe0351f5f0&gt;{number = 2, name = (null)}
receive thread = &lt;NSThread: 0x7ffe03508b30&gt;{number = 1, name = main}
</code></pre>

<p>可以看到，消息的post与接收处理并不是在同一个线程中。如上面所提到的，如果queue为nil，则消息是默认在post线程中同步处理，大家可以试一下。</p>

<p>对于第3点，由于使用的是block，所以需要注意的就是避免引起循环引用的问题，如代码清单3所示：</p>

<p><strong>代码清单3：block引发的循环引用问题</strong></p>

<pre><code>@interface Observer : NSObject

@property (nonatomic, assign) NSInteger i;
@property (nonatomic, weak) id&lt;NSObject&gt; observer;

@end

@implementation Observer

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        NSLog(@"Init Observer");

        // 添加观察者
        _observer =  [[NSNotificationCenter defaultCenter] addObserverForName:TEST_NOTIFICATION object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *note) {

            NSLog(@"handle notification");

            // 使用self
            self.i = 10;
        }];
    }

    return self;
}

@end

#pragma mark - ViewController

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [self createObserver];

    // 发送消息
    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
}

- (void)createObserver {

    Observer *observer = [[Observer alloc] init];
}

@end
</code></pre>

<p>运行后的输出如下：</p>

<pre><code>Init Observer
handle notification
</code></pre>

<p>我们可以看到createObserver中创建的observer并没有被释放。所以，使用
&ndash; addObserverForName:object:queue:usingBlock:一定要注意这个问题。</p>

<h2>移除观察者</h2>

<p>与注册观察者相对应的，NSNotificationCenter为我们提供了两个移除观察者的方法。它们的定义如下：</p>

<pre><code>- (void)removeObserver:(id)notificationObserver

- (void)removeObserver:(id)notificationObserver name:(NSString *)notificationName object:(id)notificationSender
</code></pre>

<p>前一个方法会将notificationObserver从通知中心中移除，这样notificationObserver就无法再监听任何消息。而后一个会根据三个参数来移除相应的观察者。</p>

<p>这两个方法也有几点需要注意：</p>

<ol>
<li>由于注册观察者时(不管是哪个方法)，通知中心会维护一个观察者的弱引用，所以在释放对象时，要确保移除对象所有监听的通知。否则，可能会导致程序崩溃或一些莫名其妙的问题。</li>
<li>对于第二个方法，如果notificationName为nil，则会移除所有匹配notificationObserver和notificationSender的通知，同理notificationSender也是一样的。而如果notificationName和notificationSender都为nil，则其效果就与第一个方法是一样的了。大家可以试一下。</li>
<li>最有趣的应该是这两个方法的使用时机。–removeObserver:适合于在类的dealloc方法中调用，这样可以确保将对象从通知中心中清除；而在viewWillDisappear:这样的方法中，则适合于使用-removeObserver:name:object:方法，以避免不知情的情况下移除了不应该移除的通知观察者。例如，假设我们的ViewController继承自一个类库的某个ViewController类(假设为SKViewController吧)，可能SKViewController自身也监听了某些通知以执行特定的操作，但我们使用时并不知道。如果直接在viewWillDisappear:中调用–removeObserver:，则也会把父类监听的通知也给移除。</li>
</ol>


<p>关于注册监听者，还有一个需要注意的问题是，每次调用addObserver时，都会在通知中心重新注册一次，即使是同一对象监听同一个消息，而不是去覆盖原来的监听。这样，当通知中心转发某一消息时，如果同一对象多次注册了这个通知的观察者，则会收到多个通知，如代码清单4所示：</p>

<p><strong>代码清单4：同一对象多次注册同一消息</strong></p>

<pre><code>@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];

    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"notification = %@", notification.name);
}

@end
</code></pre>

<p>其输出结果如下所示：</p>

<pre><code>notification = TestNotification
notification = TestNotification
</code></pre>

<p>可以看到对象处理了两次通知。所以，如果我们需要在viewWillAppear监听一个通知时，一定要记得在对应的viewWillDisappear里面将观察者移除，否则就可能会出现上面的情况。</p>

<p><strong>最后，再特别重点强调的非常重要的一点是，在释放对象前，一定要记住如果它监听了通知，一定要将它从通知中心移除。如果是用
&ndash; addObserverForName:object:queue:usingBlock:，也记得一定得移除这个匿名观察者。说白了就一句话，添加和移除要配对出现。</strong></p>

<h2>post消息</h2>

<p>注册了通知观察者，我们便可以随时随地的去post一个通知了(当然，如果闲着没事，也可以不注册观察者，post通知随便玩，只是没人理睬罢了)。NSNotificationCenter提供了三个方法来post一个通知，如下所示：</p>

<pre><code>- postNotification:
– postNotificationName:object:
– postNotificationName:object:userInfo:
</code></pre>

<p>我们可以根据需要指定通知的发送者(object)并附带一些与通知相关的信息(userInfo)，当然这些发送者和userInfo可以封装在一个NSNotification对象中，由- postNotification:来发送。注意，- postNotification:的参数不能为空，否则会引发一个异常，如下所示：</p>

<pre><code>*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -[NSNotificationCenter postNotification:]: notification is nil'
</code></pre>

<p>每次post一个通知时，通知中心都会去遍历一下它的分发表，然后将通知转发给相应的观察者。</p>

<p>另外，通知的发送与处理是同步的，在某个地方post一个消息时，会等到所有观察者对象执行完处理操作后，才回到post的地方，继续执行后面的代码。如代码清单5所示：</p>

<p><strong>代码清单5：通知的同步处理</strong></p>

<pre><code>@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];

    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];

    NSLog(@"continue");
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"handle notification");
}

@end
</code></pre>

<p>运行后输出结果是：</p>

<pre><code>handle notification
continue
</code></pre>

<h2>一些思考</h2>

<p>翻了好些资料，还有两个问题始终没有明确的答案。</p>

<p>首先就是通知中心是如何维护观察者对象的。可以明确的是，添加观察者时，通知中心没有对观察者做retain操作，即不会使观察者的引用计数加1。那通知中心维护的是观察者的weak引用呢还是unsafe_unretained引用呢？</p>

<p>个人认为可能是unsafe_unretained的引用，因为我们知道如果是weak引用，其所指的对象被释放后，这个引用会被置成nil。而实际情况是通知中心还会给这个对象发送消息，并引发一个异常。而如果向nil发送一个消息是不会导致异常的。</p>

<p>【非常感谢 <a href="http://weibo.com/u/2814972697">@lv-pw</a>，上面这个问题在<a href="http://open.163.com/movie/2014/1/L/H/M9H7S9F1H_M9H801GLH.html">《斯坦福大学公开课：iOS 7应用开发》的第5集</a>的第57分50秒中得到了解答：确实使用的是unsafe_unretained，老师的解释是，之所以使用unsafe_unretained，而不使用weak，是为了兼容老版本的系统。】</p>

<p>另外，我们知道NSNotificationCenter实现的是观察者模式，而且通常情况下消息在哪个线程被post，就在哪个线程被转发。而从上面的描述可以发现，
-addObserverForName:object:queue:usingBlock:添加的匿名观察者可以在指定的队列中处理通知，那它的实现机制是什么呢？</p>

<h2>小结</h2>

<p>在我们的应用程序中，一个大的话题就是两个对象之间如何通信。我们需要根据对象之间的关系来确定采用哪一种通信方式。对象之间的通信方式主要有以下几种：</p>

<ol>
<li>直接方法调用</li>
<li>Target-Action</li>
<li>Delegate</li>
<li>回调(block)</li>
<li>KVO</li>
<li>通知</li>
</ol>


<p>一般情况下，我们可以根据以下两点来确定使用哪种方式：</p>

<ol>
<li>通信对象是一对一的还是一对多的</li>
<li>对象之间的耦合度，是强耦合还是松耦合</li>
</ol>


<p>Objective-C中的通知由于其广播性及松耦合性，非常适合于大的范围内对象之间的通信(模块与模块，或一些框架层级)。通知使用起来非常方便，也正因为如此，所以容易导致滥用。所以在使用前还是需要多想想，是否有更好的方法来实现我们所需要的对象间通信。毕竟，通知机制会在一定程度上会影响到程序的性能。</p>

<p>对于使用NSNotificationCenter，最后总结一些小建议：</p>

<ol>
<li>在需要的地方使用通知。</li>
<li>注册的观察者在不使用时一定要记得移除，即添加和移除要配对出现。</li>
<li>尽可能迟地去注册一个观察者，并尽可能早将其移除，这样可以改善程序的性能。因为，每post一个通知，都会是遍历通知中心的分发表，确保通知发给每一个观察者。</li>
<li>记住通知的发送和处理是在同一个线程中。</li>
<li>使用-addObserverForName:object:queue:usingBlock:务必处理好内存问题，避免出现循环引用。</li>
<li>NSNotificationCenter是线程安全的，但并不意味着在多线程环境中不需要关注线程安全问题。不恰当的使用仍然会引发线程问题。</li>
</ol>


<p>最后，“<a href="http://weibo.com/u/1438670852">@叶孤城___</a>”叶大大在微博中推荐了几篇文章，即参考中的4-7，值得细读一下。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/">NSNotificationCenter Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Notifications/Articles/NotificationQueues.html">Notification Programming Topics</a></li>
<li><a href="http://nshipster.com/nsnotification-and-nsnotificationcenter/">NSNotification &amp; NSNotification​Center</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-1/">NSNotificationCenter part 1: Receiving and sending notifications</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-2/">NSNotificationCenter part 2: Implementing the observer pattern with notifications</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-3/">NSNotificationCenter part 3: Unit testing notifications with OCMock</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-4/">NSNotificationCenter part 4: Asynchronous notifications with NSNotificationQueue</a></li>
<li><a href="http://stackoverflow.com/questions/12699118/view-controller-dealloc-not-called-when-using-nsnotificationcenter-code-block-me">View controller dealloc not called when using NSNotificationCenter code block method with ARC</a></li>
<li><a href="http://open.163.com/movie/2014/1/L/H/M9H7S9F1H_M9H801GLH.html">《斯坦福大学公开课：iOS 7应用开发》第5集</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notification与多线程]]></title>
    <link href="http://southpeak.github.io/blog/2015/03/14/nsnotificationyu-duo-xian-cheng/"/>
    <updated>2015-03-14T12:58:59+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/03/14/nsnotificationyu-duo-xian-cheng</id>
    <content type="html"><![CDATA[<p>前几天与同事讨论到Notification在多线程下的转发问题，所以就此整理一下。</p>

<p>先来看看官方的文档，是这样写的：</p>

<pre><code>In a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.
</code></pre>

<p>翻译过来是：</p>

<pre><code>在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。
</code></pre>

<p>也就是说，Notification的发送与接收处理都是在同一个线程中。为了说明这一点，我们先来看一个示例：</p>

<p><strong>代码清单1：Notification的发送与处理</strong></p>

<pre><code>@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    NSLog(@"current thread = %@", [NSThread currentThread]);

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil userInfo:nil];
    });
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"current thread = %@", [NSThread currentThread]);

    NSLog(@"test notification");
}

@end
</code></pre>

<p>其输出结果如下：</p>

<pre><code>2015-03-11 22:05:12.856 test[865:45102] current thread = &lt;NSThread: 0x7fbb23412f30&gt;{number = 1, name = main}
2015-03-11 22:05:12.857 test[865:45174] current thread = &lt;NSThread: 0x7fbb23552370&gt;{number = 2, name = (null)}
2015-03-11 22:05:12.857 test[865:45174] test notification
</code></pre>

<p>可以看到，虽然我们在主线程中注册了通知的观察者，但在全局队列中post的Notification，并不是在主线程处理的。所以，这时候就需要注意，如果我们想在回调中处理与UI相关的操作，需要确保是在主线程中执行回调。</p>

<p>这时，就有一个问题了，如果我们的Notification是在二级线程中post的，如何能在主线程中对这个Notification进行处理呢？或者换个提法，如果我们希望一个Notification的post线程与转发线程不是同一个线程，应该怎么办呢？我们看看官方文档是怎么说的：</p>

<pre><code>For example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.
</code></pre>

<p>这里讲到了“重定向”，就是我们在Notification所在的默认线程中捕获这些分发的通知，然后将其重定向到指定的线程中。</p>

<p>一种重定向的实现思路是自定义一个通知队列(注意，不是NSNotificationQueue对象，而是一个数组)，让这个队列去维护那些我们需要重定向的Notification。我们仍然是像平常一样去注册一个通知的观察者，当Notification来了时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，则将这个Notification存储到我们的队列中，并发送一个信号(signal)到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程在收到信号后，将Notification从队列中移除，并进行处理。</p>

<p>官方文档已经给出了示例代码，在此借用一下，以测试实际结果：</p>

<p><strong>代码清单2：在不同线程中post和转发一个Notification</strong></p>

<pre><code>@interface ViewController () &lt;NSMachPortDelegate&gt;

@property (nonatomic) NSMutableArray    *notifications;         // 通知队列
@property (nonatomic) NSThread          *notificationThread;    // 期望线程
@property (nonatomic) NSLock            *notificationLock;      // 用于对通知队列加锁的锁对象，避免线程冲突
@property (nonatomic) NSMachPort        *notificationPort;      // 用于向期望线程发送信号的通信端口

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    NSLog(@"current thread = %@", [NSThread currentThread]);

    // 初始化
    self.notifications = [[NSMutableArray alloc] init];
    self.notificationLock = [[NSLock alloc] init];

    self.notificationThread = [NSThread currentThread];
    self.notificationPort = [[NSMachPort alloc] init];
    self.notificationPort.delegate = self;

    // 往当前线程的run loop添加端口源
    // 当Mach消息到达而接收线程的run loop没有运行时，则内核会保存这条消息，直到下一次进入run loop
    [[NSRunLoop currentRunLoop] addPort:self.notificationPort
                                forMode:(__bridge NSString *)kCFRunLoopCommonModes];

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:@"TestNotification" object:nil];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil userInfo:nil];

    });
}

- (void)handleMachMessage:(void *)msg {

    [self.notificationLock lock];

    while ([self.notifications count]) {
        NSNotification *notification = [self.notifications objectAtIndex:0];
        [self.notifications removeObjectAtIndex:0];
        [self.notificationLock unlock];
        [self processNotification:notification];
        [self.notificationLock lock];
    };

    [self.notificationLock unlock];
}

- (void)processNotification:(NSNotification *)notification {

    if ([NSThread currentThread] != _notificationThread) {
        // Forward the notification to the correct thread.
        [self.notificationLock lock];
        [self.notifications addObject:notification];
        [self.notificationLock unlock];
        [self.notificationPort sendBeforeDate:[NSDate date]
                                   components:nil
                                         from:nil
                                     reserved:0];
    }
    else {
        // Process the notification here;
        NSLog(@"current thread = %@", [NSThread currentThread]);
        NSLog(@"process notification");
    }
}

@end
</code></pre>

<p>运行后，其输出如下：</p>

<pre><code>2015-03-11 23:38:31.637 test[1474:92483] current thread = &lt;NSThread: 0x7ffa4070ed50&gt;{number = 1, name = main}
2015-03-11 23:38:31.663 test[1474:92483] current thread = &lt;NSThread: 0x7ffa4070ed50&gt;{number = 1, name = main}
2015-03-11 23:38:31.663 test[1474:92483] process notification
</code></pre>

<p>可以看到，我们在全局dispatch队列中抛出的Notification，如愿地在主线程中接收到了。</p>

<p>这种实现方式的具体解析及其局限性大家可以参考官方文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG">Delivering Notifications To Particular Threads</a>，在此不多做解释。当然，更好的方法可能是我们自己去子类化一个NSNotificationCenter，或者单独写一个类来处理这种转发。</p>

<h2>NSNotificationCenter的线程安全性</h2>

<p>苹果之所以采取通知中心在同一个线程中post和转发同一消息这一策略，应该是出于线程安全的角度来考量的。官方文档告诉我们，NSNotificationCenter是一个线程安全类，我们可以在多线程环境下使用同一个NSNotificationCenter对象而不需要加锁。原文在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html">Threading Programming Guide</a>中，具体如下：</p>

<pre><code>The following classes and functions are generally considered to be thread-safe. You can use the same instance from multiple threads without first acquiring a lock.

NSArray
...
NSNotification
NSNotificationCenter
...
</code></pre>

<p>我们可以在任何线程中添加/删除通知的观察者，也可以在任何线程中post一个通知。</p>

<p>NSNotificationCenter在线程安全性方面已经做了不少工作了，那是否意味着我们可以高枕无忧了呢？再回过头来看看第一个例子，我们稍微改造一下，一点一点来：</p>

<p><strong>代码清单3：NSNotificationCenter的通用模式</strong></p>

<pre><code>@interface Observer : NSObject

@end

@implementation Observer

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        _poster = [[Poster alloc] init];

        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil]
    }

    return self;
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"handle notification ");
}

- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

@end

// 其它地方
[[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];   
</code></pre>

<p>上面的代码就是我们通常所做的事情：添加一个通知监听者，定义一个回调，并在所属对象释放时移除监听者；然后在程序的某个地方post一个通知。简单明了，如果这一切都是发生在一个线程里面，或者至少dealloc方法是在-postNotificationName:的线程中运行的(注意：NSNotification的post和转发是同步的)，那么都OK，没有线程安全问题。但如果dealloc方法和-postNotificationName:方法不在同一个线程中运行时，会出现什么问题呢？</p>

<p>我们再改造一下上面的代码：</p>

<p><strong>代码清单4：NSNotificationCenter引发的线程安全问题</strong></p>

<pre><code>#pragma mark - Poster

@interface Poster : NSObject

@end

@implementation Poster

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        [self performSelectorInBackground:@selector(postNotification) withObject:nil];
    }

    return self;
}

- (void)postNotification
{
    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
}

@end

#pragma mark - Observer

@interface Observer : NSObject
{
    Poster  *_poster;
}

@property (nonatomic, assign) NSInteger i;

@end

@implementation Observer

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        _poster = [[Poster alloc] init];

        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];
    }

    return self;
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"handle notification begin");
    sleep(1);
    NSLog(@"handle notification end");

    self.i = 10;
}

- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];

    NSLog(@"Observer dealloc");
}

@end

#pragma mark - ViewController

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    __autoreleasing Observer *observer = [[Observer alloc] init];
}

@end
</code></pre>

<p>这段代码是在主线程添加了一个TEST_NOTIFICATION通知的监听者，并在主线程中将其移除，而我们的NSNotification是在后台线程中post的。在通知处理函数中，我们让回调所在的线程睡眠1秒钟，然后再去设置属性i值。这时会发生什么呢？我们先来看看输出结果：</p>

<pre><code>2015-03-14 00:31:41.286 SKTest[932:88791] handle notification begin
2015-03-14 00:31:41.291 SKTest[932:88713] Observer dealloc
2015-03-14 00:31:42.361 SKTest[932:88791] handle notification end
(lldb) 

// 程序在self.i = 10处抛出了"Thread 6: EXC_BAD_ACCESS(code=EXC_I386_GPFLT)"
</code></pre>

<p>经典的内存错误，程序崩溃了。其实从输出结果中，我们就可以看到到底是发生了什么事。我们简要描述一下：</p>

<ol>
<li>当我们注册一个观察者是，通知中心会持有观察者的一个弱引用，来确保观察者是可用的。</li>
<li>主线程调用dealloc操作会让Observer对象的引用计数减为0，这时对象会被释放掉。</li>
<li>后台线程发送一个通知，如果此时Observer还未被释放，则会向其转发消息，并执行回调方法。而如果在回调执行的过程中对象被释放了，就会出现上面的问题。</li>
</ol>


<p>当然，上面这个例子是故意而为之，但不排除在实际编码中会遇到类似的问题。虽然NSNotificationCenter是线程安全的，但并不意味着我们在使用时就可以保证线程安全的，如果稍不注意，还是会出现线程问题。</p>

<p>那我们该怎么做呢？这里有一些好的建议：</p>

<ol>
<li>尽量在一个线程中处理通知相关的操作，大部分情况下，这样做都能确保通知的正常工作。不过，我们无法确定到底会在哪个线程中调用dealloc方法，所以这一点还是比较困难。</li>
<li>注册监听都时，使用基于block的API。这样我们在block还要继续调用self的属性或方法，就可以通过weak-strong的方式来处理。具体大家可以改造下上面的代码试试是什么效果。</li>
<li>使用带有安全生命周期的对象，这一点对象单例对象来说再合适不过了，在应用的整个生命周期都不会被释放。</li>
<li>使用代理。</li>
</ol>


<h2>小结</h2>

<p>NSNotificationCenter虽然是线程安全的，但不要被这个事实所误导。在涉及到多线程时，我们还是需要多加小心，避免出现上面的线程问题。想进一步了解的话，可以查看<a href="http://inessential.com/2013/12/20/observers_and_thread_safety">Observers and Thread Safety</a>。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/Notifications.html">Notification Programming Topics</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html">Threading Programming Guide</a></li>
<li><a href="http://blog.csdn.net/wzzvictory/article/details/8489516">NSNotification的几点说明</a></li>
<li><a href="http://lapcatsoftware.com/articles/nsnotificationcenter-is-threadsafe-not.html">NSNotificationCenter is thread-safe NOT</a></li>
<li><a href="http://inessential.com/2013/12/20/observers_and_thread_safety">Observers and Thread Safety</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIResponder]]></title>
    <link href="http://southpeak.github.io/blog/2015/03/07/uiresponder/"/>
    <updated>2015-03-07T18:54:23+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/03/07/uiresponder</id>
    <content type="html"><![CDATA[<p>我们的App与用户进行交互，基本上是依赖于各种各样的事件。例如，用户点击界面上的按钮，我们需要触发一个按钮点击事件，并进行相应的处理，以给用户一个响应。UIView的三大职责之一就是处理事件，一个视图是一个事件响应者，可以处理点击等事件，而这些事件就是在UIResponder类中定义的。</p>

<p>一个UIResponder类为那些需要响应并处理事件的对象定义了一组接口。这些事件主要分为两类：触摸事件(touch events)和运动事件(motion events)。UIResponder类为每两类事件都定义了一组接口，这个我们将在下面详细描述。</p>

<p>在UIKit中，UIApplication、UIView、UIViewController这几个类都是直接继承自UIResponder类。另外SpriteKit中的SKNode也是继承自UIResponder类。因此UIKit中的视图、控件、视图控制器，以及我们自定义的视图及视图控制器都有响应事件的能力。这些对象通常被称为响应对象，或者是响应者(以下我们统一使用响应者)。</p>

<p>本文将详细介绍一个UIResponder类提供的基本功能。不过在此之前，我们先来了解一下事件响应链机制。</p>

<h2>响应链</h2>

<p>大多数事件的分发都是依赖响应链的。响应链是由一系列链接在一起的响应者组成的。一般情况下，一条响应链开始于第一响应者，结束于application对象。如果一个响应者不能处理事件，则会将事件沿着响应链传到下一响应者。</p>

<p>那这里就会有三个问题：</p>

<ol>
<li>响应链是何时构建的</li>
<li>系统是如何确定第一响应者的</li>
<li>确定第一响应者后，系统又是按照什么样的顺序来传递事件的</li>
</ol>


<h3>构建响应链</h3>

<p>我们都知道在一个App中，所有视图是按一定的结构组织起来的，即树状层次结构。除了根视图外，每个视图都有一个父视图；而每个视图都可以有0个或多个子视图。而在这个树状结构构建的同时，也构建了一条条的事件响应链。</p>

<h3>确定第一响应者</h3>

<p>当用户触发某一事件(触摸事件或运动事件)后，UIKit会创建一个事件对象(UIEvent)，该对象包含一些处理事件所需要的信息。然后事件对象被放到一个事件队列中。这些事件按照先进先出的顺序来处理。当处理事件时，程序的UIApplication对象会从队列头部取出一个事件对象，将其分发出去。通常首先是将事件分发给程序的主window对象，对于触摸事件来讲，window对象会首先尝试将事件分发给触摸事件发生的那个视图上。这一视图通常被称为hit-test视图，而查找这一视图的过程就叫做hit-testing。</p>

<p>系统使用hit-testing来找到触摸下的视图，它检测一个触摸事件是否发生在相应视图对象的边界之内(即视图的frame属性，这也是为什么子视图如果在父视图的frame之外时，是无法响应事件的)。如果在，则会递归检测其所有的子视图。包含触摸点的视图层次架构中最底层的视图就是hit-test视图。在检测出hit-test视图后，系统就将事件发送给这个视图来进行处理。</p>

<p>我们通过一个示例来演示hit-testing的过程。图1是一个视图层次结构，</p>

<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png" alt="image" /></p>

<p>假设用户点击了视图E，系统按照以下顺序来查找hit-test视图：</p>

<ol>
<li>点击事件发生在视图A的边界内，所以检测子视图B和C；</li>
<li>点击事件不在视图B的边界内，但在视图C的边界范围内，所以检测子图片D和E；</li>
<li>点击事件不在视图D的边界内，但在视图E的边界范围内；</li>
</ol>


<p>视图E是包含触摸点的视图层次架构中最底层的视图(倒树结构)，所以它就是hit-test视图。</p>

<p>hit-test视图可以最先去处理触摸事件，如果hit-test视图不能处理事件，则事件会沿着响应链往上传递，直到找到能处理它的视图。</p>

<h3>事件传递</h3>

<p>最有机会处理事件的对象是hit-test视图或第一响应者。如果这两者都不能处理事件，UIKit就会将事件传递到响应链中的下一个响应者。每一个响应者确定其是否要处理事件或者是通过nextResponder方法将其传递给下一个响应者。这一过程一直持续到找到能处理事件的响应者对象或者最终没有找到响应者。</p>

<p>图2演示了这样一个事件传递的流程，</p>

<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png" alt="image" /></p>

<p>当系统检测到一个事件时，将其传递给初始对象，这个对象通常是一个视图。然后，会按以下路径来处理事件(我们以左图为例)：</p>

<ol>
<li>初始视图(initial view)尝试处理事件。如果它不能处理事件，则将事件传递给其父视图。</li>
<li>初始视图的父视图(superview)尝试处理事件。如果这个父视图还不能处理事件，则继续将视图传递给上层视图。</li>
<li>上层视图(topmost view)会尝试处理事件。如果这个上层视图还是不能处理事件，则将事件传递给视图所在的视图控制器。</li>
<li>视图控制器会尝试处理事件。如果这个视图控制器不能处理事件，则将事件传递给窗口(window)对象。</li>
<li>窗口(window)对象尝试处理事件。如果不能处理，则将事件传递给单例app对象。</li>
<li>如果app对象不能处理事件，则丢弃这个事件。</li>
</ol>


<p>从上面可以看到，视图、视图控制器、窗口对象和app对象都能处理事件。另外需要注意的是，手势也会影响到事件的传递。</p>

<p>以上便是响应链的一些基本知识。有了这些知识，我们便可以来看看UIResponder提供给我们的一些方法了。</p>

<h2>管理响应链</h2>

<p>UIResponder提供了几个方法来管理响应链，包括让响应对象成为第一响应者、放弃第一响应者、检测是否是第一响应者以及传递事件到下一响应者的方法，我们分别来介绍一下。</p>

<p>上面提到在响应链中负责传递事件的方法是nextResponder，其声明如下：</p>

<pre><code>- (UIResponder *)nextResponder
</code></pre>

<p>UIResponder类并不自动保存或设置下一个响应者，该方法的默认实现是返回nil。子类的实现必须重写这个方法来设置下一响应者。UIView的实现是返回管理它的UIViewController对象(如果它有)或者其父视图。而UIViewController的实现是返回它的视图的父视图；UIWindow的实现是返回app对象；而UIApplication的实现是返回nil。所以，响应链是在构建视图层次结构时生成的。</p>

<p>一个响应对象可以成为第一响应者，也可以放弃第一响应者。为此，UIResponder提供了一系列方法，我们分别来介绍一下。</p>

<p>如果想判定一个响应对象是否是第一响应者，则可以使用以下方法：</p>

<pre><code>- (BOOL)isFirstResponder
</code></pre>

<p>如果我们希望将一个响应对象作为第一响应者，则可以使用以下方法：</p>

<pre><code>- (BOOL)becomeFirstResponder
</code></pre>

<p>如果对象成为第一响应者，则返回YES；否则返回NO。默认实现是返回YES。子类可以重写这个方法来更新状态，或者来执行一些其它的行为。</p>

<p>一个响应对象只有在当前响应者能放弃第一响应者状态(canResignFirstResponder)且自身能成为第一响应者(canBecomeFirstResponder)时才会成为第一响应者。</p>

<p>这个方法相信大家用得比较多，特别是在希望UITextField获取焦点时。另外需要注意的是只有当视图是视图层次结构的一部分时才调用这个方法。如果视图的window属性不为空时，视图才在一个视图层次结构中；如果该属性为nil，则视图不在任何层次结构中。</p>

<p>上面提到一个响应对象成为第一响应者的一个前提是它可以成为第一响应者，我们可以使用canBecomeFirstResponder方法来检测，</p>

<pre><code>- (BOOL)canBecomeFirstResponder
</code></pre>

<p>需要注意的是我们不能向一个不在视图层次结构中的视图发送这个消息，其结果是未定义的。</p>

<p>与上面两个方法相对应的是响应者放弃第一响应者的方法，其定义如下：</p>

<pre><code>- (BOOL)resignFirstResponder
- (BOOL)canResignFirstResponder
</code></pre>

<p>resignFirstResponder默认也是返回YES。需要注意的是，如果子类要重写这个方法，则在我们的代码中必须调用super的实现。</p>

<p>canResignFirstResponder默认也是返回YES。不过有些情况下可能需要返回NO，如一个输入框在输入过程中可能需要让这个方法返回NO，以确保在编辑过程中能始终保证是第一响应者。</p>

<h2>管理输入视图</h2>

<p>所谓的输入视图，是指当对象为第一响应者时，显示另外一个视图用来处理当前对象的信息输入，如UITextView和UITextField两个对象，在其成为第一响应者是，会显示一个系统键盘，用来输入信息。这个系统键盘就是输入视图。输入视图有两种，一个是inputView，另一个是inputAccessoryView。这两者如图3所示：</p>

<p><img src="http://images.cnblogs.com/cnblogs_com/kuku/b.jpg" alt="image" /></p>

<p>与inputView相关的属性有如下两个，</p>

<pre><code>@property(nonatomic, readonly, retain) UIView *inputView
@property(nonatomic, readonly, retain) UIInputViewController *inputViewController
</code></pre>

<p>这两个属性提供一个视图(或视图控制器)用于替代为UITextField和UITextView弹出的系统键盘。我们可以在子类中将这两个属性重新定义为读写属性来设置这个属性。如果我们需要自己写一个键盘的，如为输入框定义一个用于输入身份证的键盘(只包含0-9和X)，则可以使用这两个属性来获取这个键盘。</p>

<p>与inputView类似，inputAccessoryView也有两个相关的属性：</p>

<pre><code>@property(nonatomic, readonly, retain) UIView *inputAccessoryView
@property(nonatomic, readonly, retain) UIInputViewController *inputAccessoryViewController
</code></pre>

<p>设置方法与前面相同，都是在子类中重新定义为可读写属性，以设置这个属性。</p>

<p>另外，UIResponder还提供了以下方法，在对象是第一响应者时更新输入和访问视图，</p>

<pre><code>- (void)reloadInputViews
</code></pre>

<p>调用这个方法时，视图会立即被替换，即不会有动画之类的过渡。如果当前对象不是第一响应者，则该方法是无效的。</p>

<h2>响应触摸事件</h2>

<p>UIResponder提供了如下四个大家都非常熟悉的方法来响应触摸事件：</p>

<pre><code>// 当一个或多个手指触摸到一个视图或窗口
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
// 当与事件相关的一个或多个手指在视图或窗口上移动时
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
// 当一个或多个手指从视图或窗口上抬起时
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
// 当一个系统事件取消一个触摸事件时
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event
</code></pre>

<p>这四个方法默认都是什么都不做。不过，UIKit中UIResponder的子类，尤其是UIView，这几个方法的实现都会把消息传递到响应链上。因此，为了不阻断响应链，我们的子类在重写时需要调用父类的相应方法；而不要将消息直接发送给下一响应者。</p>

<p>默认情况下，多点触摸是被禁用的。为了接受多点触摸事件，我们需要设置响应视图的multipleTouchEnabled属性为YES。</p>

<h2>响应移动事件</h2>

<p>与触摸事件类似，UIResponder也提供了几个方法来响应移动事件：</p>

<pre><code>// 移动事件开始
- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event
// 移动事件结束
- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event
// 取消移动事件
- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event
</code></pre>

<p>与触摸事件不同的是，运动事件只有开始与结束操作；它不会报告类似于晃动这样的事件。这几个方法的默认操作也是什么都不做。不过，UIKit中UIResponder的子类，尤其是UIView，这几个方法的实现都会把消息传递到响应链上。</p>

<h2>响应远程控制事件</h2>

<p>远程控制事件来源于一些外部的配件，如耳机等。用户可以通过耳机来控制视频或音频的播放。接收响应者对象需要检查事件的子类型来确定命令(如播放，子类型为UIEventSubtypeRemoteControlPlay)，然后进行相应处理。</p>

<p>为了响应远程控制事件，UIResponder提供了以下方法，</p>

<pre><code>- (void)remoteControlReceivedWithEvent:(UIEvent *)event
</code></pre>

<p>我们可以在子类中实现该方法，来处理远程控制事件。不过，为了允许分发远程控制事件，我们必须调用UIApplication的beginReceivingRemoteControlEvents方法；而如果要关闭远程控制事件的分发，则调用endReceivingRemoteControlEvents方法。</p>

<h2>获取Undo管理器</h2>

<p>默认情况下，程序的每一个window都有一个undo管理器，它是一个用于管理undo和redo操作的共享对象。然而，响应链上的任何对象的类都可以有自定义undo管理器。例如，UITextField的实例的自定义管理器在文件输入框放弃第一响应者状态时会被清理掉。当需要一个undo管理器时，请求会沿着响应链传递，然后UIWindow对象会返回一个可用的实例。</p>

<p>UIResponder提供了一个只读方法来获取响应链中共享的undo管理器，</p>

<pre><code>@property(nonatomic, readonly) NSUndoManager *undoManager
</code></pre>

<p>我们可以在自己的视图控制器中添加undo管理器来执行其对应的视图的undo和redo操作。</p>

<h2>验证命令</h2>

<p>在我们的应用中，经常会处理各种菜单命令，如文本输入框的&#8221;复制&#8221;、&#8221;粘贴&#8221;等。UIResponder为此提供了两个方法来支持此类操作。首先使用以下方法可以启动或禁用指定的命令：</p>

<pre><code>- (BOOL)canPerformAction:(SEL)action withSender:(id)sender
</code></pre>

<p>该方法默认返回YES，我们的类可以通过某种途径处理这个命令，包括类本身或者其下一个响应者。子类可以重写这个方法来开启菜单命令。例如，如果我们希望菜单支持&#8221;Copy&#8221;而不支持&#8221;Paser&#8221;，则在我们的子类中实现该方法。需要注意的是，即使在子类中禁用某个命令，在响应链上的其它响应者也可能会处理这些命令。</p>

<p>另外，我们可以使用以下方法来获取可以响应某一行为的接收者：</p>

<pre><code>- (id)targetForAction:(SEL)action withSender:(id)sender
</code></pre>

<p>在对象需要调用一个action操作时调用该方法。默认的实现是调用canPerformAction:withSender:方法来确定对象是否可以调用action操作。如果可以，则返回对象本身，否则将请求传递到响应链上。如果我们想要重写目标的选择方式，则应该重写这个方法。下面这段代码演示了一个文本输入域禁用拷贝/粘贴操作：</p>

<pre><code>- (id)targetForAction:(SEL)action withSender:(id)sender
{
    UIMenuController *menuController = [UIMenuController sharedMenuController];
    if (action == @selector(selectAll:) || action == @selector(paste:) ||action == @selector(copy:) || action == @selector(cut:)) {
        if (menuController) {
            [UIMenuController sharedMenuController].menuVisible = NO;
        }
        return nil;
    }
    return [super targetForAction:action withSender:sender];
}
</code></pre>

<h2>访问快捷键命令</h2>

<p>我们的应用可以支持外部设备，包括外部键盘。在使用外部键盘时，使用快捷键可以大大提高我们的输入效率。因此从iOS7后，UIResponder类新增了一个只读属性keyCommands，来定义一个响应者支持的快捷键，其声明如下：</p>

<pre><code>@property(nonatomic, readonly) NSArray *keyCommands
</code></pre>

<p>一个支持硬件键盘命令的响应者对象可以重新定义这个方法并使用它来返回一个其所支持快捷键对象(UIKeyCommand)的数组。每一个快捷键命令表示识别的键盘序列及响应者的操作方法。</p>

<p>我们用这个方法返回的快捷键命令数组被用于整个响应链。当与快捷键命令对象匹配的快捷键被按下时，UIKit会沿着响应链查找实现了响应行为方法的对象。它调用找到的第一个对象的方法并停止事件的处理。</p>

<h2>管理文本输入模式</h2>

<p>文本输入模式标识当响应者激活时的语言及显示的键盘。UIResponder为此定义了一个属性来返回响应者对象的文本输入模式：</p>

<pre><code>@property(nonatomic, readonly, retain) UITextInputMode *textInputMode
</code></pre>

<p>对于响应者而言，系统通常显示一个基于用户语言设置的键盘。我们可以重新定义这个属性，并让它返回一个不同的文本输入模式，以让我们的响应者使用一个特定的键盘。用户在响应者被激活时仍然可以改变键盘，在切换到另一个响应者时，可以再恢复到指定的键盘。</p>

<p>如果我们想让UIKit来跟踪这个响应者的文本输入模式，我们可以通过textInputContextIdentifier属性来设置一个标识，该属性的声明如下：</p>

<pre><code>@property(nonatomic, readonly, retain) NSString *textInputContextIdentifier
</code></pre>

<p>该标识指明响应者应保留文本输入模式的信息。在跟踪模式下，任何对文本输入模式的修改都会记录下来，当响应者激活时再用于恢复处理。</p>

<p>为了从程序的user default中清理输入模式信息，UIResponder定义了一个类方法，其声明如下：</p>

<pre><code>+ (void)clearTextInputContextIdentifier:(NSString *)identifier
</code></pre>

<p>调用这个方法可以从程序的user default中移除与指定标识相关的所有文本输入模式。移除这些信息会让响应者重新使用默认的文本输入模式。</p>

<h2>支持User Activities</h2>

<p>从iOS 8起，苹果为我们提供了一个非常棒的功能，即Handoff。使用这一功能，我们可以在一部iOS设备的某个应用上开始做一件事，然后在另一台iOS设备上继续做这件事。Handoff的基本思想是用户在一个应用里所做的任何操作都可以看作是一个Activity，一个Activity可以和一个特定iCloud用户的多台设备关联起来。在编写一个支持Handoff的应用时，会有以下三个交互事件：</p>

<ol>
<li>为将在另一台设备上继续做的事创建一个新的User Activity；</li>
<li>当需要时，用新的数据更新已有的User Activity；</li>
<li>把一个User Activity传递到另一台设备上。</li>
</ol>


<p>为了支持这些交互事件，在iOS 8后，UIResponder类新增了几个方法，我们在此不讨论这几个方法的实际使用，想了解更多的话，可以参考<a href="http://www.cocoachina.com/ios/20150115/10926.html">iOS 8 Handoff 开发指南</a>。我们在此只是简单描述一下这几个方法。</p>

<p>在UIResponder中，已经为我们提供了一个userActivity属性，它是一个NSUserActivity对象。因此我们在UIResponder的子类中不需要再去声明一个userActivity属性，直接使用它就行。其声明如下：</p>

<pre><code>@property(nonatomic, retain) NSUserActivity *userActivity
</code></pre>

<p>由UIKit管理的User Activities会在适当的时间自动保存。一般情况下，我们可以重写UIResponder类的updateUserActivityState:方法来延迟添加表示User Activity的状态数据。当我们不再需要一个User Activity时，我们可以设置userActivity属性为nil。任何由UIKit管理的NSUserActivity对象，如果它没有相关的响应者，则会自动失效。</p>

<p>另外，多个响应者可以共享一个NSUserActivity实例。</p>

<p>上面提到的updateUserActivityState:是用于更新给定的User Activity的状态。其定义如下：</p>

<pre><code>- (void)updateUserActivityState:(NSUserActivity *)activity
</code></pre>

<p>子类可以重写这个方法来按照我们的需要更新给定的User Activity。我们需要使用NSUserActivity对象的addUserInfoEntriesFromDictionary:方法来添加表示用户Activity的状态。</p>

<p>在我们修改了User Activity的状态后，如果想将其恢复到某个状态，则可以使用以下方法：</p>

<pre><code>- (void)restoreUserActivityState:(NSUserActivity *)activity
</code></pre>

<p>子类可以重写这个方法来使用给定User Activity的恢复响应者的状态。系统会在接收到数据时，将数据传递给application:continueUserActivity:restorationHandler:以做处理。我们重写时应该使用存储在user activity的userInfo字典中的状态数据来恢复对象。当然，我们也可以直接调用这个方法。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class">UIResponder Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html">Event Handling Guide for iOS</a></li>
<li><a href="http://www.cnblogs.com/kuku/archive/2011/11/12/2246389.html">iOS UIResponder 学习笔记</a></li>
<li><a href="http://firestudio.cn/blog/2013/12/26/ru-he-rang-ni-de-ios7ying-yong-zhi-chi-jian-pan-kuai-jie-jian/">如何让你的iOS7应用支持键盘快捷键</a></li>
<li><a href="http://www.cocoachina.com/ios/20150115/10926.html">iOS 8 Handoff 开发指南</a></li>
<li><a href="http://southpeak.github.io/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/">iOS 8 Handoff Tutorial</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译篇：iOS 8 Handoff Tutorial]]></title>
    <link href="http://southpeak.github.io/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/"/>
    <updated>2015-03-01T12:33:51+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial</id>
    <content type="html"><![CDATA[<p>原文由Soheil Azarpour发表于raywenderlich，地址是<a href="http://www.raywenderlich.com/84174/ios-8-handoff-tutorial">iOS 8 Handoff Tutorial</a></p>

<p>Handoff是iOS 8和OS X Yosemite中的一个新特性。它让我们在不同的设备间切换时，可以不间断地继续一个Activity，而不需要重新配置任何设备。</p>

<p>我们可以为在iOS 8和Yosemite上的应用添加Handoff特性。在这篇指南中，我们将学习Handoff的基本功能和如何在非基于文档的app中使用Handoff。</p>

<h2>Handoff概览</h2>

<p>在开始写代码前，我们需要先来了解一下handoff的一些基本概念。</p>

<h3>起步</h3>

<p>Handoff不仅可以将当前的activity从一个iOS设备传递到OS X设备，还可以将activity在不同的iOS设备传递。目前在模拟器上还不能使用Handoff功能，所以需要在iOS设备上运行我们的实例。</p>

<h4>设备兼容性：iOS</h4>

<p>为了查看我们的iOS设备是否支持handoff功能，我们可以查看“设置”->“通用”列表。如果在列表中看到“Handoff与建议的应用程序”，则设备具备Handoff功能。以下截图显示了iPhone 5s(具备Handoff功能)和iPad3(不具备Handoff功能)的对比：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/settings_screenshots-436x320.jpg" alt="image" /></p>

<p>Handoff功能依赖于以下几点：</p>

<ol>
<li>一个iCloud账户：我们必须在希望使用Handoff功能的多台设备上登录同一个iCloud账户。</li>
<li>低功耗蓝牙(Bluetooth LE 4.0)：Handoff是通过低功耗蓝牙来广播activities的，所以广播设备和接收设备都必须支持Bluetooth LE 4.0。</li>
<li>iCloud配对：设备必须已经通过iCloud配对。当在支持Handoff的设备上登录iCloud账户后，每台设备都会与其它支持Handoff的设备进行配对。</li>
</ol>


<p>此时，我们需要确保已经使用同一iCloud账号在两台支持Handoff功能且运行iOS 8+系统的设备上登录了。(译者注：具体配置可以参考<a href="https://support.google.com/chrome/answer/6153783?hl=zh-Hans">在 Chrome（iOS 版）中使用 Handoff</a>)</p>

<h3>User Activities</h3>

<p>Handoff是基于User Activity的。User Activity是一个独立的信息集合单位，可以不依赖于任何其它信息而进行传输(be handed off)。</p>

<p>NSUserActivity对象表示一个User Activity实例。它封装了程序的一些状态，这些状态可以在其它设备相关的程序中继续使用。</p>

<p>有三种方法和一个NSUserActivity对象交互：</p>

<p>1) 创建一个user activity：原始应用程序创建一个NSUserActivity实例并调用becomeCurrent()以开启一个广播进程。下面是一个实例：</p>

<pre><code>let activity = NSUserActivity(activityType: "com.razeware.shopsnap.view")
activity.title = "Viewing"
activity.userInfo = ["shopsnap.item.key": ["Apple", "Orange", "Banana"]]
self.userActivity = activity;
self.userActivity?.becomeCurrent()
</code></pre>

<p>我们可以使用NSUserActivity的userInfo字典来传递本地数据类型对象或可编码的自定义对象以将其传输到接收设备。本地数据类型包括NSArray, NSData, NSDate, NSDictionary, NSNull, NSNumber, NSSet, NSString, NSUUID和NSURL。通过NSURL可能会有点棘手。在使用NSURL前可以先参考一下下面的“最佳实践”一节。</p>

<p>2) 更新user activity：一旦一个NSUserActivity成为当前的activity，则iOS会在最上层的视图控制器中调用updateUserActivityState(activity:)方法，以让我们有机会来更新user activity。下面是一个实例：</p>

<pre><code>override func updateUserActivityState(activity: NSUserActivity) {
  let activityListItems = // ... get updated list of items
  activity.addUserInfoEntriesFromDictionary(["shopsnap.item.key": activityListItems])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>注意我们不要将userInfo设置为一个新的字典或直接更新它，而是应该使用便捷方法addUserInfoEntriesFromDictionary()。</p>

<p>在下文中，我们将学习如何按需求强制刷新user activity，或者是在程序的app delegate级别来获取一个相似功能的回调。</p>

<p>3) 接收user activity：当我们的接收程序以Handoff的方式启动时，程序代理会调用application(:willContinueUserActivityWithType:)方法。注意这个方法的参数不是NSUserActivity对象，因为接收程序在下载并传递NSUserActivity数据需要花费一定的时间。在user activity已经被下载完成后，会调用以下的回调函数：</p>

<pre><code>func application(application: UIApplication!, 
                 continueUserActivity userActivity: NSUserActivity!,
                 restorationHandler: (([AnyObject]!) -&gt; Void)!) 
                 -&gt; Bool {

  // Do some checks to make sure you can proceed
  if let window = self.window {
    window.rootViewController?.restoreUserActivityState(userActivity)
  }
  return true
}
</code></pre>

<p>然后我们可以使用存储在NSUserActivity对象中的数据来重新创建用户的activity。在这里，我们更新我们的应用以继续相关的activity。</p>

<h3>Activity类型</h3>

<p>当创建一个user activity后，我们必须为其指定一个activity类型。一个activity类型是一个简单的唯一字符串，通常使用反转DNS语义，如com.razeware.shopsnap.view。</p>

<p>每一个可以接收user activity的程序都必须声明其可接收的activity类型。这类似于在程序中声明支持的URL方案(URL scheme)。对于非基于文本的程序，activity类型需要在Info.plist文件中定义，其键值为NSUserActivityTypes，如下所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/image10-38-480x259.png" alt="image" /></p>

<p>对于支持一个给定activity的程序来说，需要满足三个要求：</p>

<ol>
<li>相同的组：两个程序都必须源于使用同一开发者组ID(developer Team ID)的开发者。</li>
<li>相同的activity类型：发送程序创建某一activity类型的user activity，接收程序必须有相应类型的NSUserActivityTypes入口。</li>
<li>签约：两个程序必须通过App store来发布或使用同一开发者账号来签约。</li>
</ol>


<p>现在我们已经学习了user activities和activity类型的基础知识，接下来让我们来看一个实例。</p>

<h2>启动工程</h2>

<p>本指南的启动工程可以在“<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/10/ShopSnap-Starter.zip">启动工程</a>”中下载。下载后，使用Xcode打开工程并在iPhone模拟器中运行。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/App_Screenshots-700x412.jpg" alt="image" /></p>

<p>工程名是ShopSnap，我们可以在这个程序中构建一个简单的购物清单。一个购物项由一个字符串表示，然后我们将购物项存储在一个字符串的数组中。点击+按钮添加一个新的项目到清单中，而轻扫可以移除项目。</p>

<p>我们将在程序中定义两个独立的user activity：</p>

<ol>
<li>查看清单。如果用户当前正在查看清单，我们将传输整个数组。</li>
<li>添加或编译项目。如果用户当前正在添加新的项目，我们将传递一个单一项目的“编辑”activity。</li>
</ol>


<h3>设置开发组</h3>

<p>为了让Handoff工作，发送和接收app都必须使用相同的开发组来签约。由于这个示例程序即是发送者也是接收者，所以这很简单！</p>

<p>选择ShopSnap工程，在“通用”选项卡中，在&#8221;Team&#8221;中选择自己的开发组：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/10/image15-49-700x232.png" alt="image" /></p>

<p>在支持Handoff的设备中编译并运行程序，以确保运行正常，然后继续。</p>

<h3>配置activity类型</h3>

<p>接下来是配置程序所支持的activity类型。打开&#8221;Supporting Files\Info.plist&#8221;，点击&#8221;Information Property List&#8221;旁边的&#8221;+&ldquo;按钮，在&#8221;Information Property List&#8221;中添加一个新的选项：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image16-52-480x268.png" alt="image" /></p>

<p>键名为&#8221;NSUserActivityTypes&#8221;，类型设备为数组类型，如下所示：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/10/image17-55-480x233.png" alt="image" /></p>

<p>在NSUserActivityTypes下添加两项并设置类型为字符串。Item 0的值为com.razeware.shopsnap.view，Item 1的值为com.razeware.shopsnap.edit。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image18-58-480x85.png" alt="image" /></p>

<p>这些任意的activity类型对于我们的程序来说是特定和唯一的。因为我们将在程序的不同地方引用它们，所以在独立的文件中将其添加为常量是一种好的实践。</p>

<p>在工程导航中右键点击ShopSnap组，选择&#8221;New File \ iOS \ Source \ Swift File&#8221;。将文件命名为Constants.swift并确保新类被添加到ShopSnap target中。</p>

<p>在类中添加以下代码：</p>

<pre><code>let ActivityTypeView = "com.razeware.shopsnap.view"
let ActivityTypeEdit = "com.razeware.shopsnap.edit"

let ActivityItemsKey = "shopsnap.items.key"
let ActivityItemKey  = "shopsnap.item.key"
</code></pre>

<p>然后我们就可以使用这两个activity类型的常量。同时我们定义一些用于user activity的userInfo字典的键名字符串。</p>

<h3>快速端到端测试</h3>

<p>让我们来运行一个快速端到端测试以确保设备可以正确地通信。</p>

<p>打开ListViewController.swift并添加以下两个函数：</p>

<pre><code>// 1.
func startUserActivity() {
  let activity = NSUserActivity(activityType: ActivityTypeView)
  activity.title = "Viewing Shopping List"
  activity.userInfo = [ActivityItemsKey: ["Ice cream", "Apple", "Nuts"]]
  userActivity = activity
  userActivity?.becomeCurrent()
}

// 2.
override func updateUserActivityState(activity: NSUserActivity) {
  activity.addUserInfoEntriesFromDictionary([ActivityItemsKey: ["Ice cream", "Apple", "Nuts"]])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>我们通过硬编码一个user activity来快速测试，以确保我们可以在另一端正常接收。</p>

<p>上面的代码做了以下两件事：</p>

<ol>
<li>startUserActivity()是一个辅助函数，它使用一个硬编码的购物清单来创建了一个NSUserActivity实例。然后调用becomeCurrent()来广播这个activity。</li>
<li>在调用becomeCurrent()后，系统将定期调用updateUserActivityState()。UIViewController从UIResponder类中继承了这个方法，我们应该重写它来更新我们的userActivity的状态。在这里，我们像前面一样使用硬编码来更新购物清单。注意，我们应该使用addUserInfoEntriesFromDictionary方法来修改NSUserActivity的userInfo字典。我们应该总是在方法的结尾调用super.updateUserActivityState()。</li>
</ol>


<p>注意，我们只需要调用上面的起始方法。在viewDidLoad()起始行下面添加以下代码</p>

<pre><code>startUserActivity()
</code></pre>

<p>开始广播至少需要以上步骤。现在来看看接收者。打开AppDelegate.swift并添加以下代码：</p>

<pre><code>func application(application: UIApplication!, 
                 continueUserActivity userActivity: NSUserActivity!, 
                 restorationHandler: (([AnyObject]!) -&gt; Void)!) 
                 -&gt; Bool {

  let userInfo = userActivity.userInfo as NSDictionary
  println("Received a payload via handoff: \(userInfo)")
  return true
}
</code></pre>

<p>AppDelegate中的这个方法在所有事情都准备好，且一个userActivity被成功传送后调用。在这里我们简单打印userActivity中的userInfo字典。我们返回true来标识我们处理了user activity。</p>

<p>让我们来试试！要想在两台设备中正常工作，还需要做一些协调工作，所以还得仔细跟着。</p>

<ol>
<li>在第一台设备上安装并运行程序。</li>
<li>在第二台设备上安装并运行程序。确保在Xcode中调用程序以便我们能看到打印输出。</li>
<li><p>按下电源按钮让第二台设备休眠。在同一台设备上，按下Home键。如果所有事件都正常运行，我们应该可以看到ShopSnap程序的icon显示在屏幕的左下角上。从这里我们可以启动程序，然后在Xcode控制台可以看到以下的日志信息：</p>

<p> Received a payload via handoff: {
     &ldquo;shopsnap.items.key&rdquo; = (
     &ldquo;Ice cream&rdquo;,
     Apple,
     Nuts
   );
 }</p></li>
</ol>


<p>如果在锁屏下没有看到程序的icon，则在源设备上关闭并重新打开程序。这将强制系统重新广播信息。同时确认一下设备的控制台以查看是否有来自于Handoff的错误消息。</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/10/image20-63-180x320.png" alt="image" /></p>

<h2>创建一个新的Activity</h2>

<p>现在我们有一个基本上可以工作的Handoff程序，是时候来扩展它了。打开ListViewController.swift，更新startUserActivity()方法，这次我们传入实际的购物清单以代码硬编码。使用以下代码来更新方法：</p>

<pre><code>func startUserActivity() {
  let activity = NSUserActivity(activityType: ActivityTypeView)
  activity.title = "Viewing Shopping List"
  activity.userInfo = [ActivityItemsKey: items]
  userActivity = activity
  userActivity?.becomeCurrent()
}
</code></pre>

<p>同样，更新ListViewController.swift的updateUserActivityState(activity:)方法，传递购物清单数组：</p>

<pre><code>override func updateUserActivityState(activity: NSUserActivity) {
  activity.addUserInfoEntriesFromDictionary([ActivityItemsKey: items])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>现在，更新ListViewController.swift中的viewDidLoad()，在从前面的代码中成功获取到清单后开启userActivity，如下所示：</p>

<pre><code>override func viewDidLoad() {
  title = "Shopping List"
  weak var weakSelf = self
  PersistentStore.defaultStore().fetchItems({ (items:[String]) in
    if let unwrapped = weakSelf {
      unwrapped.items = items
      unwrapped.tableView.reloadData()
      if items.isEmpty == false {
        unwrapped.startUserActivity()
      }
    }
  })
  super.viewDidLoad()
}
</code></pre>

<p>当然，如果程序开始时，清单是空的，则程序不会去广播user activity。我们需要解决这个问题：在用户第一次添加一个购物项到列表时开启user activity。</p>

<p>为了做到这一点，更新ListViewController.swift中代理回调detailViewController(controller:didFinishWithUpdatedItem:)的实现，如下所示：</p>

<pre><code>func detailViewController(#controller: DetailViewController,
                          didFinishWithUpdatedItem item: String) {
    // ... some code
    if !items.isEmpty {
      startUserActivity()
    }
}
</code></pre>

<p>在此有三种可能：</p>

<ol>
<li>用于更新一个已存在的购物项</li>
<li>用户删除一个存在的购物项</li>
<li>用户添加一个新的购物项</li>
</ol>


<p>现存的代码处理了所有的可能性；我们只需要添加一些检测代码，以在有一个非空的清单时开始一个activity。</p>

<p>在两台设备上编译并运行。此时，我们应该可以在一台设备上添加新的项目，然后将其发送给另外一台设备。</p>

<h3>收尾</h3>

<p>当用户开始添加一个新的项目或编辑一个已存在的项目时，用户可能不是在查看购物清单。所以我们需要停止广播当前activity。同样，当清单中的所有项目被删除时，没有理由去继续广播当前activiry。在ListViewController.swift中添加以下辅助方法：</p>

<pre><code>func stopUserActivity() {
  userActivity?.invalidate()
}
</code></pre>

<p>在stopUserActivity()中，我们废止已存在的NSUserActivity。这让handoff停止广播。</p>

<p>现在有了stopUserActivity()，是时候在适当的地方调用它了。</p>

<p>在ListViewController.swift中，更新prepareForSegue(segue:, sender:)方法的实现，如下所示：</p>

<pre><code>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject!) {
    // ... some code
    stopUserActivity()
}
</code></pre>

<p>当用户选择一行或者点击添加按钮时，ListViewController准备导航到详情视图。我们废弃当前的清单查看activity。</p>

<p>在同一文件中，更新tableView(_:commitEditingStyle:forRowAtIndexPath:)的实现，如下所示：</p>

<pre><code>override func tableView(tableView: UITableView, 
                        commitEditingStyle editingStyle: UITableViewCellEditingStyle,
                        forRowAtIndexPath indexPath: NSIndexPath) {
  // ... some code
  if items.isEmpty {
    stopUserActivity()
  } else {
    userActivity?.needsSave = true
  }
}
</code></pre>

<p>当用户从清单中删除一项时，我们需要相应地更新user activity。如果移除清单中的所有项目，我们停止广播。否则，我们设置userActivity的needsSave属性为true。当我们这样做时，系统会立即回调updateUserActivityState(activity:)，在这里我们会更新userActivity。</p>

<p>结束这一节之前，还有一种情况需要考虑，用户点击取消按钮，然后从DetailViewController中返回。这触发了一个已存在的场景。我们需要重新开始userActivity。更新unwindDetailViewController(unwindSegue:)的实现，如下所示：</p>

<pre><code>@IBAction func unwindDetailViewController(unwindSegue: UIStoryboardSegue) {
  // ... some code
  startUserActivity()
}
</code></pre>

<p>编译并运行，确保所有事情运行正常。尝试添加一些项目到清单中，确保它们在设备间传输。</p>

<h2>创建一个编辑Activity</h2>

<p>接下来，我们以类似的方式来处理DetailViewController。这一次，我们广播另一个activity类型。</p>

<p>打开DetailViewController.swift并修改textFieldDidBeginEditing(textField:)，如下所示：</p>

<pre><code>func textFieldDidBeginEditing(textField: UITextField!) {
  // Broadcast what we have, if there is anything!
  let activity = NSUserActivity(activityType: ActivityTypeEdit)
  activity.title = "Editing Shopping List Item"
  let activityItem = (countElements(textField.text!) &gt; 0) ? textField.text : ""
  activity.userInfo = [ActivityItemKey: activityItem]
  userActivity = activity
  userActivity?.becomeCurrent()
}
</code></pre>

<p>上面的方法使用项目的字符串的当前内容创建一个“编辑”activity。</p>

<p>当用户继续编辑项目时，我们需要更新user activity。仍然是在DetailViewController.swift中，更新textFieldTextDidChange(notification:)的实现，如下所示：</p>

<pre><code>func textFieldTextDidChange(notification: NSNotification) {
  if let text = textField!.text {
    item = text
  }

  userActivity?.needsSave = true
}
</code></pre>

<p>现在我们已经标记了activity需要更新，接下来实现updateUserActivityState(activity:)，以备系统的更新需求：</p>

<pre><code>override func updateUserActivityState(activity: NSUserActivity) {
  let activityListItem = (countElements(textField!.text!) &gt; 0) ? textField!.text : ""
  activity.addUserInfoEntriesFromDictionary([ActivityItemKey: activityListItem])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>这里我们简单地更新了当前项为文本输入框中的文本。</p>

<p>编译并运行。此时，如果我们在一个设备中开始添加一个新项或编辑已存在的项目，我们可以将编辑进程同步给另一个设备。</p>

<h3>收尾</h3>

<p>因为needsSave是一个轻量级的操作，在上面的代码中，你可以根据需要来设置它，然后在每次按键时更新userInfo。</p>

<p>这里有一个小细节你可能已经注意到了。视图控制器在iPad和iPhone的景观模式下中是一个分离视图。这样可以在清单的项目间切换而不需要收起键盘。这种情况发生时，textFieldDidBeginEditing(textField:)方法不会被调用，导致我们的user activity不会更新为新的文本。</p>

<p>为了解决这个问题，更新DetailViewController.swift中item属性的didSet观察者，如下所示：</p>

<pre><code>var item: String? {
  didSet {
    if let textField = self.textField {
      textField.text = item
    }
    if let activity = userActivity {
      activity.needsSave = true
    }
  }
}
</code></pre>

<p>当用户点击ListViewController中的一个项目时，DetailViewController的item属性被设置。一个简单解决方案是让视图控制器知道，在项目更新时它必须更新activity。</p>

<p>最后，当用户离开DetailViewController时，我们需要废止userActivity，以让编辑activity不再被广播。</p>

<p>在DetailViewController.swift的textFieldShouldReturn(_:)方法的起始位置添加以下代码：</p>

<pre><code>userActivity?.invalidate()
</code></pre>

<p>编译并运行程序，确保程序工作正常。接下来，我们将处理接收的activity。</p>

<h2>接收Activity</h2>

<p>当用户通过Handoff启动程序时，处理接收的NSUserActivity的任务大部分是由程序的delegate来完成的。</p>

<p>假设所有事情运行正常，数据成功传输，iOS会调用application(_:continueUserActivity:restorationHandler:)方法。这是我们与NSUserActivity实例交互的第一次机会。</p>

<p>我们在前面的章节中已经有一个该方法的实现了。现在，我们做如下修改：</p>

<pre><code>func application(application: UIApplication!, 
                 continueUserActivity userActivity: NSUserActivity!,
                 restorationHandler: (([AnyObject]!) -&gt; Void)!)
                 -&gt; Bool {

  if let window = self.window {
    window.rootViewController?.restoreUserActivityState(userActivity)
  }
  return true
}
</code></pre>

<p>我们将userActivity传递给程序的window对象的rootViewController，然后返回true。这告诉系统成功处理了Handoff行为。从这里开始，我们将自己转发调用并恢复activity。</p>

<p>我们在rootViewController中调用的方法是restoreUserActivityState(activity:)。这是在UIResponder中声明的一个标准方法。系统使用这个方法来告诉接收者恢复一个NSUserActivivty实例。</p>

<p>我们现在的任务是沿着视图控制器架构往下，将activity从父视图控制器传递到子视图控制器，直到到达需要使用activity的地方：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image22-691-700x360.png" alt="image" /></p>

<p>根视图控制器是一个TraitOverrideViewController对象，它的任务是管理程序的size classes；它对我们的user activity不感兴趣。打开TraitOverrideViewController.swift并添加以下代码：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  let nextViewController = childViewControllers.first as UIViewController
  nextViewController.restoreUserActivityState(activity)
  super.restoreUserActivityState(activity)
}
</code></pre>

<p>在这里，我们获取TraitOverrideViewController的第一个子视图控制器，然后将activity往下传递。这样做是安全的，因为我们知道程序的视图控制器只包含一个子视图控制器。</p>

<p>层级架构中的下一个视图控制器是SplitViewController，在这里事情会变得更有趣一些。</p>

<p>打开SplitViewController.swift并添加以下代码：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  // What type of activity is it?
  let activityType = activity.activityType

  // This is an activity for ListViewController.
  if activityType == ActivityTypeView {
    let controller = viewControllerForViewing()
    controller.restoreUserActivityState(activity)

  } else if activityType == ActivityTypeEdit {
    // This is an activity for DetailViewController.
    let controller = viewControllerForEditing()
    controller.restoreUserActivityState(activity)
  }

  super.restoreUserActivityState(activity)
}
</code></pre>

<p>SplitViewController知道ListViewController和DetailViewController。如果NSUserActivity是一个列表查看activity类型，则将其传递给ListViewController；否则，如果是一个编辑activity类型，则传递给DetailViewController。</p>

<p>我们将所有的activity传递给正确的对象，现在是时候从这些activity中获取数据了。</p>

<p>打开ListViewController.swift并实现restoreUserActivityState(activity:)，如下所示：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  // Get the list of items.
  if let userInfo = activity.userInfo {
    if let importedItems = userInfo[ActivityItemsKey] as? NSArray {
      // Merge it with what we have locally and update UI.
      for anItem in importedItems {
        addItemToItemsIfUnique(anItem as String)
      }
      PersistentStore.defaultStore().updateStoreWithItems(items)
      PersistentStore.defaultStore().commit()
      tableView.reloadData()
    }
  }
  super.restoreUserActivityState(activity)
}
</code></pre>

<p>在上面的方法中，我们终于可以继续一个查看activity了。因为我们需要维护一个唯一的购物清单时，我们只需要将这些唯一的项目添加到本地列表中，然后保存并更新UI。</p>

<p>编译并运行。现在我们可以看到通过Handoff从另一台设备上同步过来的清单数据了。</p>

<p>编辑activity以类似的方法来处理。打开DetailViewController.swift并实现restoreUserActivityState(activity:)，如下所示：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  if let userInfo = activity.userInfo {
    var activityItem: AnyObject? = userInfo[ActivityItemKey]
    if let itemToRestore = activityItem as? String {
      item = itemToRestore
      textField?.text = item
    }
  }
  super.restoreUserActivityState(activity)
}
</code></pre>

<p>这里获取编辑activity的信息并更新文本域的内容。</p>

<p>编译并运行，查看运行结果！</p>

<h3>收尾</h3>

<p>当用户在另一台设备上点击程序的icon以表明他们想要继续一个user activity时，系统启动相应的程序。一旦程序启动后，系统调用application(_, willContinueUserActivityWithType:)方法。打开AppDelegate.swift并添加以下方法：</p>

<pre><code>func application(application: UIApplication,
                 willContinueUserActivityWithType userActivityType: String!)
                 -&gt; Bool {
  return true
}
</code></pre>

<p>到这里，我们的程序已经下载了NSUserActivity实例及其userInfo有效载荷。现在我们只是简单返回true。这强制程序在每次用户初始Handoff进程时接收activity。如果想要通知用户activity正在处理，则这是个好地方。</p>

<p>到这里，系统开始将数据从一台设备同步到另一台设备上。我们已经覆盖了任务正常运行的所有情况。但是可以想象Handoff的activity在某些情况下会失败。</p>

<p>将以下方法添加到AppDelegate.swift中来处理这种情况：</p>

<pre><code>func application(application: UIApplication!, 
                 didFailToContinueUserActivityWithType userActivityType: String!,
                 error: NSError!) {

  if error.code != NSUserCancelledError {
    let message = "The connection to your other device may have been interrupted. Please try again. \(error.localizedDescription)"
    let alertView = UIAlertView(title: "Handoff Error", message: message, delegate: nil, cancelButtonTitle: "Dismiss")
    alertView.show()
  }
}
</code></pre>

<p>如果我们接收到除了NSUserCancelledError之外的任何信息，则发生了某些错误，且我们不能恢复activity。在这种情况下，我们显示一个适当的消息给用户。然而，如果用户显示取消Handoff行为，则在这里我们不需要做任何事情，只需要放弃操作。</p>

<h2>版本支持</h2>

<p>使用Handoff的最佳实践之一是版本化。处理这的一个策略是为每个发送的Handoff添加一个版本号，并且只接收来自这个版本号(或者更早的)handoff。让我们来试试。</p>

<p>打开Constants.swift并添加以下常量：</p>

<pre><code>let ActivityVersionKey = "shopsnap.version.key"
let ActivityVersionValue = "1.0"
</code></pre>

<p>上面的版本键名和值是我们为这个版本的程序随意挑选的键值对。</p>

<p>如果我们回顾一下上面的章节，系统会定期并自动调用restoreUserActivityState(activity:)方法。这个方法的实现聚集于并限定于实现它的对象的范围内。例如，ListViewController重写了这个方法来更新带有购物清单的userActivity，而DetailViewController的实现是更新当前正在被编辑的项目。</p>

<p>如果涉及到的东西对于userActivity来说是通用的，可用于所有的user activity，如版本号，则处理它的最好的地方就是在AppDelegate中了。</p>

<p>任何时候调用restoreUserActivityState(activity:)，系统都会紧接着调用程序delegate的application(application:, didUpdateUserActivity userActivity:)方法。我们使用这个方法来为我们的Handoff添加版本支持。</p>

<p>打开AppDelegate.swift并添加以下代码：</p>

<pre><code>func application(application: UIApplication, 
                 didUpdateUserActivity userActivity: NSUserActivity) {
  userActivity.addUserInfoEntriesFromDictionary([ActivityVersionKey: ActivityVersionValue])
}
</code></pre>

<p>在这里我们简单地使用了程序的版本号来更新了userInfo字典。</p>

<p>仍然是在AppDelegate.swift中，更新application(_:, continueUserActivity: restorationHandler:)的实现，如下所示：</p>

<pre><code>func application(application: UIApplication!,
                 continueUserActivity userActivity: NSUserActivity!,
                 restorationHandler: (([AnyObject]!) -&gt; Void)!)
                 -&gt; Bool {

  if let userInfo: NSDictionary = userActivity.userInfo {
    if let version = userInfo[ActivityVersionKey] as? String {
      // Pass it on.
      if let window = self.window {
        window.rootViewController?.restoreUserActivityState(userActivity)
      }
      return true
    }
  }
  return false
}
</code></pre>

<p>在这里我们检查userAcitivty的版本，只有当版本号与我们知道的相匹配时才传递。编译并运行，确保程序运行正常。</p>

<h2>Handoff最佳实践</h2>

<p>在结束之前，我们来看看Handoff的最佳实践：</p>

<ol>
<li><p>NSURL：在NSUserActivity的userInfo字典中使用NSURL有点棘手。唯一可以安全地在Handoff中传输的NSURLs是使用HTTP/HTTPS和iCloud文档的web网址。我们不能传递本地文件的URL，因为在接收者端，接收者不能正确地转换并映射这些URL。传输文件链接的最好的方式是传递相对路径，然后在接收者端重新构建我们的URL。</p></li>
<li><p>平台特定值：避免使用平台特定值，如滑动视图的内容偏移量；更好的方法是使用相对位置。例如，如果用户查看table view中的一些项目时，在我们的user activity中传递table view最上面的可视项的index path，而不是传递table view可视区域的内容偏移量。</p></li>
<li><p>版本：想想在程序中使用版本和将来的更新。我们可以在程序的未来版本中添加一些新数据格式或者从userInfo字典中移除值。版本让我们可以理好地控制我们的user activity在当前和将来版本的程序中的行为。</p></li>
</ol>


<h2>下一步是哪</h2>

<p>这里是<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/ShopSnap-Final.zip">示例工程</a>的最终版本。</p>

<p>如果想了解更多的关于Handoff，流和基于文档的Handoff，则可以查看Handoff的开发文档<a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/Handoff/HandoffFundamentals/HandoffFundamentals.html">Apple’s Handoff Programming Guide</a>以获取更多的信息。</p>

<p>如果喜欢这篇文章，则可以下载我们的书<a href="http://www.raywenderlich.com/store/ios-8-by-tutorials">iOS 8 by Tutorials</a>，这里塞满了这样的教程。</p>

<p>如果有更多的总量或关于这篇文章的评论，那么可以加入下面的讨论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSCache]]></title>
    <link href="http://southpeak.github.io/blog/2015/02/11/nscache/"/>
    <updated>2015-02-11T21:45:14+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/02/11/nscache</id>
    <content type="html"><![CDATA[<p>NSCache是一个类似于集合的容器，即缓存。它存储key-value对，这一点类似于NSDictionary类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。如果对象被丢弃了，则下次使用时需要重新计算。</p>

<p>当一个key-value对在缓存中时，缓存维护它的一个强引用。存储在NSCache中的通用数据类型通常是实现了NSDiscardableContent协议的对象。在缓存中存储这类对象是有好处的，因为当不再需要它时，可以丢弃这些内容，以节省内存。默认情况下，缓存中的NSDiscardableContent对象在其内容被丢弃时，会被移除出缓存，尽管我们可以改变这种缓存策略。如果一个NSDiscardableContent被放进缓存，则在对象被移除时，缓存会调用discardContentIfPossible方法。</p>

<p>NSCache与可变集合有几点不同：</p>

<ol>
<li>NSCache类结合了各种自动删除策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用。</li>
<li>NSCache是线程安全的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域。</li>
<li>不像NSMutableDictionary对象，一个缓存对象不会拷贝key对象。</li>
</ol>


<p>这些特性对于NSCache类来说是必须的，因为在需要释放内存时，缓存必须异步地在幕后决定去自动修改自身。</p>

<h2>缓存限制</h2>

<p>NSCache提供了几个属性来限制缓存的大小，如属性countLimit限定了缓存最多维护的对象的个数。声明如下：</p>

<pre><code>@property NSUInteger countLimit
</code></pre>

<p>默认值为0，表示不限制数量。但需要注意的是，这不是一个严格的限制。如果缓存的数量超过这个数量，缓存中的一个对象可能会被立即丢弃、或者稍后、也可能永远不会，具体依赖于缓存的实现细节。</p>

<p>另外，NSCache提供了totalCostLimit属性来限定缓存能维持的最大内存。其声明如下：</p>

<pre><code>@property NSUInteger totalCostLimit
</code></pre>

<p>默认值也是0，表示没有限制。当我们添加一个对象到缓存中时，我们可以为其指定一个消耗(cost)，如对象的字节大小。如果添加这个对象到缓存导致缓存总的消耗超过totalCostLimit的值，则缓存会自动丢弃一些对象，直到总消耗低于totalCostLimit值。不过被丢弃的对象的顺序无法保证。</p>

<p>需要注意的是totalCostLimit也不是一个严格限制，其策略是与countLimit一样的。</p>

<h2>存取方法</h2>

<p>NSCache提供了一组方法来存取key-value对，类似于NSMutableDictionary类。如下所示：</p>

<pre><code>- (id)objectForKey:(id)key

- (void)setObject:(id)obj forKey:(id)key

- (void)removeObjectForKey:(id)key

- (void)removeAllObjects
</code></pre>

<p>如上所述，与NSMutableDictionary不同的就是它不会拷贝key对象。</p>

<p>此外，我们在存储对象时，可以为对象指定一个消耗值，如下所示：</p>

<pre><code>- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)num
</code></pre>

<p>这个消耗值用于计算缓存中所有对象的一个消耗总和。当内存受限或者总消耗超过了限定的最大总消耗，则缓存应该开启一个丢弃过程以移除一些对象。不过，这个过程不能保证被丢弃对象的顺序。其结果是，如果我们试图操作这个消耗值来实现一些特殊的行为，则后果可能会损害我们的程序。通常情况下，这个消耗值是对象的字节大小。如果这些信息不是现成的，则我们不应该去计算它，因为这样会使增加使用缓存的成本。如果我们没有可用的值传递，则直接传递0，或者是使用-setObject:forKey:方法，这个方法不需要传入一个消耗值。</p>

<h2>NSDiscardableContent协议</h2>

<p>NSDiscardableContent是一个协议，实现这个协议的目的是为了让我们的对象在不被使用时，可以将其丢弃，以让程序占用更少的内存。</p>

<p>一个NSDiscardableContent对象的生命周期依赖于一个“counter”变量。一个NSDiscardableContent对象实际是一个可清理内存块，这个内存记录了对象当前是否被其它对象使用。如果这块内存正在被读取，或者仍然被需要，则它的counter变量是大于或等于1的；当它不再被使用时，就可以丢弃，此时counter变量将等于0。当counter变量等于0时，如果当前时间点内存比较紧张的话，内存块就可能被丢弃。</p>

<p>为了丢弃这些内容，可以调用对象的discardContentIfPossible方法，该方法的声明如下：</p>

<pre><code>- (void)discardContentIfPossible
</code></pre>

<p>这样当counter变量等于0时将会释放相关的内存。而如果counter变量不为0，则该方法什么也不做。</p>

<p>默认情况下，NSDiscardableContent对象的counter变量初始值为1，以确保对象不会被内存管理系统立即释放。从这个点开始，我们就需要去跟踪counter变量的状态。为此。协议声明了两个方法：beginContentAccess和endContentAccess。</p>

<p>其中调用beginContentAccess方法会增加对象的counter变量(+1)，这样就可以确保对象不会被丢弃。该方法声明如下：</p>

<pre><code>- (BOOL)beginContentAccess
</code></pre>

<p>通常我们在对象被需要或者将要使用时调用这个方法。具体的实现类可以决定在对象已经被丢弃的情况下是否重新创建这些内存，且重新创建成功后返回YES。协议的实现者在NSDiscardableContent对象被使用，而又没有调用它的beginContentAccess方法时，应该抛出一个异常。</p>

<p>函数的返回值如果是YES，则表明可丢弃内存仍然可用且已被成功访问；否则返回NO。另外需要注意的是，该方法是在实现类中必须实现(required)。</p>

<p>与beginContentAccess相对应的是endContentAccess。如果可丢弃内存不再被访问时调用。其声明如下：</p>

<pre><code>- (void)endContentAccess
</code></pre>

<p>该方法会减少对象的counter变量，通常是让对象的counter值变回为0，这样在对象的内容不再被需要时，就要以将其丢弃。</p>

<p>NSCache类提供了一个属性，来标识缓存是否自动舍弃那些内存已经被丢弃的对象(discardable-content object)，其声明如下：</p>

<pre><code>@property BOOL evictsObjectsWithDiscardedContent
</code></pre>

<p>如果设置为YES，则在对象的内存被丢弃时舍弃对象。默认值为YES。</p>

<h2>NSCacheDelegate代理</h2>

<p>NSCache对象还有一个代理属性，其声明如下：</p>

<pre><code>@property(assign) id&lt; NSCacheDelegate &gt; delegate
</code></pre>

<p>实现NSCacheDelegate代理的对象会在对象即将从缓存中移除时执行一些特定的操作，因此代理对象可以实现以下方法：</p>

<pre><code>- (void)cache:(NSCache *)cache willEvictObject:(id)obj
</code></pre>

<p>需要注意的是在这个代理方法中不能修改cache对象。</p>

<h2>小结</h2>

<p>实际上，我们常用的SDWebImage图片下载库的缓存机制就是通过NSCache来实现的。《Effective Objective-C 2.0》中也专门用一小篇的内容来介绍NSCache的使用(第50条：构建缓存时选用NSCache而非NSDictionary)，里面有更精彩的内容。如果我们需要构建缓存机制，则应该使用NSCache，而不是NSDictionary，这样可以减少我们应用对内存的占用，从而达到优化内存的目标。</p>

<p><em>题外话：最近好好久不用的微博整理了一下，重新开始混微博圈了，哈哈，还是个菜鸟。还望大家多提意见啊。微博号：南峰子_老驴(<a href="http://weibo.com/touristdiary">http://weibo.com/touristdiary</a>)</em></p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/">NSCache Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSDiscardableContent_Protocol/index.html">NSDiscardableContent Protocol Reference</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSCacheDelegate_Protocol/index.html">NSCacheDelegate Protocol Reference</a></li>
<li><a href="http://www.15yan.com/story/45toOUzFGlr/">Objective-C中的缓存: NSCache介绍</a></li>
<li><a href="http://nshipster.cn/nscache/">NSCache</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[源码篇：SDWebImage]]></title>
    <link href="http://southpeak.github.io/blog/2015/02/07/yuan-ma-pian-:sdwebimage/"/>
    <updated>2015-02-07T23:30:45+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/02/07/yuan-ma-pian-:sdwebimage</id>
    <content type="html"><![CDATA[<p>源码来源：<a href="https://github.com/rs/SDWebImage">https://github.com/rs/SDWebImage</a></p>

<p>版本: 3.7</p>

<p>SDWebImage是一个开源的第三方库，它提供了UIImageView的一个分类，以支持从远程服务器下载并缓存图片的功能。它具有以下功能：</p>

<ol>
<li>提供UIImageView的一个分类，以支持网络图片的加载与缓存管理</li>
<li>一个异步的图片加载器</li>
<li>一个异步的内存+磁盘图片缓存</li>
<li>支持GIF图片</li>
<li>支持WebP图片</li>
<li>后台图片解压缩处理</li>
<li>确保同一个URL的图片不被下载多次</li>
<li>确保虚假的URL不会被反复加载</li>
<li>确保下载及缓存时，主线程不被阻塞</li>
</ol>


<p>从github上对SDWebImage使用情况就可以看出，SDWebImage在图片下载及缓存的处理方面还是很被认可的。在本文中，我们主要从源码的角度来分析一下SDWebImage的实现机制。讨论的内容将主要集中在图片的下载及缓存，而不包含对GIF图片及WebP图片的支持操作。</p>

<h2>下载</h2>

<p>在SDWebImage中，图片的下载是由SDWebImageDownloader类来完成的。它是一个异步下载器，并对图像加载做了优化处理。下面我们就来看看它的具体实现。</p>

<h3>下载选项</h3>

<p>在下载的过程中，程序会根据设置的不同的下载选项，而执行不同的操作。下载选项由枚举SDWebImageDownloaderOptions定义，具体如下</p>

<pre><code>typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) {
    SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0,
    SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,

    // 默认情况下请求不使用NSURLCache，如果设置该选项，则以默认的缓存策略来使用NSURLCache
    SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,

    // 如果从NSURLCache缓存中读取图片，则使用nil作为参数来调用完成block
    SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,

    // 在iOS 4+系统上，允许程序进入后台后继续下载图片。该操作通过向系统申请额外的时间来完成后台下载。如果后台任务终止，则操作会被取消
    SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,

    // 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie
    SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,

    // 允许不受信任的SSL证书。主要用于测试目的。
    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,

    // 将图片下载放到高优先级队列中
    SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,
};
</code></pre>

<p>可以看出，这些选项主要涉及到下载的优先级、缓存、后台任务执行、cookie处理以认证几个方面。</p>

<h3>下载顺序</h3>

<p>SDWebImage的下载操作是按一定顺序来处理的，它定义了两种下载顺序，如下所示</p>

<pre><code>typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) {

    // 以队列的方式，按照先进先出的顺序下载。这是默认的下载顺序
    SDWebImageDownloaderFIFOExecutionOrder,

    // 以栈的方式，按照后进先出的顺序下载。
    SDWebImageDownloaderLIFOExecutionOrder
};
</code></pre>

<h3>下载管理器</h3>

<p>SDWebImageDownloader下载管理器是一个单例类，它主要负责图片的下载操作的管理。图片的下载是放在一个NSOperationQueue操作队列中来完成的，其声明如下：</p>

<pre><code>@property (strong, nonatomic) NSOperationQueue *downloadQueue;
</code></pre>

<p>默认情况下，队列最大并发数是6。如果需要的话，我们可以通过SDWebImageDownloader类的<strong>maxConcurrentDownloads</strong>属性来修改。</p>

<p>所有下载操作的网络响应序列化处理是放在一个自定义的并行调度队列中来处理的，其声明及定义如下：</p>

<pre><code>@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t barrierQueue;

- (id)init {
    if ((self = [super init])) {
        ...
        _barrierQueue = dispatch_queue_create("com.hackemist.SDWebImageDownloaderBarrierQueue", DISPATCH_QUEUE_CONCURRENT);
        ...
    }
    return self;
}
</code></pre>

<p>每一个图片的下载都会对应一些回调操作，如下载进度回调，下载完成回调等，这些回调操作是以block形式来呈现，为此在SDWebImageDownloader.h中定义了几个block，如下所示：</p>

<pre><code>// 下载进度
typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);
// 下载完成
typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data, NSError *error, BOOL finished);
// Header过滤
typedef NSDictionary *(^SDWebImageDownloaderHeadersFilterBlock)(NSURL *url, NSDictionary *headers);
</code></pre>

<p>图片下载的这些回调信息存储在SDWebImageDownloader类的<strong>URLCallbacks</strong>属性中，该属性是一个字典，key是图片的URL地址，value则是一个数组，包含每个图片的多组回调信息。由于我们允许多个图片同时下载，因此可能会有多个线程同时操作URLCallbacks属性。为了保证URLCallbacks操作(添加、删除)的线程安全性，SDWebImageDownloader将这些操作作为一个个任务放到barrierQueue队列中，并设置屏障来确保同一时间只有一个线程操作URLCallbacks属性，我们以添加操作为例，如下代码所示：</p>

<pre><code>- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback {

    ...

    // 1. 以dispatch_barrier_sync操作来保证同一时间只有一个线程能对URLCallbacks进行操作
    dispatch_barrier_sync(self.barrierQueue, ^{
        ...

        // 2. 处理同一URL的同步下载请求的单个下载
        NSMutableArray *callbacksForURL = self.URLCallbacks[url];
        NSMutableDictionary *callbacks = [NSMutableDictionary new];
        if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];
        if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];
        [callbacksForURL addObject:callbacks];
        self.URLCallbacks[url] = callbacksForURL;

        ...
    });
}
</code></pre>

<p>整个下载管理器对于下载请求的管理都是放在downloadImageWithURL:options:progress:completed:方法里面来处理的，该方法调用了上面所提到的addProgressCallback:andCompletedBlock:forURL:createCallback:方法来将请求的信息存入管理器中，同时在创建回调的block中创建新的操作，配置之后将其放入downloadQueue操作队列中，最后方法返回新创建的操作。其具体实现如下：</p>

<pre><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock {
    ...

    [self addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^{
        ...

        // 1. 创建请求对象，并根据options参数设置其属性
        // 为了避免潜在的重复缓存(NSURLCache + SDImageCache)，如果没有明确告知需要缓存，则禁用图片请求的缓存操作
        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];
        ...

        // 2. 创建SDWebImageDownloaderOperation操作对象，并进行配置
        // 配置信息包括是否需要认证、优先级
        operation = [[wself.operationClass alloc] initWithRequest:request
                                                          options:options
                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) {
                                                             // 3. 从管理器的callbacksForURL中找出该URL所有的进度处理回调并调用
                                                             ...
                                                             for (NSDictionary *callbacks in callbacksForURL) {
                                                                 SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];
                                                                 if (callback) callback(receivedSize, expectedSize);
                                                             }
                                                         }
                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) {
                                                             // 4. 从管理器的callbacksForURL中找出该URL所有的完成处理回调并调用，
                                                             // 如果finished为YES，则将该url对应的回调信息从URLCallbacks中删除
                                                            ...
                                                            if (finished) {
                                                                [sself removeCallbacksForURL:url];
                                                            }
                                                            for (NSDictionary *callbacks in callbacksForURL) {
                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];
                                                                if (callback) callback(image, data, error, finished);
                                                            }
                                                        }
                                                        cancelled:^{
                                                            // 5. 取消操作将该url对应的回调信息从URLCallbacks中删除
                                                            SDWebImageDownloader *sself = wself;
                                                            if (!sself) return;
                                                            [sself removeCallbacksForURL:url];
                                                        }];

        ...

        // 6. 将操作加入到操作队列downloadQueue中
        // 如果是LIFO顺序，则将新的操作作为原队列中最后一个操作的依赖，然后将新操作设置为最后一个操作
        [wself.downloadQueue addOperation:operation];
        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {
            [wself.lastAddedOperation addDependency:operation];
            wself.lastAddedOperation = operation;
        }
    }];

    return operation;
}
</code></pre>

<p>另外，每个下载操作的超时时间可以通过downloadTimeout属性来设置，默认值为15秒。</p>

<h3>下载操作</h3>

<p>每个图片的下载都是一个Operation操作。我们在上面分析过这个操作的创建及加入操作队列的过程。现在我们来看看单个操作的具体实现。</p>

<p>SDWebImage定义了一个协议，即<strong>SDWebImageOperation</strong>作为图片下载操作的基础协议。它只声明了一个cancel方法，用于取消操作。协议的具体声明如下：</p>

<pre><code>@protocol SDWebImageOperation &lt;NSObject&gt;

- (void)cancel;

@end
</code></pre>

<p>SDWebImage自定义了一个Operation类，即<strong>SDWebImageDownloaderOperation</strong>，它继承自NSOperation，并采用了SDWebImageOperation协议。除了继承而来的方法，该类只向外暴露了一个方法，即上面所用到的初始化方法initWithRequest:options:progress:completed:cancelled:。</p>

<p>对于图片的下载，SDWebImageDownloaderOperation完全依赖于URL加载系统中的NSURLConnection类(并未使用7.0以后的NSURLSession类)。我们先来分析一下SDWebImageDownloaderOperation类中对于图片实际数据的下载处理，即NSURLConnection各代理方法的实现。</p>

<p>首先，SDWebImageDownloaderOperation在分类中采用了NSURLConnectionDataDelegate协议，并实现了该协议的以下几个方法：</p>

<pre><code>- connection:didReceiveResponse:
- connection:didReceiveData:
- connectionDidFinishLoading:
- connection:didFailWithError:
- connection:willCacheResponse:
- connectionShouldUseCredentialStorage:
- connection:willSendRequestForAuthenticationChallenge:
</code></pre>

<p>我们在此不逐一分析每个方法的实现，就重点分析一下-connection:didReceiveData:方法。该方法的主要任务是接收数据。每次接收到数据时，都会用现有的数据创建一个CGImageSourceRef对象以做处理。在首次获取到数据时(width+height==0)会从这些包含图像信息的数据中取出图像的长、宽、方向等信息以备使用。而后在图片下载完成之前，会使用CGImageSourceRef对象创建一个图片对象，经过缩放、解压缩操作后生成一个UIImage对象供完成回调使用。当然，在这个方法中还需要处理的就是进度信息。如果我们有设置进度回调的话，就调用这个进度回调以处理当前图片的下载进度。</p>

<p><em>注：缩放操作可以查看SDWebImageCompat文件中的SDScaledImageForKey函数；解压缩操作可以查看SDWebImageDecoder文件+decodedImageWithImage方法</em></p>

<pre><code>- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
    // 1. 附加数据
    [self.imageData appendData:data];

    if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0 &amp;&amp; self.completedBlock) {

        // 2. 获取已下载数据总大小
        const NSInteger totalSize = self.imageData.length;

        // 3. 更新数据源，我们需要传入所有数据，而不仅仅是新数据
        CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)self.imageData, NULL);

        // 4. 首次获取到数据时，从这些数据中获取图片的长、宽、方向属性值
        if (width + height == 0) {
            CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL);
            if (properties) {
                NSInteger orientationValue = -1;
                CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);
                if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;height);
                ...
                CFRelease(properties);

                // 5. 当绘制到Core Graphics时，我们会丢失方向信息，这意味着有时候由initWithCGIImage创建的图片
                //    的方向会不对，所以在这边我们先保存这个信息并在后面使用。
                orientation = [[self class] orientationFromPropertyValue:(orientationValue == -1 ? 1 : orientationValue)];
            }
        }

        // 6. 图片还未下载完成
        if (width + height &gt; 0 &amp;&amp; totalSize &lt; self.expectedSize) {
            // 7. 使用现有的数据创建图片对象，如果数据中存有多张图片，则取第一张
            CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(imageSource, 0, NULL);

#ifdef TARGET_OS_IPHONE
            // 8. 适用于iOS变形图像的解决方案。我的理解是由于iOS只支持RGB颜色空间，所以在此对下载下来的图片做个颜色空间转换处理。
            if (partialImageRef) {
                const size_t partialHeight = CGImageGetHeight(partialImageRef);
                CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
                CGContextRef bmContext = CGBitmapContextCreate(NULL, width, height, 8, width * 4, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);
                CGColorSpaceRelease(colorSpace);

                if (bmContext) {
                    CGContextDrawImage(bmContext, (CGRect){.origin.x = 0.0f, .origin.y = 0.0f, .size.width = width, .size.height = partialHeight}, partialImageRef);
                    CGImageRelease(partialImageRef);
                    partialImageRef = CGBitmapContextCreateImage(bmContext);
                    CGContextRelease(bmContext);
                }
                else {
                    CGImageRelease(partialImageRef);
                    partialImageRef = nil;
                }
            }
#endif

            // 9. 对图片进行缩放、解码操作
            if (partialImageRef) {
                UIImage *image = [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation];
                NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];
                UIImage *scaledImage = [self scaledImageForKey:key image:image];
                image = [UIImage decodedImageWithImage:scaledImage];
                CGImageRelease(partialImageRef);
                dispatch_main_sync_safe(^{
                    if (self.completedBlock) {
                        self.completedBlock(image, nil, nil, NO);
                    }
                });
            }
        }

        CFRelease(imageSource);
    }

    if (self.progressBlock) {
        self.progressBlock(self.imageData.length, self.expectedSize);
    }
}
</code></pre>

<p>我们前面说过SDWebImageDownloaderOperation类是继承自NSOperation类。它没有简单的实现main方法，而是采用更加灵活的start方法，以便自己管理下载的状态。</p>

<p>在start方法中，创建了我们下载所使用的NSURLConnection对象，开启了图片的下载，同时抛出一个下载开始的通知。当然，如果我们期望下载在后台处理，则只需要配置我们的下载选项，使其包含SDWebImageDownloaderContinueInBackground选项。start方法的具体实现如下：</p>

<pre><code>- (void)start {
    @synchronized (self) {
        // 管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES
        if (self.isCancelled) {
            self.finished = YES;
            [self reset];
            return;
        }

#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0
        // 1. 如果设置了在后台执行，则进行后台执行
        if ([self shouldContinueWhenAppEntersBackground]) {
            __weak __typeof__ (self) wself = self;
            self.backgroundTaskId = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
                ...
                }
            }];
        }
#endif

        self.executing = YES;
        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];
        self.thread = [NSThread currentThread];
    }

    [self.connection start];

    if (self.connection) {
        if (self.progressBlock) {
            self.progressBlock(0, NSURLResponseUnknownLength);
        }

        // 2. 在主线程抛出下载开始通知
        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];
        });

        // 3. 启动run loop
        if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) {
            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);
        }
        else {
            CFRunLoopRun();
        }

        // 4. 如果未完成，则取消连接
        if (!self.isFinished) {
            [self.connection cancel];
            [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@{NSURLErrorFailingURLErrorKey : self.request.URL}]];
        }
    }
    else {
        ... 
    }

#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0
    if (self.backgroundTaskId != UIBackgroundTaskInvalid) {
        [[UIApplication sharedApplication] endBackgroundTask:self.backgroundTaskId];
        self.backgroundTaskId = UIBackgroundTaskInvalid;
    }
#endif
}
</code></pre>

<p>当然，在下载完成或下载失败后，需要停止当前线程的run loop，清除连接，并抛出下载停止的通知。如果下载成功，则会处理完整的图片数据，对其进行适当的缩放与解压缩操作，以提供给完成回调使用。具体可参考-connectionDidFinishLoading:与-connection:didFailWithError:的实现。</p>

<h3>小结</h3>

<p>下载的核心其实就是利用NSURLConnection对象来加载数据。每个图片的下载都由一个Operation操作来完成，并将这些操作放到一个操作队列中。这样可以实现图片的并发下载。</p>

<h2>缓存</h2>

<p>为了减少网络流量的消耗，我们都希望下载下来的图片缓存到本地，下次再去获取同一张图片时，可以直接从本地获取，而不再从远程服务器获取。这样做的另一个好处是提升了用户体验，用户第二次查看同一幅图片时，能快速从本地获取图片直接呈现给用户。</p>

<p>SDWebImage提供了对图片缓存的支持，而该功能是由SDImageCache类来完成的。该类负责处理内存缓存及一个可选的磁盘缓存。其中磁盘缓存的写操作是异步的，这样就不会对UI操作造成影响。</p>

<h3>内存缓存及磁盘缓存</h3>

<p>内存缓存的处理是使用NSCache对象来实现的。NSCache是一个类似于集合的容器。它存储key-value对，这一点类似于NSDictionary类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。</p>

<p>磁盘缓存的处理则是使用NSFileManager对象来实现的。图片存储的位置是位于Cache文件夹。另外，SDImageCache还定义了一个串行队列，来异步存储图片。</p>

<p>内存缓存与磁盘缓存相关变量的声明及定义如下：</p>

<pre><code>@interface SDImageCache ()

@property (strong, nonatomic) NSCache *memCache;
@property (strong, nonatomic) NSString *diskCachePath;
@property (strong, nonatomic) NSMutableArray *customPaths;
@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t ioQueue;

@end

- (id)initWithNamespace:(NSString *)ns {
    if ((self = [super init])) {
        NSString *fullNamespace = [@"com.hackemist.SDWebImageCache." stringByAppendingString:ns];

        ...

        _ioQueue = dispatch_queue_create("com.hackemist.SDWebImageCache", DISPATCH_QUEUE_SERIAL);

        ...

        // Init the memory cache
        _memCache = [[NSCache alloc] init];
        _memCache.name = fullNamespace;

        // Init the disk cache
        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
        _diskCachePath = [paths[0] stringByAppendingPathComponent:fullNamespace];

        dispatch_sync(_ioQueue, ^{
            _fileManager = [NSFileManager new];
        });

        ...
    }

    return self;
}
</code></pre>

<p>SDImageCache提供了大量方法来缓存、获取、移除及清空图片。而对于每个图片，为了方便地在内存或磁盘中对它进行这些操作，我们需要一个key值来索引它。在内存中，我们将其作为NSCache的key值，而在磁盘中，我们用这个key作为图片的文件名。对于一个远程服务器下载的图片，其url是作为这个key的最佳选择了。我们在后面会看到这个key值的重要性。</p>

<h3>存储图片</h3>

<p>我们先来看看图片的缓存操作，该操作会在内存中放置一份缓存，而如果确定需要缓存到磁盘，则将磁盘缓存操作作为一个task放到串行队列中处理。在iOS中，会先检测图片是PNG还是JPEG，并将其转换为相应的图片数据，最后将数据写入到磁盘中(文件名是对key值做MD5摘要后的串)。缓存操作的基础方法是-storeImage:recalculateFromImage:imageData:forKey:toDisk，它的具体实现如下：</p>

<pre><code>- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk {
    ...

    // 1. 内存缓存，将其存入NSCache中，同时传入图片的消耗值
    [self.memCache setObject:image forKey:key cost:image.size.height * image.size.width * image.scale * image.scale];

    if (toDisk) {
        // 2. 如果确定需要磁盘缓存，则将缓存操作作为一个任务放入ioQueue中
        dispatch_async(self.ioQueue, ^{
            NSData *data = imageData;

            if (image &amp;&amp; (recalculate || !data)) {
#if TARGET_OS_IPHONE

                // 3. 需要确定图片是PNG还是JPEG。PNG图片容易检测，因为有一个唯一签名。PNG图像的前8个字节总是包含以下值：137 80 78 71 13 10 26 10
                // 在imageData为nil的情况下假定图像为PNG。我们将其当作PNG以避免丢失透明度。而当有图片数据时，我们检测其前缀，确定图片的类型
                BOOL imageIsPng = YES;

                if ([imageData length] &gt;= [kPNGSignatureData length]) {
                    imageIsPng = ImageDataHasPNGPreffix(imageData);
                }

                if (imageIsPng) {
                    data = UIImagePNGRepresentation(image);
                }
                else {
                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);
                }
#else
                data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];
#endif
            }

            // 4. 创建缓存文件并存储图片
            if (data) {
                if (![_fileManager fileExistsAtPath:_diskCachePath]) {
                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];
                }

                [_fileManager createFileAtPath:[self defaultCachePathForKey:key] contents:data attributes:nil];
            }
        });
    }
}
</code></pre>

<h3>查询图片</h3>

<p>如果我们想在内存或磁盘中查询是否有key指定的图片，则可以分别使用以下方法：</p>

<pre><code>- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key;
- (UIImage *)imageFromDiskCacheForKey:(NSString *)key;
</code></pre>

<p>而如果只是想查看本地是否在key指定的图片，则不管是在内存还是在磁盘上，则可以使用以下方法：</p>

<pre><code>- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock {
    ...

    // 1. 首先查看内存缓存，如果查找到，则直接回调doneBlock并返回
    UIImage *image = [self imageFromDiskCacheForKey:key];
    if (image) {
        doneBlock(image, SDImageCacheTypeMemory);
        return nil;
    }

    // 2. 如果内存中没有，则在磁盘中查找。如果找到，则将其放到内存缓存，并调用doneBlock回调
    NSOperation *operation = [NSOperation new];
    dispatch_async(self.ioQueue, ^{
        if (operation.isCancelled) {
            return;
        }

        @autoreleasepool {
            UIImage *diskImage = [self diskImageForKey:key];
            if (diskImage) {
                CGFloat cost = diskImage.size.height * diskImage.size.width * diskImage.scale * diskImage.scale;
                [self.memCache setObject:diskImage forKey:key cost:cost];
            }

            dispatch_async(dispatch_get_main_queue(), ^{
                doneBlock(diskImage, SDImageCacheTypeDisk);
            });
        }
    });

    return operation;
}
</code></pre>

<h3>移除图片</h3>

<p>图片的移除操作则可以使用以下方法：</p>

<pre><code>- (void)removeImageForKey:(NSString *)key;
- (void)removeImageForKey:(NSString *)key withCompletion:(SDWebImageNoParamsBlock)completion;
- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk;
- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion;
</code></pre>

<p>我们可以选择同时移除内存及磁盘上的图片。</p>

<h3>清理图片</h3>

<p>磁盘缓存图片的清理操作可以分为完全清空和部分清理。完全清空操作是直接把缓存的文件夹移除，清空操作有以下两个方法：</p>

<pre><code>- (void)clearDisk;
- (void)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion;
</code></pre>

<p>而部分清理则是根据我们设定的一些参数值来移除一些文件，这里主要有两个指标：文件的缓存有效期及最大缓存空间大小。文件的缓存有效期可以通过maxCacheAge属性来设置，默认是1周的时间。如果文件的缓存时间超过这个时间值，则将其移除。而最大缓存空间大小是通过maxCacheSize属性来设置的，如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。清理的操作在-cleanDiskWithCompletionBlock:方法中，其实现如下：</p>

<pre><code>- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock {
    dispatch_async(self.ioQueue, ^{
        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];
        NSArray *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];

        // 1. 该枚举器预先获取缓存文件的有用的属性
        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL
                                                   includingPropertiesForKeys:resourceKeys
                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles
                                                                 errorHandler:NULL];

        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];
        NSMutableDictionary *cacheFiles = [NSMutableDictionary dictionary];
        NSUInteger currentCacheSize = 0;

        // 2. 枚举缓存文件夹中所有文件，该迭代有两个目的：移除比过期日期更老的文件；存储文件属性以备后面执行基于缓存大小的清理操作
        NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init];
        for (NSURL *fileURL in fileEnumerator) {
            NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:NULL];

            // 3. 跳过文件夹
            if ([resourceValues[NSURLIsDirectoryKey] boolValue]) {
                continue;
            }

            // 4. 移除早于有效期的老文件
            NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];
            if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) {
                [urlsToDelete addObject:fileURL];
                continue;
            }

            // 5. 存储文件的引用并计算所有文件的总大小，以备后用
            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];
            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];
            [cacheFiles setObject:resourceValues forKey:fileURL];
        }

        for (NSURL *fileURL in urlsToDelete) {
            [_fileManager removeItemAtURL:fileURL error:nil];
        }

        // 6.如果磁盘缓存的大小大于我们配置的最大大小，则执行基于文件大小的清理，我们首先删除最老的文件
        if (self.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.maxCacheSize) {
            // 7. 以设置的最大缓存大小的一半作为清理目标
            const NSUInteger desiredCacheSize = self.maxCacheSize / 2;

            // 8. 按照最后修改时间来排序剩下的缓存文件
            NSArray *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent
                                                            usingComparator:^NSComparisonResult(id obj1, id obj2) {
                                                                return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];
                                                            }];

            // 9. 删除文件，直到缓存总大小降到我们期望的大小
            for (NSURL *fileURL in sortedFiles) {
                if ([_fileManager removeItemAtURL:fileURL error:nil]) {
                    NSDictionary *resourceValues = cacheFiles[fileURL];
                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];
                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];

                    if (currentCacheSize &lt; desiredCacheSize) {
                        break;
                    }
                }
            }
        }
                                if (completionBlock) {
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock();
            });
        }
    });
}
</code></pre>

<h3>小结</h3>

<p>以上分析了图片缓存操作，当然，除了上面讲的几个操作，SDImageCache类还提供了一些辅助方法。如获取缓存大小、缓存中图片的数量、判断缓存中是否存在某个key指定的图片。另外，SDImageCache类提供了一个单例方法的实现，所以我们可以将其当作单例对象来处理。</p>

<h2>SDWebImageManager</h2>

<p>在实际的运用中，我们并不直接使用SDWebImageDownloader类及SDImageCache类来执行图片的下载及缓存。为了方便用户的使用，SDWebImage提供了SDWebImageManager对象来管理图片的下载与缓存。而且我们经常用到的诸如UIImageView+WebCache等控件的分类都是基于SDWebImageManager对象的。该对象将一个下载器和一个图片缓存绑定在一起，并对外提供两个只读属性来获取它们，如下代码所示：</p>

<pre><code>@interface SDWebImageManager : NSObject

@property (weak, nonatomic) id &lt;SDWebImageManagerDelegate&gt; delegate;

@property (strong, nonatomic, readonly) SDImageCache *imageCache;
@property (strong, nonatomic, readonly) SDWebImageDownloader *imageDownloader;

...

@end
</code></pre>

<p>从上面的代码中我们还可以看到有一个delegate属性，其是一个id&lt;SDWebImageManagerDelegate>对象。SDWebImageManagerDelegate声明了两个可选实现的方法，如下所示：</p>

<pre><code>// 控制当图片在缓存中没有找到时，应该下载哪个图片
- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;

// 允许在图片已经被下载完成且被缓存到磁盘或内存前立即转换
- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;
</code></pre>

<p>这两个代理方法会在SDWebImageManager的-downloadImageWithURL:options:progress:completed:方法中调用，而这个方法是SDWebImageManager类的核心所在。我们来看看它的具体实现：</p>

<pre><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url
                                         options:(SDWebImageOptions)options
                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock {

    ...

    // 前面省略n行。主要作了如下处理：
    // 1. 判断url的合法性
    // 2. 创建SDWebImageCombinedOperation对象
    // 3. 查看url是否是之前下载失败过的
    // 4. 如果url为nil，或者在不可重试的情况下是一个下载失败过的url，则直接返回操作对象并调用完成回调

    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) {
        ...

        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) {

            // 下载
            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) {
                if (weakOperation.isCancelled) {
                    // 操作被取消，则不做任务事情
                }
                else if (error) {
                    // 如果出错，则调用完成回调，并将url放入下载挫败url数组中
                    ...
                }
                else {
                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);

                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) {
                        // Image refresh hit the NSURLCache cache, do not call the completion block
                    }
                    else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) {
                        // 在全局队列中并行处理图片的缓存
                        // 首先对图片做个转换操作，该操作是代理对象实现的
                        // 然后对图片做缓存处理
                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];

                            if (transformedImage &amp;&amp; finished) {
                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];
                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:data forKey:key toDisk:cacheOnDisk];
                            }

                            ...
                        });
                    }
                    else {
                        if (downloadedImage &amp;&amp; finished) {
                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];
                        }

                        ...
                    }
                }

                // 下载完成并缓存后，将操作从队列中移除
                if (finished) {
                    @synchronized (self.runningOperations) {
                        [self.runningOperations removeObject:operation];
                    }
                }
            }];

            // 设置取消回调
            operation.cancelBlock = ^{
                [subOperation cancel];

                @synchronized (self.runningOperations) {
                    [self.runningOperations removeObject:weakOperation];
                }
            };
        }
        else if (image) {
            ...
        }
        else {
            ...
        }
    }];

    return operation;
}
</code></pre>

<p>对于这个方法，我们没有做过多的解释。其主要就是下载图片并根据操作选项来缓存图片。上面这个下载方法中的操作选项参数是由枚举SDWebImageOptions来定义的，这个操作中的一些选项是与SDWebImageDownloaderOptions中的选项对应的。我们来看看这个SDWebImageOptions选项都有哪些：</p>

<pre><code>typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) {

    // 默认情况下，当URL下载失败时，URL会被列入黑名单，导致库不会再去重试，该标记用于禁用黑名单
    SDWebImageRetryFailed = 1 &lt;&lt; 0,

    // 默认情况下，图片下载开始于UI交互，该标记禁用这一特性，这样下载延迟到UIScrollView减速时
    SDWebImageLowPriority = 1 &lt;&lt; 1,

    // 该标记禁用磁盘缓存
    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,

    // 该标记启用渐进式下载，图片在下载过程中是渐渐显示的，如同浏览器一下。
    // 默认情况下，图像在下载完成后一次性显示
    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,

    // 即使图片缓存了，也期望HTTP响应cache control，并在需要的情况下从远程刷新图片。
    // 磁盘缓存将被NSURLCache处理而不是SDWebImage，因为SDWebImage会导致轻微的性能下载。
    // 该标记帮助处理在相同请求URL后面改变的图片。如果缓存图片被刷新，则完成block会使用缓存图片调用一次
    // 然后再用最终图片调用一次
    SDWebImageRefreshCached = 1 &lt;&lt; 4,

    // 在iOS 4+系统中，当程序进入后台后继续下载图片。这将要求系统给予额外的时间让请求完成
    // 如果后台任务超时，则操作被取消
    SDWebImageContinueInBackground = 1 &lt;&lt; 5,

    // 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES;来处理存储在NSHTTPCookieStore中的cookie
    SDWebImageHandleCookies = 1 &lt;&lt; 6,

    // 允许不受信任的SSL认证
    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,

    // 默认情况下，图片下载按入队的顺序来执行。该标记将其移到队列的前面，
    // 以便图片能立即下载而不是等到当前队列被加载
    SDWebImageHighPriority = 1 &lt;&lt; 8,

    // 默认情况下，占位图片在加载图片的同时被加载。该标记延迟占位图片的加载直到图片已以被加载完成
    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,

    // 通常我们不调用动画图片的transformDownloadedImage代理方法，因为大多数转换代码可以管理它。
    // 使用这个票房则不任何情况下都进行转换。
    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,
};
</code></pre>

<p>大家在看-downloadImageWithURL:options:progress:completed:，可以看到两个SDWebImageOptions与SDWebImageDownloaderOptions中的选项是如何对应起来的，在此不多做解释。</p>

<h2>视图扩展</h2>

<p>我在使用SDWebImage的时候，使用得最多的是UIImageView+WebCache中的针对UIImageView的扩展方法，这些扩展方法将UIImageView与WebCache集成在一起，来让UIImageView对象拥有异步下载和缓存远程图片的能力。其中最核心的方法是-sd_setImageWithURL:placeholderImage:options:progress:completed:，其使用SDWebImageManager单例对象下载并缓存图片，完成后将图片赋值给UIImageView对象的image属性，以使图片显示出来，其具体实现如下：</p>

<pre><code>- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock {
    ...

    if (url) {
        __weak UIImageView *wself = self;

        // 使用SDWebImageManager单例对象来下载图片
        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
            if (!wself) return;
            dispatch_main_sync_safe(^{
                if (!wself) return;

                // 图片下载完后显示图片
                if (image) {
                    wself.image = image;
                    [wself setNeedsLayout];
                } else {
                    if ((options &amp; SDWebImageDelayPlaceholder)) {
                        wself.image = placeholder;
                        [wself setNeedsLayout];
                    }
                }
                if (completedBlock &amp;&amp; finished) {
                    completedBlock(image, error, cacheType, url);
                }
            });
        }];
        [self sd_setImageLoadOperation:operation forKey:@"UIImageViewImageLoad"];
    } else {
        ...
    }
}
</code></pre>

<p>除了扩展UIImageView之外，SDWebImage还扩展了UIView、UIButton、MKAnnotationView等视图类，大家可以参考源码。</p>

<p>当然，如果不想使用这些扩展，则可以直接使用SDWebImageManager来下载图片，这也是很OK的。</p>

<h2>技术点</h2>

<p>SDWebImage的主要任务就是图片的下载和缓存。为了支持这些操作，它主要使用了以下知识点：</p>

<ol>
<li><p>dispatch_barrier_sync函数：该方法用于对操作设置屏幕，确保在执行完任务后才会执行后续操作。该方法常用于确保类的线程安全性操作。</p></li>
<li><p>NSMutableURLRequest：用于创建一个网络请求对象，我们可以根据需要来配置请求报头等信息。</p></li>
<li><p>NSOperation及NSOperationQueue：操作队列是Objective-C中一种高级的并发处理方法，现在它是基于GCD来实现的。相对于GCD来说，操作队列的优点是可以取消在任务处理队列中的任务，另外在管理操作间的依赖关系方面也容易一些。对SDWebImage中我们就看到了如何使用依赖将下载顺序设置成后进先出的顺序。</p></li>
<li><p>NSURLConnection：用于网络请求及响应处理。在iOS7.0后，苹果推出了一套新的网络请求接口，即NSURLSession类。</p></li>
<li><p>开启一个后台任务。</p></li>
<li><p>NSCache类：一个类似于集合的容器。它存储key-value对，这一点类似于NSDictionary类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。</p></li>
<li><p>清理缓存图片的策略：特别是最大缓存空间大小的设置。如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。</p></li>
<li><p>对图片的解压缩操作：这一操作可以查看SDWebImageDecoder.m中+decodedImageWithImage方法的实现。</p></li>
<li><p>对GIF图片的处理</p></li>
<li><p>对WebP图片的处理</p></li>
</ol>


<p>感兴趣的同学可以深入研究一下这些知识点。当然，这只是其中一部分，更多的知识还有待大家去发掘。</p>

<h2>参考</h2>

<ol>
<li><a href="https://github.com/rs/SDWebImage">SDWebImage工程</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/">Grand Central Dispatch (GCD) Reference</a></li>
<li><a href="http://objccn.io/issue-2-2/">常见的后台实践</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/">NSOperation Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/">NSCache Class Reference</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSObject之二]]></title>
    <link href="http://southpeak.github.io/blog/2015/01/31/nsobjectzhi-er/"/>
    <updated>2015-01-31T22:41:09+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/01/31/nsobjectzhi-er</id>
    <content type="html"><![CDATA[<p>前面一章我们整理了NSObject类，这一章我们来看看NSObject协议的内容。</p>

<p>NSObject协议提供了一组方法作为Objective-C对象的基础。其实我们对照一个NSObject类和NSObject协议，可以看到很多方法的方法名都是一样的，只不过NSObject类提供的是类方法，是基于类级别的操作；而NSObject协议提供的是实例方法，是基于实例对象级别的操作。</p>

<p>如果一个对象如果采用了这个协议，则可以被看作是一级对象。我们可以从这个对象获取以下信息：</p>

<ol>
<li>类信息，以及类所在的继承体系。</li>
<li>协议信息</li>
<li>响应特定消息的能力</li>
</ol>


<p>实际上，Cocoa的根类NSObject就采用了这个类，所以所有继承自NSObject类的对象都具备NSObject协议中描述的功能。接下来，我们参照NSObject类，整理一下这些功能。</p>

<h2>识别对象</h2>

<p>类似于NSObject类，NSObject协议提供了一些方法来识别类。</p>

<p>如果想获取对象的类对象，则可以使用如下方法：</p>

<pre><code>- (Class)class
</code></pre>

<p>如果想获取对象父类的类对象，则可以使用以下只读属性：</p>

<pre><code>@property(readonly) Class superclass
</code></pre>

<p>如果想查看某个对象是否是给定类的实例或者是给定类子类的实例，则可以使用以下方法：</p>

<pre><code>- (BOOL)isKindOfClass:(Class)aClass
</code></pre>

<p>这个方法应该是大家常用的方法。需要注意的是在类簇中使用这个方法。在类簇中，我们获取到的对象类型可能并不是我们期望的类型。如果我们调用一个返回类簇的方法，则这个方法返回的实际类型会是最能标识这个类能做些什么的类型。例如，如果一个方法返回一个指向NSArray对象的指针，则不能使用isKindOfClass:方法查看经是否是一个可变数组，如以下代码：</p>

<pre><code>if ([myArray isKindOfClass:[NSMutableArray class]])
{
    // Modify the object
}
</code></pre>

<p>如果我们使用这样的代码，我们可能会认为修改一个实际上不应该被修改的对象是没问题的。这样做可能会对那些期望对象保持不要变的代码产生影响。</p>

<p>另外，查看对象是否是指定类的一个实例还可以使用以下方法：</p>

<pre><code>- (BOOL)isMemberOfClass:(Class)aClass
</code></pre>

<p>注意，这个方法无法确定对象是否是指定类子类的实例。另外，类对象可能是编译器创建的对象，但它仍然支持这一概念。</p>

<h2>测试对象</h2>

<p>对于对象的测试，NSObject协议也定义了两个方法，其中respondsToSelector:方法用于测试对象是否能响应指定的消息，这个方法可以是类自定义的实例方法，也可以是继承而来的实例方法。其声明如下：</p>

<pre><code>- (BOOL)respondsToSelector:(SEL)aSelector
</code></pre>

<p>不过我们不能使用super关键字来调用respondsToSelector:，以查看对象是否是从其父类继承了某个方法。因为我们可以从super的定义可知，消息的最终实际接收者还是self本身，因此测试的还是对象的整个体系(包括对象所在类本身)，而不仅仅是父类。不过，我们可以使用父类来调用NSObject类的类方法instancesRespondToSelector:来达到这个目的，如下所示：</p>

<pre><code>if( [MySuperclass instancesRespondToSelector:@selector(aMethod)] ) {
    // invoke the inherited method
    [super aMethod];
}
</code></pre>

<p>我们不能简单地使用[[self superclass] instancesRespondToSelector:@selector(aMethod)]，因为如果由一个子类来调用，则可能导致方法的失败。</p>

<p>还需要注意的是，如果对象能够转发消息，则也可以响应这个消息，不过这个方法会返回NO。</p>

<p>如果想查看对象是否实现了某个类，则可以使用如下方法：</p>

<pre><code>- (BOOL)conformsToProtocol:(Protocol *)aProtocol
</code></pre>

<p>这个方法与NSObject类的类方法conformsToProtocol:是一样的。它只是提供了一个便捷方法，我们不需要先去取对象的类，再调用类方法conformsToProtocol:。</p>

<h2>标识和比较对象</h2>

<p>如果我们想获取对象本身，则可以使用以下方法：</p>

<pre><code>- (instancetype)self
</code></pre>

<p>比较两个对象是否相同，则可以使用以下方法：</p>

<pre><code>- (BOOL)isEqual:(id)anObject
</code></pre>

<p>这个方法定义了对象相同的意义。例如，一个容器对象可能会按照特定规则来定义两个对象是否相等，如其所有元素的isEqual:请求都返回YES。我们在自定义子类时，可以重写这个方法，以使用我们自己的规则来评判两个对象相等。</p>

<p>如果两个对象相等，则它们必须拥有相同的hash值。在子类中定义isEqual:方法并打算把子类的实例放入集合中时，这一点非常重要。因此在子类中必须同时定义hash。</p>

<p>hash值是一个整数值，它可以用于在hash表结构中作为一个表地址。其声明如下：</p>

<pre><code>@property(readonly) NSUInteger hash
</code></pre>

<p>如果一个可变对象被添加到一个以hash值来确定对象位置的集合中，则当对象还在集合中时，其由hash方法返回的值不能改变。因此，hash方法不能依赖于对象内部的任何状态信息，或许我们必须确保对象在集合中时，不能改变其内部状态信息。比如，一个可变字典可以放到一个hash表中，但当它还在表中时，不能改变它。</p>

<h2>发送消息</h2>

<p>在NSObject类中，定义了一系列的发送消息的方法，用于在目标线程中执行方法。NSObject协议也定义了如下几个方法，来执行发送消息的任务：</p>

<pre><code>- (id)performSelector:(SEL)aSelector

- (id)performSelector:(SEL)aSelector withObject:(id)anObject

- (id)performSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject
</code></pre>

<p>这三个方法基本相同，只不过后面两个方法能为selector指定的方法携带参数。因此我们以performSelector:为例。</p>

<p>performSelector:方法的使用与直接将消息发送给对象的效果是一样的，如下面几个操作，做的事情是一样的：</p>

<pre><code>id myClone = [anObject copy];
id myClone = [anObject performSelector:@selector(copy)];
id myClone = [anObject performSelector:sel_getUid("copy")];
</code></pre>

<p>区别在于，performSelector:允许在运行时再去确定对象是否能处理消息。而[anObject copy]中，如果anObject不能处理copy，编译器就直接会报错。</p>

<p>如果方法的参数过多，以至于上面几个方法都无法处理，则可以考虑使用NSInvocation对象。</p>

<h2>描述对象</h2>

<p>描述对象的方法与NSObject类中描述类的方法其方法名相同，都是description，其声明如下：</p>

<pre><code>@property(readonly, copy) NSString *description
</code></pre>

<p>这个方法用于创建一个对象的文本表达方式，例如：</p>

<pre><code>ClassName *anObject = &lt;#An object#&gt;;
NSString *string = [NSString stringWithFormat:@"anObject is %@", anObject];
</code></pre>

<p>为了便于调试，NSObject协议还定义debugDescription方法，该方法声明如下：</p>

<pre><code>@property(readonly, copy) NSString *debugDescription
</code></pre>

<p>该方法返回一个在调试器中显示的用于描述对象内容的字符串。在调试器中打印一个对象时，会调用这个方法。NSObject类实现这个方法时只是调用了description方法，所以默认情况下，这两个方法的输出都是一样的。我们在子类中可以重写这个方法的实现。</p>

<h2>总结</h2>

<p>NSObject协议的定义的很多方法都是我们平常经常使用的。我们在创建NSObject类的子类时，默认都继承了NSObject类对于NSObject协议的实现。如果有特殊的需求，我们可以重写这些方法。</p>

<p>当然，NSObject协议还定义了一些方法，如我们非常熟悉的retain, release, autorelease, retainCount方法，不过这些方法在ARC时代已经过时了，我们在此不过多说明。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html">NSObject Protocol Reference</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSObject之一]]></title>
    <link href="http://southpeak.github.io/blog/2015/01/31/nsobjectzhi-%5B%3F%5D/"/>
    <updated>2015-01-31T22:37:32+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/01/31/nsobjectzhi-[?]</id>
    <content type="html"><![CDATA[<p><em>Objective-C中有两个NSObject，一个是NSObject类，另一个是NSObject协议。而其中NSObject类采用了NSObject协议。在本文中，我们主要整理一下NSObject类的使用。</em></p>

<p>说到NSObject类，写Objective-C的人都应该知道它。它是大部分Objective-C类继承体系的根类。这个类提供了一些通用的方法，对象通过继承NSObject，可以从其中继承访问运行时的接口，并让对象具备Objective-C对象的基本能力。以下我们就来看看NSObejct提供给我们的一些基础功能。</p>

<h2>+load与+initialize</h2>

<p>这两个方法可能平时用得比较少，但很有用。在我们的程序编译后，类相关的数据结构会保留在目标文件中，在程序运行后会被解析和使用，此时类的信息会经历加载和初始化两个过程。在这两个过程中，会分别调用类的load方法和initialize方法，在这两个方法中，我们可以适当地做一些定制处理。不当是类本身，类的分类也会经历这两个过程。对于一个类，我们可以在类的定义中重写这两个方法，也可以在分类中重写它们，或者同时重写。</p>

<h3>load方法</h3>

<p>对于load方法，当Objective-C运行时加载类或分类时，会调用这个方法；通常如果我们有一些类级别的操作需要在加载类时处理，就可以放在这里面，如为一个类执行Swizzling Method操作。</p>

<p>load消息会被发送到动态加载和静态链接的类和分类里面。不过，只有当我们在类或分类里面实现这个方法时，类/分类才会去调用这个方法。</p>

<p>在类继承体系中，load方法的调用顺序如下：</p>

<ol>
<li>一个类的load方法会在其所有父类的load方法之后调用</li>
<li>分类的load方法会在对应类的load方法之后调用</li>
</ol>


<p>在load的实现中，如果使用同一库中的另外一个类，则可能是不安全的，因为可能存在的情况是另外一个类的load方法还没有运行，即另一个类可能尚未被加载。另外，在load方法里面，我们不需要显示地去调用[super load]，因为父类的load方法会自动被调用，且在子类之前。</p>

<p>在有依赖关系的两个库中，被依赖的库中的类其load方法会优先调用。但在库内部，各个类的load方法的调用顺序是不确定的。</p>

<h3>initialize方法</h3>

<p>当我们在程序中向类或其任何子类发送第一条消息前，runtime会向该类发送initialize消息。runtime会以线程安全的方式来向类发起initialize消息。父类会在子类之前收到这条消息。父类的initialize实现可能在下面两种情况下被调用：</p>

<ol>
<li>子类没有实现initialize方法，runtime将会调用继承而来的实现</li>
<li>子类的实现中显示的调用了[super initialize]</li>
</ol>


<p>如果我们不想让某个类中的initialize被调用多次，则可以像如下处理：</p>

<pre><code>+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
}
</code></pre>

<p>因为initialize是以线程安全的方式调用的，且在不同的类中initialize被调用的顺序是不确定的，所以在initialize方法中，我们应该做少量的必须的工作。特别需要注意是，如果我们initialize方法中的代码使用了锁，则可能会导致死锁。因此，我们不应该在initialize方法中实现复杂的初始化工作，而应该在类的初始化方法(如-init)中来初始化。</p>

<p>另外，每个类的initialize只会被调用一次。所以，如果我们想要为类和类的分类实现单独的初始化操作，则应该实现load方法。</p>

<p>如果想详细地了解这两个方法的使用，可以查看《Effective Objective-C 2.0》的第51条，里面有非常详细的说明。如果想更深入地了解这两个方法的调用，则可以参考objc库的源码，另外，<a href="http://www.cocoachina.com/ios/20150104/10826.html">NSObject的load和initialize方法</a>一文从源码层面为我们简单介绍了这两个方法。</p>

<h2>对象的生命周期</h2>

<p>一说到对象的创建，我们会立即想到[[NSObject alloc] init]这种经典的两段式构造。对于这种两段式构造，唐巧大神在他的&#8221;<a href="http://blog.devtang.com/blog/2013/01/13/two-stage-creation-on-cocoa/">谈ObjC对象的两段构造模式</a>&ldquo;一文中作了详细描述，大家可以参考一下。</p>

<p>本小节我们主要介绍一下与对象生命周期相关的一些方法。</p>

<h3>对象分配</h3>

<p>NSObject提供的对象分配的方法有alloc和allocWithZone:，它们都是类方法。这两个方法负责创建对象并为其分配内存空间，返回一个新的对象实例。新的对象的isa实例变量使用一个数据结构来初始化，这个数据结构描述了对象的信息；创建完成后，对象的其它实例变量被初始化为0。</p>

<p>alloc方法的定义如下：</p>

<pre><code>+ (instancetype)alloc
</code></pre>

<p>而allocWithZone:方法的存在是由历史原因造成的，它的调用基本上和alloc是一样的。既然是历史原因，我们就不说了，官方文档只给了一句话：</p>

<pre><code>This method exists for historical reasons; memory zones are no longer used by Objective-C.
</code></pre>

<p>我们只需要知道alloc方法的实现调用了allocWithZone:方法。</p>

<h3>对象初始化</h3>

<p>我们一般不去自己重写alloc或allocWithZone:方法，不用去关心对象是如何创建、如何为其分配内存空间的；我们更关心的是如何去初始化这个对象。上面提到了，对象创建后，isa以外的实例变量都默认初始化为0。通常，我们希望将这些实例变量初始化为我们期望的值，这就是init方法的工作了。</p>

<p>NSObject类默认提供了一个init方法，其定义如下：</p>

<pre><code>- (instancetype)init
</code></pre>

<p>正常情况下，它会初始化对象，如果由于某些原因无法完成对象的创建，则会返回nil。注意，对象在使用之前必须被初始化，否则无法使用。不过，NSObject中定义的init方法不做任何初始化操作，只是简单地返回self。</p>

<p>当然，我们定义自己的类时，可以提供自定义的初始化方法，以满足我们自己的初始化需求。需要注意的就是子类的初始化方法需要去调用父类的相应的初始化方法，以保证初始化的正确性。</p>

<p>讲完两段式构造的两个部分，有必要来讲讲NSObject类的new方法了。</p>

<p>new方法实际上是集alloc和init于一身，它创建了对象并初始化了对象。它的实现如下：</p>

<pre><code>+ (instancetype)new {
    return [[self alloc] init];
}
</code></pre>

<p>new方法更多的是一个历史遗留产物，它源于NeXT时代。如果我们的初始化操作只是调用[[self alloc] init]时，就可以直接用new来代替。不过如果我们需要使用自定义的初始化方法时，通常就使用两段式构造方式。</p>

<h3>拷贝</h3>

<p>说到拷贝，相信大家都很熟悉。拷贝可以分为“深拷贝”和“浅拷贝”。深拷贝拷贝的是对象的值，两个对象相互不影响，而浅拷贝拷贝的是对象的引用，修改一个对象时会影响到另一个对象。</p>

<p>在Objective-C中，如果一个类想要支持拷贝操作，则需要实现NSCopying协议，并实现copyWithZone:【注意：NSObject类本身并没有实现这个协议】。如果一个类不是直接继承自NSObject，则在实现copyWithZone:方法时需要调用父类的实现。</p>

<p>虽然NSObject自身没有实现拷贝协议，不过它提供了两个拷贝方法，如下：</p>

<pre><code>- (id)copy
</code></pre>

<p>这个是拷贝操作的便捷方法。它的返回值是NSCopying协议的copyWithZone:方法的返回值。如果我们的类没有实现这个方法，则会抛出一个异常。</p>

<p>与copy对应的还有一个方法，即：</p>

<pre><code>- (id)mutableCopy
</code></pre>

<p>从字面意义来讲，copy可以理解为不可变拷贝操作，而mutableCopy可以理解为可变操作。这便引出了拷贝的另一个特性，即可变性。</p>

<p>顾名思义，不可变拷贝即拷贝后的对象具有不可变属性，可变拷贝后的对象具有可变属性。这对于数组、字典、字符串、URL这种分可变和不可变的对象来说是很有意义的。我们来看如下示例：</p>

<pre><code>NSMutableArray *mutableArray = [NSMutableArray array];
NSMutableArray *array = [mutableArray copy];
[array addObject:@"test1"];
</code></pre>

<p>实际上，这段代码是会崩溃的，我们来看看崩溃日志：</p>

<pre><code>-[__NSArrayI addObject:]: unrecognized selector sent to instance 0x100107070
*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSArrayI addObject:]: unrecognized selector sent to instance 0x100107070'
</code></pre>

<p>从中可以看出，经过copy操作，我们的array实际上已经变成不可变的了，其底层元类是__NSArrayI。这个类是不支持addObject:方法的。</p>

<p>偶尔在代码中，也会看到类似于下面的情况：</p>

<pre><code>@property (copy) NSMutableArray *array;
</code></pre>

<p>这种属性的声明方式是有问题的，即上面提到的可变性问题。使用self.array = **赋值后，数组其实是不可变的，所以需要特别注意。</p>

<p>mutableCopy的使用也挺有意思的，具体的还请大家自己去试验一下。</p>

<h3>释放</h3>

<p>当一个对象的引用计数为0时，系统就会将这个对象释放。此时run time会自动调用对象的dealloc方法。在ARC环境下，我们不再需要在此方法中去调用[super dealloc]了。我们重写这个方法主要是为了释放对象中用到的一些资源，如我们通过C方法分配的内存空间。dealloc方法的定义如下：</p>

<pre><code>- (void)dealloc
</code></pre>

<p>需要注意的是，我们不应该直接去调用这个方法。这些事都让run time去做吧。</p>

<h2>消息发送</h2>

<p>Objective-C中对方法的调用并不是像C++里面那样直接调用，而是通过消息分发机制来实现的。这个机制核心的方法是objc_msgSend函数。消息机制的具体实现我们在此不做讨论，可以参考<a href="http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/">Objective-C Runtime 运行时之三：方法与消息</a>。</p>

<p>对于消息的发送，除了使用[obj method]这种机制之外，NSObject类还提供了一系列的performSelector**方法。这些方法可以让我们更加灵活地控制方法的调用。接下来我们就来看看这些方法的使用。</p>

<h3>在线程中调用方法</h3>

<p>如果我们想在当前线程中调用一个方法，则可以使用以下两个方法：</p>

<pre><code>- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay

- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes
</code></pre>

<p>这两个方法会在当前线程的Run loop中设置一个定时器，以在delay指定的时间之后执行aSelector。如果我们希望定时器运行在默认模式(NSDefaultRunLoopMode)下，可以使用前一个方法；如果想自己指定Run loop模式，则可以使用后一个方法。</p>

<p>当定时器启动时，线程会从Run loop的队列中获取到消息，并执行相应的selector。如果Run loop运行在指定的模式下，则方法会成功调用；否则，定时器会处于等待状态，直到Run loop运行在指定模式下。</p>

<p>需要注意的是，调用这些方法时，Run loop会保留方法接收者及相关的参数的引用(即对这些对象做retain操作)，这样在执行时才不至于丢失这些对象。当方法调用完成后，Run loop会调用这些对象的release方法，减少对象的引用计数。</p>

<p>如果我们想在主线程上执行某个对象的方法，则可以使用以下两个方法：</p>

<pre><code>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait

- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array
</code></pre>

<p>我们都知道，iOS中所有的UI操作都需要在主线程中处理。如果想在某个二级线程的操作完成之后做UI操作，就可以使用这两个方法。</p>

<p>这两个方法会将消息放到主线程Run loop的队列中，前一个方法使用的是NSRunLoopCommonModes运行时模式；如果想自己指定运行模式，则使用后一个方法。方法的执行与之前的两个performSelector方法是类似的。当在一个线程中多次调用这个方法将不同的消息放入队列时，消息的分发顺序与入队顺序是一致的。</p>

<p>方法中的wait参数指定当前线程在指定的selector在主线程执行完成之后，是否被阻塞住。如果设置为YES，则当前线程被阻塞。如果当前线程是主线程，而该参数也被设置为YES，则消息会被立即发送并处理。</p>

<p>另外，这两个方法分发的消息不能被取消。</p>

<p>如果我们想在指定的线程中分发某个消息，则可以使用以下两个方法：</p>

<pre><code>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait

- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array
</code></pre>

<p>这两个方法基本上与在主线程的方法差不多。在此就不再讨论。</p>

<p>如果想在后台线程中调用接收者的方法，可以使用以下方法：</p>

<pre><code>- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg
</code></pre>

<p>这个方法会在程序中创建一个新的线程。由aSelector表示的方法必须像程序中的其它新线程一样去设置它的线程环境。</p>

<p>当然，我们经常看到的performSelector系列方法中还有几个方法，即：</p>

<pre><code>- (id)performSelector:(SEL)aSelector
- (id)performSelector:(SEL)aSelector withObject:(id)anObject
- (id)performSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject
</code></pre>

<p>不过这几个方法是在NSObject协议中定义的，NSObject类实现了这个协议，也就定义了相应的实现。这个我们将在NSObject协议中来介绍。</p>

<h3>取消方法调用请求</h3>

<p>对于使用performSelector:withObject:afterDelay:方法(仅限于此方法)注册的执行请求，在调用发生前，我们可以使用以下两个方法来取消：</p>

<pre><code>+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget

+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(id)anArgument
</code></pre>

<p>前一个方法会取消所以接收者为aTarget的执行请求，不过仅限于当前run loop，而不是所有的。</p>

<p>后一个方法则会取消由aTarget、aSelector和anArgument三个参数指定的执行请求。同样仅限于当前run loop。</p>

<h2>消息转发及动态解析方法</h2>

<p>当一个对象能接收一个消息时，会走正常的方法调用流程。但如果一个对象无法接收一个消息时，就会走消息转发机制。</p>

<p>消息转发机制基本上分为三个步骤：</p>

<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>


<p>具体流程可参考<a href="http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/">Objective-C Runtime 运行时之三：方法与消息</a>，《Effective Objective-C 2.0》一书的第12小节也有详细描述。在此我们只介绍一下NSObject类为实现消息转发提供的方法。</p>

<p>首先，对于动态方法解析，NSObject提供了以下两个方法来处理：</p>

<pre><code>+ (BOOL)resolveClassMethod:(SEL)name
+ (BOOL)resolveInstanceMethod:(SEL)name
</code></pre>

<p>从方法名我们可以看出，resolveClassMethod:是用于动态解析一个类方法；而resolveInstanceMethod:是用于动态解析一个实例方法。</p>

<p>我们知道，一个Objective-C方法是其实是一个C函数，它至少带有两个参数，即self和_cmd。我们使用class_addMethod函数，可以给类添加一个方法。我们以resolveInstanceMethod:为例，如果要给对象动态添加一个实例方法，则可以如下处理：</p>

<pre><code>void dynamicMethodIMP(id self, SEL _cmd)
{
    // implementation ....
}

+ (BOOL) resolveInstanceMethod:(SEL)aSEL
{
    if (aSEL == @selector(resolveThisMethodDynamically))
    {
          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
          return YES;
    }
    return [super resolveInstanceMethod:aSel];
}
</code></pre>

<p>其次，对于备用接收者，NSObject提供了以下方法来处理：</p>

<pre><code>- (id)forwardingTargetForSelector:(SEL)aSelector
</code></pre>

<p>该方法返回未被接收消息最先被转发到的对象。如果一个对象实现了这个方法，并返回一个非空的对象(且非对象本身)，则这个被返回的对象成为消息的新接收者。另外如果在非根类里面实现这个方法，如果对于给定的selector，我们没有可用的对象可以返回，则应该调用父类的方法实现，并返回其结果。</p>

<p>最后，对于完整转发，NSObject提供了以下方法来处理</p>

<pre><code>- (void)forwardInvocation:(NSInvocation *)anInvocation
</code></pre>

<p>当前面两步都无法处理消息时，运行时系统便会给接收者最后一个机会，将其转发给其它代理对象来处理。这主要是通过创建一个表示消息的NSInvocation对象并将这个对象当作参数传递给forwardInvocation:方法。我们在forwardInvocation:方法中可以选择将消息转发给其它对象。</p>

<p>在这个方法中，主要是需要做两件事：</p>

<ol>
<li>找到一个能处理anInvocation调用的对象。</li>
<li>将消息以anInvocation的形式发送给对象。anInvocation将维护调用的结果，而运行时则会将这个结果返回给消息的原始发送者。</li>
</ol>


<p>这一过程如下所示：</p>

<pre><code>- (void)forwardInvocation:(NSInvocation *)invocation
{
    SEL aSelector = [invocation selector];

    if ([friend respondsToSelector:aSelector])
        [invocation invokeWithTarget:friend];
    else
        [super forwardInvocation:invocation];
}
</code></pre>

<p>当然，对于一个非根类，如果还是无法处理消息，则应该调用父类的实现。而NSObject类对于这个方法的实现，只是简单地调用了doesNotRecognizeSelector:。它不再转发任何消息，而是抛出一个异常。doesNotRecognizeSelector:的声明如下：</p>

<pre><code>- (void)doesNotRecognizeSelector:(SEL)aSelector
</code></pre>

<p>运行时系统在对象无法处理或转发一个消息时会调用这个方法。这个方法引发一个NSInvalidArgumentException异常并生成一个错误消息。</p>

<p>任何doesNotRecognizeSelector:消息通常都是由运行时系统来发送的。不过，它们可以用于阻止一个方法被继承。例如，一个NSObject的子类可以按以下方式来重写copy或init方法以阻止继承：</p>

<pre><code>- (id)copy
{
    [self doesNotRecognizeSelector:_cmd];
}
</code></pre>

<p>这段代码阻止子类的实例响应copy消息或阻止父类转发copy消息&mdash;虽然respondsToSelector:仍然报告接收者可以访问copy方法。</p>

<p>当然，如果我们要重写doesNotRecognizeSelector:方法，必须调用super的实现，或者在实现的最后引发一个NSInvalidArgumentException异常。它代表对象不能响应消息，所以总是应该引发一个异常。</p>

<h2>获取方法信息</h2>

<p>在消息转发的最后一步中，forwardInvocation:参数是一个NSInvocation对象，这个对象需要获取方法签名的信息，而这个签名信息就是从methodSignatureForSelector:方法中获取的。</p>

<p>该方法的声明如下:</p>

<pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
</code></pre>

<p>这个方法返回包含方法描述信息的NSMethodSignature对象，如果找不到方法，则返回nil。如果我们的对象包含一个代理或者对象能够处理它没有直接实现的消息，则我们需要重写这个方法来返回一个合适的方法签名。</p>

<p>对应于实例方法，当然还有一个处理类方法的相应方法，其声明如下：</p>

<pre><code>+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector
</code></pre>

<p>另外，NSObject类提供了两个方法来获取一个selector对应的方法实现的地址，如下所示：</p>

<pre><code>- (IMP)methodForSelector:(SEL)aSelector
+ (IMP)instanceMethodForSelector:(SEL)aSelector
</code></pre>

<p>获取到了方法实现的地址，我们就可以直接将IMP以函数形式来调用。</p>

<p>对于methodForSelector:方法，如果接收者是一个对象，则aSelector应该是一个实例方法；如果接收者是一个类，则aSelector应该是一个类方法。</p>

<p>对于instanceMethodForSelector:方法，其只是向类对象索取实例方法的实现。如果接收者的实例无法响应aSelector消息，则产生一个错误。</p>

<h2>测试类</h2>

<p>对于类的测试，在NSObject类中定义了两个方法，其中类方法instancesRespondToSelector:用于测试接收者的实例是否响应指定的消息，其声明如下：</p>

<pre><code>+ (BOOL)instancesRespondToSelector:(SEL)aSelector
</code></pre>

<p>如果aSelector消息被转发到其它对象，则类的实例可以接收这个消息而不会引发错误，即使该方法返回NO。</p>

<p>为了询问类是否能响应特定消息(注意：不是类的实例)，则使用这个方法，而不使用NSObject协议的实例方法respondsToSelector:。</p>

<p>NSObject还提供了一个方法来查看类是否采用了某个协议，其声明如下：</p>

<pre><code>+ (BOOL)conformsToProtocol:(Protocol *)aProtocol
</code></pre>

<p>如果一个类直接或间接地采用了一个协议，则我们可以说这个类实现了该协议。我们可以看看以下这个例子：</p>

<pre><code>@protocol AffiliationRequests &lt;Joining&gt;

@interface MyClass : NSObject &lt;AffiliationRequests, Normalization&gt;

BOOL canJoin = [MyClass conformsToProtocol:@protocol(Joining)];
</code></pre>

<p>通过继承体系，MyClass类实现了Joining协议。</p>

<p>不过，这个方法并不检查类是否实现了协议的方法，这应该是程序员自己的职责了。</p>

<h2>识别类</h2>

<p>NSObject类提供了几个类方法来识别一个类，首先是我们常用的class类方法，该方法声明如下：</p>

<pre><code>+ (Class)class
</code></pre>

<p>该方法返回类对象。当类是消息的接收者时，我们只通过类的名称来引用一个类。在其它情况下，类的对象必须通过这个方法类似的方法(-class实例方法)来获取。如下所示：</p>

<pre><code>BOOL test = [self isKindOfClass:[SomeClass class]];
</code></pre>

<p>NSObject还提供了superclass类方法来获取接收者的父类，其声明如下：</p>

<pre><code>+ (Class)superclass
</code></pre>

<p>另外，我们还可以使用isSubclassOfClass:类方法查看一个类是否是另一个类的子类，其声明如下：</p>

<pre><code>+ (BOOL)isSubclassOfClass:(Class)aClass
</code></pre>

<h2>描述类</h2>

<p>描述类是使用description方法，它返回一个表示类的内容的字符串。其声明如下：</p>

<pre><code>+ (NSString *)description
</code></pre>

<p>我们在LLDB调试器中打印类的信息时，使用的就是这个方法。</p>

<p>当然，如果想打印类的实例的描述时，使用的是NSObject协议中的实例方法description，我们在此不多描述。</p>

<h2>归档操作</h2>

<p>一说到归档操作，你会首先想到什么呢？我想到的是NSCoding协议以及它的两个方法：
initWithCoder:和encodeWithCoder:。如果我们的对象需要支持归档操作，则应该采用这个协议并提供两个方法的具体实现。</p>

<p>在编码与解码的过程中，一个编码器会调用一些方法，这些方法允许将对象编码以替代一个更换类或实例本身。这样，就可以使得归档在不同类层次结构或类的不同版本的实现中被共享。例如，类簇能有效地利用这一特性。这一特性也允许每个类在解码时应该只维护单一的实例来执行这一策略。</p>

<p>NSObject类虽然没有采用NSCoding协议，但却提供了一些替代方法，以支持上述策略。这些方法分为两类，即通用和专用的。</p>

<p>通用方法由NSCoder对象调用，主要有如下几个方法和属性：</p>

<pre><code>@property(readonly) Class classForCoder

- (id)replacementObjectForCoder:(NSCoder *)aCoder

- (id)awakeAfterUsingCoder:(NSCoder *)aDecoder
</code></pre>

<p>专用的方法主要是针对NSKeyedArchiver对象的，主要有如下几个方法和属性：</p>

<pre><code>@property(readonly) Class classForKeyedArchiver

+ (NSArray *)classFallbacksForKeyedArchiver

+ (Class)classForKeyedUnarchiver

- (id)replacementObjectForKeyedArchiver:(NSKeyedArchiver *)archiver
</code></pre>

<p>子类在归档的过程中如果有特殊的需求，可以重写这些方法。这些方法的具体描述，可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class">官方文档</a>。</p>

<p>在解码或解档过程中，有一点需要考虑的就是对象所属类的版本号，这样能确保老版本的对象能被正确地解析。NSObject类对此提供了两个方法，如下所示：</p>

<pre><code>+ (void)setVersion:(NSInteger)aVersion

+ (NSInteger)version
</code></pre>

<p>它们都是类方法。默认情况下，如果没有设置版本号，则默认是0.</p>

<h2>总结</h2>

<p>NSObject类是Objective-C中大部分类层次结构中的根类，并为我们提供了很多功能。了解这些功能更让我们更好地发挥Objective-C的特性。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class">NSObject Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Archiving/Articles/codingobjects.html">Archives and Serializations Programming Guide</a></li>
<li><a href="http://www.cocoachina.com/ios/20150104/10826.html">NSObject的load和initialize方法</a></li>
<li><a href="http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/">Objective-C Runtime 运行时之三：方法与消息</a></li>
<li>《Effective Objective-C 2.0》</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工具篇：LLDB调试器]]></title>
    <link href="http://southpeak.github.io/blog/2015/01/25/gong-ju-pian-:lldbdiao-shi-qi/"/>
    <updated>2015-01-25T21:33:25+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/01/25/gong-ju-pian-:lldbdiao-shi-qi</id>
    <content type="html"><![CDATA[<p>随着Xcode 5的发布，LLDB调试器已经取代了GDB，成为了Xcode工程中默认的调试器。它与LLVM编译器一起，带给我们更丰富的流程控制和数据检测的调试功能。LLDB为Xcode提供了底层调试环境，其中包括内嵌在Xcode IDE中的位于调试区域的控制面板，在这里我们可以直接调用LLDB命令。如图1所示：</p>

<p>图1：位于Xcode调试区域的控制台</p>

<p><img src="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/art/lldb_in_xc5_command_window_2x.png" alt="image" /></p>

<p>在本文中，我们主要整理一下LLDB调试器提供给我们的调试命令，更详细的内容可以查看<a href="http://lldb.llvm.org/tutorial.html">The LLDB Debugger</a>。</p>

<h2>LLDB命令结构</h2>

<p>在使用LLDB前，我们需要了解一下LLDB的命令结构及语法，这样可以尽可能地挖掘LLDB的潜能，以帮助我们更充分地利用它。</p>

<p>LLDB命令的语法有其通用结构，通常是以下形式的：</p>

<pre><code>&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]
</code></pre>

<p>其中：</p>

<ol>
<li>&lt;command>(命令)和&lt;subcommand>(子命令)：LLDB调试命令的名称。命令和子命令按层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。</li>
<li>&lt;action>：我们想在前面的命令序列的上下文中执行的一些操作。</li>
<li>&lt;options>：行为修改器(action modifiers)。通常带有一些值。</li>
<li>&lt;argument>：根据使用的命令的上下文来表示各种不同的东西。</li>
</ol>


<p>LLBD命令行的解析操作在执行命令之前完成。上面的这些元素之间通过空格来分割，如果某一元素自身含有空格，则可以使用双引用。而如果元素中又包含双引号，则可以使用反斜杠；或者元素使用单引号。如下所示：</p>

<pre><code>(lldb) command [subcommand] -option "some \"quoted\" string"
(lldb) command [subcommand] -option 'some "quoted" string'
</code></pre>

<p>这种命令解析设计规范了LLDB命令语法，并对所有命令做了个统一。</p>

<h3>命令选项</h3>

<p>LLDB中的命令选项有规范形式和缩写形式两种格式。以设置断点的命令breakpoint set为例，以下列表了其部分选项的格式，其中括号中的是规范形式：</p>

<pre><code>breakpoint set
   -M &lt;method&gt; ( --method &lt;method&gt; )
   -S &lt;selector&gt; ( --selector &lt;selector&gt; )
   -b &lt;function-name&gt; ( --basename &lt;function-name&gt; )
   -f &lt;filename&gt; ( --file &lt;filename&gt; )
   -l &lt;linenum&gt; ( --line &lt;linenum&gt; )
   -n &lt;function-name&gt; ( --name &lt;function-name&gt; )
…
</code></pre>

<p>各选项的顺序是任意的。如果后面的参数是以&#8221;&ndash;&ldquo;开头的，则在选项后面添加&rdquo;&mdash;&ldquo;作为选项的终止信号，以告诉LLDB我们处理的选项的正确位置。如下命令所示：</p>

<pre><code>(lldb) process launch --stop-at-entry -- -program_arg_1 value -program_arg_2 value
</code></pre>

<p>如上所示，命令的选项是&mdash;stop-at-entry，参数是-program_arg_1和-program_arg_2，我们使用&#8221;&mdash;&ldquo;将选项与参数作一下区分。</p>

<h3>原始命令</h3>

<p>LLDB命令解析器支持&#8221;原始(raw)&ldquo;命令，即没有命令选项，命令字符串的剩余部分未经解析就传递给命令。例如，expression就是一个原始命令。</p>

<p>不过原始命令也可以有选项，如果命令字符串中有虚线，则在命令名与命令字符串之间放置一个选项结束符(&mdash;)来表明没有命令标记。</p>

<p>我们可以通过help命令的输出来查看一个命令是否是原始命令。</p>

<h3>命令补全(Command Completion)</h3>

<p>LLDB支持源文件名，符号名，文件名，等等的命令补全(Commmand Completion)。终端窗口中的补全是通过在命令行中输入一个制表符来初始化的。Xcode控制台中的补全与在源码编辑器中的补全方式是一样的：补全会在第三个字符被键入时自动弹出，或者通过Esc键手动弹出。</p>

<p>一个命令中的私有选项可以有不同的完成者(completers)。如breakpoint中的&mdash;file <path>选项作为源文件的完成者，&mdash;shlib <path>选项作为当前加载的库的完成者，等等。这些行为是特定的，例如，如果指定&mdash;shlib <path>，且以&mdash;file <path>结尾，则LLDB只会列出由&mdash;shlib <path>指定的共享类库。</p>

<h3>Python脚本</h3>

<p>对于高级用户来说，LLDB有一个内置的Python解析器，可以通过脚本命令来访问。调试器中的所有特性在Python解析器中都可以作为类来访问。这样，我们就可以使用LLDB-Python库来写Python函数，并通过脚本将其加载到运行会话中，以执行一些更复杂的调试操作。</p>

<h2>在命令行中调试程序</h2>

<p>通常我们都是在Xcode中直接使用LLDB调试器，Xcode会帮我们完成很多操作。当然，如果我们想让自己看着更Bigger，或者想了解下调试器具体的一些流程，就可以试试直接在终端使用LLDB命令来调试程序。在终端中使用LLDB调试器，我们需要了解以下内容：</p>

<ol>
<li>加载程序以备调试</li>
<li>将一个运行的程序绑定到LLDB</li>
<li>设置断点和观察点</li>
<li>控制程序的执行</li>
<li>在调试的程序中导航</li>
<li>检查状态和值的变量</li>
<li>执行替代代码</li>
</ol>


<p>了解在终端中这些操作是如何进行的，可以帮助我们更深入的了解调试器在Xcode中是如何运作的。下面我们分步来介绍一下。</p>

<h3>指定需要调试的程序</h3>

<p>首先我们需要设置需要调试的程序。我们可以使用如下命令做到这一点：</p>

<pre><code>$ lldb /Projects/Sketch/build/Debug/Sketch.app 
Current executable set to '/Projects/Sketch/build/Debug/Sketch.app' (x86_64).
</code></pre>

<p>或者在运行lldb后，使用file命令来处理，如下所示：</p>

<pre><code>$ lldb 
(lldb) file /Projects/Sketch/build/Debug/Sketch.app 
Current executable set to '/Projects/Sketch/build/Debug/Sketch.app' (x86_64).
</code></pre>

<h3>设置断点</h3>

<p>在设置完程序后，我们可能想设置一点断点来调试程序。此时我们可以使用breakpoint set命令来设置断点，这个命令简单、直观，且有智能补全，接下来我们看看它的具体操作。</p>

<p>如果想在某个文件中的某行设置一个断点，可使用以下命令：</p>

<pre><code>(lldb) breakpoint set --file foo.c --line 12
</code></pre>

<p>如果想给某个函数设置断点，可使用以下命令：</p>

<pre><code>(lldb) breakpoint set --name foo
</code></pre>

<p>如果想给C++中所有命名为foo的方法设置断点，可以使用以下命令：</p>

<pre><code>(lldb) breakpoint set --method foo
</code></pre>

<p>如果想给Objective-C中所有命名为alignLeftEdges:的选择器设置断点，则可以使用以下命令：</p>

<pre><code>(lldb) breakpoint set --selector alignLeftEdges:
</code></pre>

<p>我们可以使用&mdash;shlib &lt;path>来将断点限定在一个特定的可执行库中：</p>

<pre><code>(lldb) breakpoint set --shlib foo.dylib --name foo
</code></pre>

<p>看吧，断点设置命令还是很强大的。</p>

<p>如果我们想查看程序中所有的断点，则可以使用breakpoint list命令，如下所示：</p>

<pre><code>(lldb) breakpoint list
Current breakpoints:
1: name = 'alignLeftEdges:', locations = 1, resolved = 1
  1.1: where = Sketch`-[SKTGraphicView alignLeftEdges:] + 33 at /Projects/Sketch/SKTGraphicView.m:1405, address = 0x0000000100010d5b, resolved, hit count = 0
</code></pre>

<p>从上面的输出结果可以看出，一个断点一般有两部分：</p>

<ol>
<li>断点的逻辑规范，这一部分是用户提供给breakpoint set命令的。</li>
<li>与规范匹配的断点的位置。</li>
</ol>


<p>如上所示，通过&#8221;breakpoint set &mdash;selector alignLeftEdges:&ldquo;设置的断点，其信息中会显示出所有alignLeftEdges:方法的位置。</p>

<p>breakpoint list命令输出列表显示每个逻辑断点都有一个整数标识，如上所示断点标识为1。而每个位置也会有一个标识，如上所示的1.1。</p>

<p>输出列表中另一个信息是断点位置是否是已解析的(resolved)。这个标识表示当与之相关的文件地址被加载到程序进行调试时，其位置是已解析的。例如，如果在共享库中设置的断点之后被卸载了，则断点的位置还会保留，但其不能再被解析。</p>

<p>不管是逻辑断点产生的所有位置，还是逻辑断点解析的任何特定位置，我们都可以使用断点触发命令来对其进行删除、禁用、设置条件或忽略计数操作。例如，如果我们想添加一个命令，以在LLDB命中断点1.1时打印跟踪栈，则可以执行以下命令</p>

<pre><code>(lldb) breakpoint command add 1.1
Enter your debugger command(s). Type 'DONE' to end.
&gt; bt
&gt; DONE
</code></pre>

<p>如果想更详细地了解&#8221;breakpoint command add&#8221;命令的使用，可以使用help帮助系统来查看。</p>

<h3>设置观察点</h3>

<p>作为断点的补充，LLDB支持观察点以在不中断程序运行的情况下监测一些变量。例如，我们可以使用以下命令来监测名为global的变量的写操作，并在(global==5)为真时停止监测：</p>

<pre><code>(lldb) watch set var global
Watchpoint created: Watchpoint 1: addr = 0x100001018 size = 4 state = enabled type = w
   declare @ '/Volumes/data/lldb/svn/ToT/test/functionalities/watchpoint/watchpoint_commands/condition/main.cpp:12'
(lldb) watch modify -c '(global==5)'
(lldb) watch list
Current watchpoints:
Watchpoint 1: addr = 0x100001018 size = 4 state = enabled type = w
    declare @ '/Volumes/data/lldb/svn/ToT/test/functionalities/watchpoint/watchpoint_commands/condition/main.cpp:12'
    condition = '(global==5)'
(lldb) c
Process 15562 resuming
(lldb) about to write to 'global'...
Process 15562 stopped and was programmatically restarted.
Process 15562 stopped and was programmatically restarted.
Process 15562 stopped and was programmatically restarted.
Process 15562 stopped and was programmatically restarted.
Process 15562 stopped
* thread #1: tid = 0x1c03, 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16, stop reason = watchpoint 1
    frame #0: 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16
   13
   14      static void modify(int32_t &amp;var) {
   15          ++var;
-&gt; 16      }
   17
   18      int main(int argc, char** argv) {
   19          int local = 0;
(lldb) bt
* thread #1: tid = 0x1c03, 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16, stop reason = watchpoint 1
    frame #0: 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16
    frame #1: 0x0000000100000eac a.out`main + 108 at main.cpp:25
    frame #2: 0x00007fff8ac9c7e1 libdyld.dylib`start + 1
(lldb) frame var global
(int32_t) global = 5
(lldb) watch list -v
Current watchpoints:
Watchpoint 1: addr = 0x100001018 size = 4 state = enabled type = w
    declare @ '/Volumes/data/lldb/svn/ToT/test/functionalities/watchpoint/watchpoint_commands/condition/main.cpp:12'
    condition = '(global==5)'
    hw_index = 0  hit_count = 5     ignore_count = 0
(lldb)
</code></pre>

<p>可以使用help watchpoint来查看该命令的使用。</p>

<h3>使用LLDB来启动程序</h3>

<p>一旦指定了调试哪个程序，并为其设置了一些断点后，就可以开始运行程序了。我们可以使用以下命令来启动程序：</p>

<pre><code>(lldb) process launch
(lldb) run
(lldb) r
</code></pre>

<p>我们同样可以使用进程ID或进程名来连接一个已经运行的程序。当使用名称来连接一个程序时，LLDB支持&mdash;waitfor选项。这个选项告诉LLDB等待下一个名称为指定名称的程序出现，然后连接它。例如，下面3个命令都是用于连接Sketch程序(假定其进程ID为123)：</p>

<pre><code>(lldb) process attach --pid 123
(lldb) process attach --name Sketch
(lldb) process attach --name Sketch --waitfor
</code></pre>

<p>启动或连接程序后，进程可能由于某些原因而停止，如：</p>

<pre><code>(lldb) process attach -p 12345
Process 46915 Attaching
Process 46915 Stopped
1 of 3 threads stopped with reasons:
* thread #1: tid = 0x2c03, 0x00007fff85cac76a, where = libSystem.B.dylib`__getdirentries64 + 10,
stop reason = signal = SIGSTOP, queue = com.apple.main-thread
</code></pre>

<p>注意“1 of 3 threads stopped with reasons:”及其下面一行。在多线程环境下，在内核实际返回控制权给调试器前，可能会有多个线程命中同一个断点。在这种情况下，我们可以在停止信息中看到所有因此而停止的线程。</p>

<h3>控制程序</h3>

<p>启动程序后，LLDB允许程序在到达断点前继续运行。LLDB中流程控制的命令都在thread命令层级中。如下所示：</p>

<pre><code>(lldb) thread continue
Resuming thread 0x2c03 in process 46915
Resuming process 46915
</code></pre>

<p>另外，还有以下命令：</p>

<pre><code>(lldb) thread step-in // The same as "step" or "s" in GDB.
(lldb) thread step-over // The same as "next" or "n" in GDB.
(lldb) thread step-out // The same as "finish" or "f" in GDB.
(lldb) thread step-inst // The same as "stepi" / "si" in GDB.
(lldb) thread step-over-inst // The same as "nexti" / "ni" in GDB.
</code></pre>

<p>LLDB还提供了run until line按步调度模式，如：</p>

<pre><code>lldb) thread until 100
</code></pre>

<p>这条命令会运行线程，直到当前frame到达100行。如果代码在运行的过程中跳过了100行，则当frame被弹出栈后终止执行。</p>

<h3>查看线程状态</h3>

<p>在进程停止后，LLDB会选择一个当前线程和线程中当前帧(frame)。很多检测状态的命令可以用于这个线程或帧。</p>

<p>为了检测进程的当前状态，可以从以下命令开始：</p>

<pre><code>(lldb) thread list
Process 46915 state is Stopped
* thread #1: tid = 0x2c03, 0x00007fff85cac76a, where = libSystem.B.dylib`__getdirentries64 + 10, stop reason = signal = SIGSTOP, queue = com.apple.main-thread
  thread #2: tid = 0x2e03, 0x00007fff85cbb08a, where = libSystem.B.dylib`kevent + 10, queue = com.apple.libdispatch-manager
  thread #3: tid = 0x2f03, 0x00007fff85cbbeaa, where = libSystem.B.dylib`__workq_kernreturn + 10
</code></pre>

<p>星号(*)表示thread #1为当前线程。为了获取线程的跟踪栈，可以使用以下命令：</p>

<pre><code>(lldb) thread backtrace

thread #1: tid = 0x2c03, stop reason = breakpoint 1.1, queue = com.apple.main-thread
 frame #0: 0x0000000100010d5b, where = Sketch`-[SKTGraphicView alignLeftEdges:] + 33 at /Projects/Sketch/SKTGraphicView.m:1405
 frame #1: 0x00007fff8602d152, where = AppKit`-[NSApplication sendAction:to:from:] + 95
 frame #2: 0x00007fff860516be, where = AppKit`-[NSMenuItem _corePerformAction] + 365
 frame #3: 0x00007fff86051428, where = AppKit`-[NSCarbonMenuImpl performActionWithHighlightingForItemAtIndex:] + 121
 frame #4: 0x00007fff860370c1, where = AppKit`-[NSMenu performKeyEquivalent:] + 272
 frame #5: 0x00007fff86035e69, where = AppKit`-[NSApplication _handleKeyEquivalent:] + 559
 frame #6: 0x00007fff85f06aa1, where = AppKit`-[NSApplication sendEvent:] + 3630
 frame #7: 0x00007fff85e9d922, where = AppKit`-[NSApplication run] + 474
 frame #8: 0x00007fff85e965f8, where = AppKit`NSApplicationMain + 364
 frame #9: 0x0000000100015ae3, where = Sketch`main + 33 at /Projects/Sketch/SKTMain.m:11
 frame #10: 0x0000000100000f20, where = Sketch`start + 52
</code></pre>

<p>如果想查看所有线程的调用栈，则可以使用以下命令：</p>

<pre><code>(lldb) thread backtrace all
</code></pre>

<h3>查看调用栈状态</h3>

<p>检查帧参数和本地变量的最简便的方式是使用frame variable命令：</p>

<pre><code>(lldb) frame variable
self = (SKTGraphicView *) 0x0000000100208b40
_cmd = (struct objc_selector *) 0x000000010001bae1
sender = (id) 0x00000001001264e0
selection = (NSArray *) 0x00000001001264e0
i = (NSUInteger) 0x00000001001264e0
c = (NSUInteger) 0x00000001001253b0
</code></pre>

<p>如果没有指定任何变量名，则会显示所有参数和本地变量。如果指定参数名或变量名，则只打印指定的值。如：</p>

<pre><code>(lldb) frame variable self
(SKTGraphicView *) self = 0x0000000100208b40
</code></pre>

<p>frame variable命令不是一个完全的表达式解析器，但它支持一些简单的操作符，如&amp;,*,&ndash;>,[]。这个数组括号可用于指针，以将指针作为数组处理。如下所示：</p>

<pre><code>(lldb) frame variable *self
(SKTGraphicView *) self = 0x0000000100208b40
(NSView) NSView = {
(NSResponder) NSResponder = {
...

(lldb) frame variable &amp;self
(SKTGraphicView **) &amp;self = 0x0000000100304ab

(lldb) frame variable argv[0]
(char const *) argv[0] = 0x00007fff5fbffaf8 "/Projects/Sketch/build/Debug/Sketch.app/Contents/MacOS/Sketch"
</code></pre>

<p>frame variable命令会在变量上执行&#8221;对象打印&#8221;操作。目前，LLDB只支持Objective-C打印，使用的是对象的description方法。</p>

<p>如果想查看另外一帧，可以使用frame select命令，如下所示：</p>

<pre><code>(lldb) frame select 9
frame #9: 0x0000000100015ae3, where = Sketch`function1 + 33 at /Projects/Sketch/SKTFunctions.m:11
</code></pre>

<h3>小结</h3>

<p>以上所介绍的命令可以让我们在终端中直接调试程序。当然，很多命令也可以在Xcode中直接使用。这些命令可以让我们了解程序运行的状态，当然有些状态可以在Xcode中了解到。建议在调试过程中，可以多使用这些命令。</p>

<p>如果想了解这一过程中使用的各种命令，可以查看<a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5">苹果的官方文档</a>。</p>

<h2>在Xcode中调试程序</h2>

<p>对于我们日常的开发工作来说，更多的时候是在Xcode中进行调试工作。因此上面所描述的流程，其实Xcode已经帮我们完成了大部分的工作，而且很多东西也可以在Xcode里面看到。因此，我们可以把精力都集中在代码层面上。</p>

<p>在<a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5">苹果的官方文档</a>中列出了我们在调试中能用到的一些命令，我们在这重点讲一些常用的命令。</p>

<h3>打印</h3>

<p>打印变量的值可以使用print命令，该命令如果打印的是简单类型，则会列出简单类型的类型和值。如果是对象，还会打印出对象指针地址，如下所示：</p>

<pre><code>(lldb) print a
(NSInteger) $0 = 0
(lldb) print b
(NSInteger) $1 = 0
(lldb) print str
(NSString *) $2 = 0x0000000100001048 @"abc"
(lldb) print url
(NSURL *) $3 = 0x0000000100206cc0 @"abc"
</code></pre>

<p>在输出结果中我们还能看到类似于$0,$1这样的符号，我们可以将其看作是指向对象的一个引用，我们在控制面板中可以直接使用这个符号来操作对应的对象，这些东西存在于LLDB的全名空间中，目的是为了辅助调试。如下所示：</p>

<pre><code>(lldb) exp $0 = 100
(NSInteger) $9 = 100
(lldb) p a
(NSInteger) $10 = 100
</code></pre>

<p>另外$后面的数值是递增的，每打印一个与对象相关的命令，这个值都会加1。</p>

<p>上面的print命令会打印出对象的很多信息，如果我们只想查看对象的值的信息，则可以使用po(print object的缩写)命令，如下所示：</p>

<pre><code>(lldb) po str
abc
</code></pre>

<p>当然，po命令是&#8221;exp -O &mdash;&ldquo;命令的别名，使用&#8221;exp -O &mdash;&#8221;能达到同样的效果。</p>

<p>对于简单类型，我们还可以为其指定不同的打印格式，其命令格式是print/，如下所示：</p>

<pre><code>(lldb) p/x a
(NSInteger) $13 = 0x0000000000000064
</code></pre>

<p>格式的完整清单可以参考<a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html">Output Formats</a>。</p>

<h3>expression</h3>

<p>在开发中，我们经常会遇到这样一种情况：我们设置一个视图的背景颜色，运行后发现颜色不好看。嗯，好吧，在代码里面修改一下，再编译运行一下，嗯，还是不好看，然后再修改吧～～这样无形中浪费了我们大把的时间。在这种情况下，expression命令强大的功能就能体现出来了，它不仅会改变调试器中的值，还改变了程序中的实际值。我们先来看看实际效果，如下所示：</p>

<pre><code>(lldb) exp a = 10
(NSInteger) $0 = 10
(lldb) exp b = 100
(NSInteger) $1 = 100
2015-01-25 14:00:41.313 test[18064:71466] a + b = 110, abc
</code></pre>

<p>expression命令的功能不仅于此，正如上面的po命令，其实际也是&#8221;expression -O &mdash;&ldquo;命令的别名。更详细使用可以参考<a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5">Evaluating Expressions</a>。</p>

<h3>image</h3>

<p>image命令的用法也挺多，首先可以用它来查看工程中使用的库，如下所示：</p>

<pre><code>(lldb) image list
[  0] 432A6EBF-B9D2-3850-BCB2-821B9E62B1E0 0x0000000100000000 /Users/**/Library/Developer/Xcode/DerivedData/test-byjqwkhxixddxudlnvqhrfughkra/Build/Products/Debug/test 
[  1] 65DCCB06-339C-3E25-9702-600A28291D0E 0x00007fff5fc00000 /usr/lib/dyld 
[  2] E3746EDD-DFB1-3ECB-88ED-A91AC0EF3AAA 0x00007fff8d324000 /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation 
[  3] 759E155D-BC42-3D4E-869B-6F57D477177C 0x00007fff8869f000 /usr/lib/libobjc.A.dylib 
[  4] 5C161F1A-93BA-3221-A31D-F86222005B1B 0x00007fff8c75c000 /usr/lib/libSystem.B.dylib 
[  5] CBD1591C-405E-376E-87E9-B264610EBF49 0x00007fff8df0d000 /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation 
[  6] A260789B-D4D8-316A-9490-254767B8A5F1 0x00007fff8de36000 /usr/lib/libauto.dylib 
......
</code></pre>

<p>我们还可以用它来查找可执行文件或共享库的原始地址，这一点还是很有用的，当我们的程序崩溃时，我们可以使用这条命令来查找崩溃所在的具体位置，如下所示：</p>

<pre><code>NSArray *array = @[@1, @2];
NSLog(@"item 3: %@", array[2]);
</code></pre>

<p>这段代码在运行后会抛出如下异常：</p>

<pre><code>2015-01-25 14:12:01.007 test[18122:76474] *** Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSArrayI objectAtIndex:]: index 2 beyond bounds [0 .. 1]'
*** First throw call stack:
(
    0   CoreFoundation                      0x00007fff8e06f66c __exceptionPreprocess + 172
    1   libobjc.A.dylib                     0x00007fff886ad76e objc_exception_throw + 43
    2   CoreFoundation                      0x00007fff8df487de -[__NSArrayI objectAtIndex:] + 190
    3   test                                0x0000000100000de0 main + 384
    4   libdyld.dylib                       0x00007fff8f1b65c9 start + 1
)
libc++abi.dylib: terminating with uncaught exception of type NSException
</code></pre>

<p>根据以上信息，我们可以判断崩溃位置是在main.m文件中，要想知道具体在哪一行，可以使用以下命令：</p>

<pre><code>(lldb) image lookup --address 0x0000000100000de0
      Address: test[0x0000000100000de0] (test.__TEXT.__text + 384)
      Summary: test`main + 384 at main.m:23
</code></pre>

<p>可以看到，最后定位到了main.m文件的第23行，正是我们代码所在的位置。</p>

<p>我们还可以使用image lookup命令来查看具体的类型，如下所示：</p>

<pre><code>(lldb) image lookup --type NSURL
Best match found in /Users/**/Library/Developer/Xcode/DerivedData/test-byjqwkhxixddxudlnvqhrfughkra/Build/Products/Debug/test:
id = {0x100000157}, name = "NSURL", byte-size = 40, decl = NSURL.h:17, clang_type = "@interface NSURL : NSObject{
    NSString * _urlString;
    NSURL * _baseURL;
    void * _clients;
    void * _reserved;
}
@property ( readonly,getter = absoluteString,setter = &lt;null selector&gt;,nonatomic ) NSString * absoluteString;
@property ( readonly,getter = relativeString,setter = &lt;null selector&gt;,nonatomic ) NSString * relativeString;
@property ( readonly,getter = baseURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * baseURL;
@property ( readonly,getter = absoluteURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * absoluteURL;
@property ( readonly,getter = scheme,setter = &lt;null selector&gt;,nonatomic ) NSString * scheme;
@property ( readonly,getter = resourceSpecifier,setter = &lt;null selector&gt;,nonatomic ) NSString * resourceSpecifier;
@property ( readonly,getter = host,setter = &lt;null selector&gt;,nonatomic ) NSString * host;
@property ( readonly,getter = port,setter = &lt;null selector&gt;,nonatomic ) NSNumber * port;
@property ( readonly,getter = user,setter = &lt;null selector&gt;,nonatomic ) NSString * user;
@property ( readonly,getter = password,setter = &lt;null selector&gt;,nonatomic ) NSString * password;
@property ( readonly,getter = path,setter = &lt;null selector&gt;,nonatomic ) NSString * path;
@property ( readonly,getter = fragment,setter = &lt;null selector&gt;,nonatomic ) NSString * fragment;
@property ( readonly,getter = parameterString,setter = &lt;null selector&gt;,nonatomic ) NSString * parameterString;
@property ( readonly,getter = query,setter = &lt;null selector&gt;,nonatomic ) NSString * query;
@property ( readonly,getter = relativePath,setter = &lt;null selector&gt;,nonatomic ) NSString * relativePath;
@property ( readonly,getter = fileSystemRepresentation,setter = &lt;null selector&gt; ) const char * fileSystemRepresentation;
@property ( readonly,getter = isFileURL,setter = &lt;null selector&gt;,readwrite ) BOOL fileURL;
@property ( readonly,getter = standardizedURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * standardizedURL;
@property ( readonly,getter = filePathURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * filePathURL;
@end"
</code></pre>

<p>可以看到，输出结果中列出了NSURL的一些成员变量及属性信息。</p>

<p>image命令还有许多其它功能，具体可以参考<a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5">Executable and Shared Library Query Commands</a>。</p>

<h3>流程控制</h3>

<p>流程控制的命令实际上我们在上一小节已经讲过了，在Xcode的控制面板中同样可以使用这些命令，在此不在重复。</p>

<h2>命令别名及帮助系统</h2>

<p>LLDB有两个非常有用的特性，即命令别名及帮助。</p>

<h3>命令别名</h3>

<p>我们可以使用LLDB的别名机制来为常用的命令创建一个别名，以方便我们的使用，如下命令：</p>

<pre><code>(lldb) breakpoint set --file foo.c --line 12
</code></pre>

<p>如果在我们的调试中需要经常用到这条命令，则每次输入这么一长串的字符一定会很让人抓狂。此时，我们就可以为这条命令创建一个别名，如下所示：</p>

<pre><code>(lldb) command alias bfl breakpoint set -f %1 -l %2
</code></pre>

<p>这样，我们只需要按如下方式来使用它即可：</p>

<pre><code>(lldb) bfl foo.c 12
</code></pre>

<p>是不是简单多了？</p>

<p>我们可以自由地创建LLDB命令的别名集合。LLDB在启动时会读取~/.lldbinit文件。这个文件中存储了command alias命令创建的别名。LLDB帮助系统会读取这个初始化文件并会列出这些别名，以让我们了解自己所设置的别名。我们可以使用&#8221;help -a&#8221;命令并在输出的后面来查看这边别名，其以下面这行开始：</p>

<pre><code>...
The following is a list of your current command abbreviations (see 'help command alias' for more info): ...
</code></pre>

<p>如果我们不喜欢已有命令的别名，则可以使用以下命令来取消这个别名：</p>

<pre><code>(lldb) command unalias b
</code></pre>

<h3>帮助系统</h3>

<p>LLDB帮助系统让我们可以了解LLDB提供了哪些功能，并可以查看LLDB命令结构的详细信息。熟悉帮助系统可以让我们访问帮助系统中中命令文档。</p>

<p>我们可以简单地调用help命令来列出LLDB所有的顶层命令。如下所示：</p>

<pre><code>(lldb) help
The following is a list of built-in, permanent debugger commands:

_regexp-attach    -- Attach to a process id if in decimal, otherwise treat the
                     argument as a process name to attach to.
_regexp-break     -- Set a breakpoint using a regular expression to specify the
                     location, where &lt;linenum&gt; is in decimal and &lt;address&gt; is
                     in hex.
_regexp-bt        -- Show a backtrace.  An optional argument is accepted; if
                     that argument is a number, it specifies the number of
                     frames to display.  If that argument is 'all', full
                     backtraces of all threads are displayed.
 … and so forth …
</code></pre>

<p>如果help后面跟着某个特定的命令，则会列出该命令相关的所有信息，我们以breakpoint set为例，输出信息如下：</p>

<pre><code>(lldb) help breakpoint set
     Sets a breakpoint or set of breakpoints in the executable.

Syntax: breakpoint set &lt;cmd-options&gt;

Command Options Usage:
  breakpoint set [-Ho] -l &lt;linenum&gt; [-s &lt;shlib-name&gt;] [-i &lt;count&gt;] [-c &lt;expr&gt;] [-x &lt;thread-index&gt;] [-t &lt;thread-id&gt;] [-T &lt;thread-name&gt;] [-q &lt;queue-name&gt;] [-f &lt;filename&gt;] [-K &lt;boolean&gt;]
  breakpoint set [-Ho] -a &lt;address-expression&gt; [-s &lt;shlib-name&gt;] [-i &lt;count&gt;] [-c &lt;expr&gt;] [-x &lt;thread-index&gt;] [-t &lt;thread-id&gt;] [-T &lt;thread-name&gt;] [-q &lt;queue-name&gt;]
  breakpoint set [-Ho] -n &lt;function-name&gt; [-s &lt;shlib-name&gt;] [-i &lt;count&gt;] [-c &lt;expr&gt;] [-x &lt;thread-index&gt;] [-t &lt;thread-id&gt;] [-T &lt;thread-name&gt;] [-q &lt;queue-name&gt;] [-f &lt;filename&gt;] [-K &lt;boolean&gt;] [-L &lt;language&gt;]
  breakpoint set [-Ho] -F &lt;fullname&gt; [-s &lt;shlib-name&gt;] [-i &lt;count&gt;] [-c &lt;expr&gt;] [-x &lt;thread-index&gt;] [-t &lt;thread-id&gt;] [-T &lt;thread-name&gt;] [-q &lt;queue-name&gt;] [-f &lt;filename&gt;] [-K &lt;boolean&gt;]

 … and so forth …
</code></pre>

<p>还有一种更直接的方式来查看LLDB有哪些功能，即使用apropos命令：它会根据关键字来搜索LLDB帮助文档，并为每个命令选取一个帮助字符串，我们以apropos file为例，其输出如下：</p>

<pre><code>(lldb) apropos file
The following commands may relate to 'file':
…
log enable                     -- Enable logging for a single log channel.
memory read                    -- Read from the memory of the process being
                                  debugged.
memory write                   -- Write to the memory of the process being
                                  debugged.
platform process launch        -- Launch a new process on a remote platform.
platform select                -- Create a platform if needed and select it as
                                  the current platform.
plugin load                    -- Import a dylib that implements an LLDB
                                  plugin.
process launch                 -- Launch the executable in the debugger.
process load                   -- Load a shared library into the current
                                  process.
source                         -- A set of commands for accessing source file
                                  information
… and so forth …
</code></pre>

<p>我们还可以使用help来了解一个命令别名的构成。如：</p>

<pre><code>(lldb) help b
…
'b' is an abbreviation for '_regexp-break'
</code></pre>

<p>help命令的另一个特性是可以查看某个具体参数的使用，我们以&#8221;break command add&#8221;命令为例：</p>

<pre><code>(lldb) help break command add
Add a set of commands to a breakpoint, to be executed whenever the breakpoint is hit.

Syntax: breakpoint command add &lt;cmd-options&gt; &lt;breakpt-id&gt;
etc...
</code></pre>

<p>如果想了解以上输出的参数&lt;breakpt-id>的作用，我们可以在help后面直接指定这个参数(将其放在尖括号内)来查询它的详细信息，如下所示：</p>

<pre><code>(lldb) help &lt;breakpt-id&gt;

&lt;breakpt-id&gt; -- Breakpoint IDs consist major and minor numbers; the major
etc...
</code></pre>

<p>帮助系统能让我们快速地了解一个LLDB命令的使用方法。经常使用它，可以让我们更快地熟悉LLDB的各项功能，所以建议多使用它。</p>

<h2>总结</h2>

<p>LLDB带给我们强大的调试功能，在调试过程中充分地利用它可以帮助我们极大地提高调试效率。我们可以不用写那么多的NSLog来打印一大堆的日志。所以建议在日常工作中多去使用它。当然，上面的命令只是LLDB的冰山一角，更多的使用还需要大家自己去发掘，在此只是抛砖引玉，做了一些整理。</p>

<h2>参考</h2>

<ol>
<li><a href="http://lldb.llvm.org/tutorial.html">The LLDB Debugger</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html">LLDB Quick Start Guide</a></li>
<li><a href="http://www.cocoachina.com/ios/20141219/10709.html">与调试器共舞 &ndash; LLDB 的华尔兹</a></li>
<li><a href="http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/">LLDB调试命令初探</a></li>
<li><a href="http://www.cocoachina.com/ios/20140530/8619.html">NSLog效率低下的原因及尝试lldb断点打印Log</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[源码篇：Mantle]]></title>
    <link href="http://southpeak.github.io/blog/2015/01/11/yuan-ma-pian-:mantle/"/>
    <updated>2015-01-11T22:01:00+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/01/11/yuan-ma-pian-:mantle</id>
    <content type="html"><![CDATA[<p>Mantle是一个用于简化Cocoa或Cocoa Touch程序中model层的第三方库。通常我们的应该中都会定义大量的model来表示各种数据结构，而这些model的初始化和编码解码都需要写大量的代码。而Mantle的优点在于能够大大地简化这些代码。</p>

<p>Mantle源码中最主要的内容包括：</p>

<ol>
<li>MTLModel类：通常是作为我们的Model的基类，该类提供了一些默认的行为来处理对象的初始化和归档操作，同时可以获取到对象所有属性的键值集合。</li>
<li>MTLJSONAdapter类：用于在MTLModel对象和JSON字典之间进行相互转换，相当于是一个适配器。</li>
<li>MTLJSONSerializing协议：需要与JSON字典进行相互转换的MTLModel的子类都需要实现该协议，以方便MTLJSONApadter对象进行转换。</li>
</ol>


<p>在此就以这三者作为我们的分析点。</p>

<h2>基类MTLModel</h2>

<p>MTLModel是一个抽象类，它主要提供了一些默认的行为来处理对象的初始化和归档操作。</p>

<h3>初始化</h3>

<p>MTLModel默认的初始化方法-init并没有做什么事情，只是调用了下[super init]。而同时，它提供了一个另一个初始化方法：</p>

<pre><code>- (instancetype)initWithDictionary:(NSDictionary *)dictionaryValue error:(NSError **)error;
</code></pre>

<p>其中参数dictionaryValue是一个字典，它包含了用于初始化对象的key-value对。我们来看下它的具体实现：</p>

<pre><code>- (instancetype)initWithDictionary:(NSDictionary *)dictionary error:(NSError **)error {
    ...

    for (NSString *key in dictionary) {

        // 1. 将value标记为__autoreleasing，这是因为在MTLValidateAndSetValue函数中，
        //    可以会返回一个新的对象存在在该变量中
        __autoreleasing id value = [dictionary objectForKey:key];

        // 2. value如果为NSNull.null，会在使用前将其转换为nil
        if ([value isEqual:NSNull.null]) value = nil;

        // 3. MTLValidateAndSetValue函数利用KVC机制来验证value的值对于key是否有效，
        //    如果无效，则使用使用默认值来设置key的值。
        //    这里同样使用了对象的KVC特性来将value值赋值给model对应于key的属性。
        //    有关MTLValidateAndSetValue的实现可参考源码，在此不做详细说明。
        BOOL success = MTLValidateAndSetValue(self, key, value, YES, error);
        if (!success) return nil;
    }

    ...
}
</code></pre>

<p>子类可以重写该方法，以在设置完对象的属性后做进一步的处理或初始化工作，不过需要记住的是：应该通过super来调用父类的实现。</p>

<h3>获取属性的键(key)、值(value)</h3>

<p>MTLModel类提供了一个类方法+propertyKeys，该方法返回所有@property声明的属性所对应的名称字符串的一个集合，但不包括只读属性和MTLModel自身的属性。在这个类方法会去遍历model的所有属性，如果属性是非只读且其ivar值不为NULL，则获取到表示属性名的字符串，并将其放入到集合中，其实现如下：</p>

<pre><code>+ (NSSet *)propertyKeys {
    // 1. 如果对象中已有缓存的属性名的集合，则直接返回缓存。该缓存是放在一个关联对象中。
    NSSet *cachedKeys = objc_getAssociatedObject(self, MTLModelCachedPropertyKeysKey);
    if (cachedKeys != nil) return cachedKeys;

    NSMutableSet *keys = [NSMutableSet set];

    // 2. 遍历对象所有的属性
    //    enumeratePropertiesUsingBlock方法会沿着superclass链一直向上遍历到MTLModel，
    //    查找当前model所对应类的继承体系中所有的属性(不包括MTLModel)，并对该属性执行block中的操作。
    //    有关enumeratePropertiesUsingBlock的实现可参考源码，在此不做详细说明。
    [self enumeratePropertiesUsingBlock:^(objc_property_t property, BOOL *stop) {
        mtl_propertyAttributes *attributes = mtl_copyPropertyAttributes(property);
        @onExit {
            free(attributes);
        };

        // 3. 过滤只读属性和ivar为NULL的属性
        if (attributes-&gt;readonly &amp;&amp; attributes-&gt;ivar == NULL) return;

        // 4. 获取属性名字符串，并存储到集合中
        NSString *key = @(property_getName(property));
        [keys addObject:key];
    }];

    // 5. 将集合缓存到关联对象中。
    objc_setAssociatedObject(self, MTLModelCachedPropertyKeysKey, keys, OBJC_ASSOCIATION_COPY);

    return keys;
}
</code></pre>

<p>有了上面这个类方法，要想获取到对象中所有属性及其对应的值就方法了。为此MTLModel提供了一个只读属性dictionaryValue来取一个包含当前model所有属性及其值的字典。如果属性值为nil，则会用NSNull来代替。另外该属性不会为nil。</p>

<pre><code>@property (nonatomic, copy, readonly) NSDictionary *dictionaryValue;

// 实现
- (NSDictionary *)dictionaryValue {
    return [self dictionaryWithValuesForKeys:self.class.propertyKeys.allObjects];
}
</code></pre>

<h3>合并对象</h3>

<p>合并对象是指将两个MTLModel对象按照自定义的方法将其对应的属性值进行合并。为此，在MTLModel定义了以下方法：</p>

<pre><code>- (void)mergeValueForKey:(NSString *)key fromModel:(MTLModel *)model;
</code></pre>

<p>该方法将当前对象指定的key属性的值与model参数对应的属性值按照指定的规则来进行合并，这种规则由我们自定义的-merge<Key>FromModel:方法来确定。如果我们的子类中实现了-merge<Key>FromModel:方法，则会调用它；如果没有找到，且model不为nil，则会用model的属性的值来替代当前对象的属性的值。具体实现如下：</p>

<pre><code>- (void)mergeValueForKey:(NSString *)key fromModel:(MTLModel *)model {
    NSParameterAssert(key != nil);

    // 1. 根据传入的key拼接"merge&lt;Key&gt;FromModel:"字符串，并从该字符串中获取到对应的selector
    //    如果当前对象没有实现-merge&lt;Key&gt;FromModel:方法，且model不为nil，则用model的属性值
    //    替代当前对象的属性值
    //
    //    MTLSelectorWithCapitalizedKeyPattern函数以C语言的方式来拼接方法字符串，具体实现请
    //    参数源码，在此不详细说明
    SEL selector = MTLSelectorWithCapitalizedKeyPattern("merge", key, "FromModel:");
    if (![self respondsToSelector:selector]) {
        if (model != nil) {
            [self setValue:[model valueForKey:key] forKey:key];
        }

        return;
    }

    // 2. 通过NSInvocation方式来调用对应的-merge&lt;Key&gt;FromModel:方法。
    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:selector]];
    invocation.target = self;
    invocation.selector = selector;

    [invocation setArgument:&amp;model atIndex:2];
    [invocation invoke];
}
</code></pre>

<p>此外，MTLModel还提供了另一个方法来合并两个对象所有的属性值，即：</p>

<pre><code>- (void)mergeValuesForKeysFromModel:(MTLModel *)model;
</code></pre>

<p>需要注意的是model必须是当前对象所属类或其子类。</p>

<h3>归档对象(Archive)</h3>

<p>Mantle将对MTLModel的编码解码处理都放在了MTLModel的NSCoding分类中进行处理了，该分类及相关的定义都放在MTLModel+NSCoding文件中。</p>

<p>对于不同的属性，在编码解码过程中可能需要区别对待，为此Mentle定义了枚举MTLModelEncodingBehavior来确定一个MTLModel属性被编码到一个归档中的行为。其定义如下：</p>

<pre><code>typedef enum : NSUInteger {
    MTLModelEncodingBehaviorExcluded = 0,           // 属性绝不应该被编码
    MTLModelEncodingBehaviorUnconditional,          // 属性总是应该被编码
    MTLModelEncodingBehaviorConditional,            // 对象只有在其它地方被无条件编码时才应该被编码。这只适用于对象属性
} MTLModelEncodingBehavior;
</code></pre>

<p>具体每个属性的归档行为我们可以在+encodingBehaviorsByPropertyKey类方法中设置。MTLModel类为我们提供了一个默认实现，如下：</p>

<pre><code>+ (NSDictionary *)encodingBehaviorsByPropertyKey {
    // 1. 获取所有属性键值
    NSSet *propertyKeys = self.propertyKeys;
    NSMutableDictionary *behaviors = [[NSMutableDictionary alloc] initWithCapacity:propertyKeys.count];

    // 2. 对每一个属性进行处理
    for (NSString *key in propertyKeys) {
        objc_property_t property = class_getProperty(self, key.UTF8String);
        NSAssert(property != NULL, @"Could not find property \"%@\" on %@", key, self);

        mtl_propertyAttributes *attributes = mtl_copyPropertyAttributes(property);
        @onExit {
            free(attributes);
        };

        // 3. 当属性为weak时，默认设置为MTLModelEncodingBehaviorConditional，否则默认为MTLModelEncodingBehaviorUnconditional，设置完后，将其封装在NSNumber中并放入字典中。
        MTLModelEncodingBehavior behavior = (attributes-&gt;weak ? MTLModelEncodingBehaviorConditional : MTLModelEncodingBehaviorUnconditional);
        behaviors[key] = @(behavior);
    }

    return behaviors;
}
</code></pre>

<p>任何不在该返回字典中的属性都不会被归档。子类可以根据自己的需要来指定各属性的归档行为。但在实际时应该通过super来调用父类的实现。</p>

<p>而为了从归档中解码指定的属性，Mantle提供了以下方法：</p>

<pre><code>- (id)decodeValueForKey:(NSString *)key withCoder:(NSCoder *)coder modelVersion:(NSUInteger)modelVersion;
</code></pre>

<p>默认情况下，该方法会查找当前对象中类似于<strong>-decode<Key>WithCoder:modelVersion:</strong>的方法，如果找到便会调用相应方法，并按照自定义的方式来处理属性的解码。如果我们没有实现自定义的方法或者coder不需要安全编码，则会对指定的key调用-[NSCoder decodeObjectForKey:]方法。其具体实现如下：</p>

<pre><code>- (id)decodeValueForKey:(NSString *)key withCoder:(NSCoder *)coder modelVersion:(NSUInteger)modelVersion {
    ...

    SEL selector = MTLSelectorWithCapitalizedKeyPattern("decode", key, "WithCoder:modelVersion:");
    // 1. 如果自定义了-decode&lt;Key&gt;WithCoder:modelVersion:方法，则通过NSInvocation来调用方法
    if ([self respondsToSelector:selector]) {
        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:selector]];
        invocation.target = self;
        invocation.selector = selector;
        [invocation setArgument:&amp;coder atIndex:2];
        [invocation setArgument:&amp;modelVersion atIndex:3];
        [invocation invoke];

        __unsafe_unretained id result = nil;
        [invocation getReturnValue:&amp;result];
        return result;
    }

    @try {
        // 2. 如果没有找到自定义的-decode&lt;Key&gt;WithCoder:modelVersion:方法，
        //    则走以下流程。
        //
        // coderRequiresSecureCoding方法的具体实现请参数源码
        if (coderRequiresSecureCoding(coder)) {
            // 3. 如果coder要求安全编码，则会从需要安全编码的字典中取出属性所对象的类型，然后根据指定
            //    类型来对属性进行解码操作。
            //    为此，MTLModel提供了类方法allowedSecureCodingClassesByPropertyKey，来获取
            //    类的对象包含的所有需要安全编码的属性及其对应的类的字典。该方法首先会查看是否已有
            //    缓存的字典，如果没有则遍历类的所有属性。首先过滤掉那些不需要编码的属性，
            //    然后遍历剩下的属性，如果是非对象类型或类类型，则其对应的类型设定为NSValue，
            //    如果是这两者，则对应的类型即为相应类型。
            //    该方法的具体实现请参考源代码。
            NSArray *allowedClasses = self.class.allowedSecureCodingClassesByPropertyKey[key];
            NSAssert(allowedClasses != nil, @"No allowed classes specified for securely decoding key \"%@\" on %@", key, self.class);

            return [coder decodeObjectOfClasses:[NSSet setWithArray:allowedClasses] forKey:key];
        } else {
            // 4. 不需要安全编码
            return [coder decodeObjectForKey:key];
        }
    } @catch (NSException *exception) {
        ...
    }
}
</code></pre>

<p>当然，所有的编码解码工作还得需要我们实现-initWithCoder:和-encodeWithCoder:两个方法来完成。我们在定义MTLModel的子类时，可以根据自己的需要来对特定的属性进行处理，不过最好调用super的实现来执行父类的操作。MTLModel对这两个方法的实现请参考源码，在此不多作说明。</p>

<h2>适配器MTLJSONApadter</h2>

<p>为了便于在MTLModel对象和JSON字典之间进行相互转换，Mantle提供了类MTLJSONApadter，作为这两者之间的一个适配器。</p>

<h3>MTLJSONSerializing协议</h3>

<p>Mantle定义了一个协议MTLJSONSerializing，那些需要与JSON字典进行相互转换的MTLModel的子类都需要实现该协议，以方便MTLJSONApadter对象进行转换。这个协议中定义了三个方法，具体如下：</p>

<pre><code>@protocol MTLJSONSerializing
@required

+ (NSDictionary *)JSONKeyPathsByPropertyKey;

@optional

+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key;
+ (Class)classForParsingJSONDictionary:(NSDictionary *)JSONDictionary;

@end
</code></pre>

<p>这三个方法都是类方法。其中+JSONKeyPathsByPropertyKey是必须实现的，它返回的字典指定了如何将对象的属性映射到JSON中不同的key path(字符串值或NSNull)中。任何不在此字典中的属性被认为是与JSON中使用的key值相匹配。而映射到NSNull的属性在JSON序列化过程中将不进行处理。</p>

<p>+JSONTransformerForKey:方法指定了如何将一个JSON值转换为指定的属性值。反过来，转换器也用于将属性值转换成JSON值。如果转换器实现了+<key>JSONTransformer方法，则MTLJSONAdapter会使用这个具体的方法，而不使用+JSONTransformerForKey:方法。另外，如果不需要执行自定义的转换，则返回nil。</p>

<p>重写+classForParsingJSONDictionary:方法可以将当前Model解析为一个不同的类对象。这对象类簇是非常有用的，其中抽象基类将被传递给-[MTLJSONAdapter initWithJSONDictionary:modelClass:]方法，而实例化的则是子类。</p>

<p>如果我们希望MTLModel的一个子类能使用MTLJSONApadter来进行转换，则需要实现这个协议，并实现相应的方法。</p>

<h3>初始化</h3>

<p>MTLJSONApadter对象有一个只读属性，该属性即为适配器需要处理的MTLModel对象，其声明如下：</p>

<pre><code>@property (nonatomic, strong, readonly) MTLModel&lt;MTLJSONSerializing&gt; *model;
</code></pre>

<p>可见该对象必须是实现了MTLJSONSerializing协议的MTLModel对象。该属性是只读的，因此它只能通过初始化方法来初始化。</p>

<p>MTLJSONApadter对象不能通过-init来初始化，这个方法会直接断言。而是需要通过类提供的两个初始化方法来初始化，如下：</p>

<pre><code>- (id)initWithJSONDictionary:(NSDictionary *)JSONDictionary modelClass:(Class)modelClass error:(NSError **)error;

- (id)initWithModel:(MTLModel&lt;MTLJSONSerializing&gt; *)model;
</code></pre>

<p>其中-(id)initWithJSONDictionary:modelClass:error:是使用一个字典和需要转换的类来进行初始化。字典JSONDictionary表示一个JSON数据，这个字典需要符合NSJSONSerialization返回的格式。如果该参数为空，则方法返回nil，且返回带有MTLJSONAdapterErrorInvalidJSONDictionary码的error对象。该方法的具体实现如下：</p>

<pre><code>- (id)initWithJSONDictionary:(NSDictionary *)JSONDictionary modelClass:(Class)modelClass error:(NSError **)error {
    ...

    if (JSONDictionary == nil || ![JSONDictionary isKindOfClass:NSDictionary.class]) {
        ...
        return nil;
    }

    if ([modelClass respondsToSelector:@selector(classForParsingJSONDictionary:)]) {
        modelClass = [modelClass classForParsingJSONDictionary:JSONDictionary];
        if (modelClass == nil) {
            ...

            return nil;
        }

        ...
    }

    ...

    _modelClass = modelClass;
    _JSONKeyPathsByPropertyKey = [[modelClass JSONKeyPathsByPropertyKey] copy];

    NSMutableDictionary *dictionaryValue = [[NSMutableDictionary alloc] initWithCapacity:JSONDictionary.count];

    NSSet *propertyKeys = [self.modelClass propertyKeys];

    // 1. 检验model的+JSONKeyPathsByPropertyKey中字典key-value对的有效性
    for (NSString *mappedPropertyKey in self.JSONKeyPathsByPropertyKey) {
        // 2. 如果model对象的属性不包含+JSONKeyPathsByPropertyKey返回的字典中的某个属性键值
        //    则返回nil。即+JSONKeyPathsByPropertyKey中指定的属性键值必须是model对象所包含
        //    的属性。
        if (![propertyKeys containsObject:mappedPropertyKey]) {
            ...
            return nil;
        }

        id value = self.JSONKeyPathsByPropertyKey[mappedPropertyKey];

        // 3. 如果属性不是映射到一个JSON关键路径或者是NSNull，也返回nil。
        if (![value isKindOfClass:NSString.class] &amp;&amp; value != NSNull.null) {
            ...
            return nil;
        }
    }

    for (NSString *propertyKey in propertyKeys) {
        NSString *JSONKeyPath = [self JSONKeyPathForPropertyKey:propertyKey];
        if (JSONKeyPath == nil) continue;

        id value;
        @try {
            value = [JSONDictionary valueForKeyPath:JSONKeyPath];
        } @catch (NSException *ex) {
            ...

            return nil;
        }

        if (value == nil) continue;

        @try {
            // 4. 获取一个转换器，
            //    如上所述，+JSONTransformerForKey:会先去查看是否有+&lt;key&gt;JSONTransformer方法，
            //    如果有则会使用这个具体的方法，如果没有，则调用相应的+JSONTransformerForKey:方法
            //    该方法具体实现请参考源码
            NSValueTransformer *transformer = [self JSONTransformerForKey:propertyKey];
            if (transformer != nil) {

                // 5. 获取转换器转换生的值
                if ([value isEqual:NSNull.null]) value = nil;
                value = [transformer transformedValue:value] ?: NSNull.null;
            }

            dictionaryValue[propertyKey] = value;
        } @catch (NSException *ex) {
            ...

            return nil;
        }
    }

    // 6. 初始化_model
    _model = [self.modelClass modelWithDictionary:dictionaryValue error:error];
    if (_model == nil) return nil;

    return self;
}
</code></pre>

<p>另外，MTLJSONApadter还提供了几个类方法来创建一个MTLJSONApadter对象，如下：</p>

<pre><code>+ (id)modelOfClass:(Class)modelClass fromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error;

+ (NSArray *)modelsOfClass:(Class)modelClass fromJSONArray:(NSArray *)JSONArray error:(NSError **)error;

+ (NSDictionary *)JSONDictionaryFromModel:(MTLModel&lt;MTLJSONSerializing&gt; *)model;
</code></pre>

<p>具体实现可参考源码。</p>

<h3>从对象中获取JSON数据</h3>

<p>从MTLModel对象中获取JSON数据是上述初始化过程中的一个逆过程。该过程由-JSONDictionary方法来实现，具体如下：</p>

<pre><code>- (NSDictionary *)JSONDictionary {
    NSDictionary *dictionaryValue = self.model.dictionaryValue;
    NSMutableDictionary *JSONDictionary = [[NSMutableDictionary alloc] initWithCapacity:dictionaryValue.count];

    [dictionaryValue enumerateKeysAndObjectsUsingBlock:^(NSString *propertyKey, id value, BOOL *stop) {
        NSString *JSONKeyPath = [self JSONKeyPathForPropertyKey:propertyKey];
        if (JSONKeyPath == nil) return;

        // 1. 获取属性的值
        NSValueTransformer *transformer = [self JSONTransformerForKey:propertyKey];
        if ([transformer.class allowsReverseTransformation]) {
            if ([value isEqual:NSNull.null]) value = nil;
            value = [transformer reverseTransformedValue:value] ?: NSNull.null;
        }

        NSArray *keyPathComponents = [JSONKeyPath componentsSeparatedByString:@"."];

        // 2. 对于嵌套属性值的设置，会先从keypath中获取每一层属性，
        //    如果当前层级的obj中没有该属性，则为其设置一个空字典；然后再进入下一层级，依此类推
        //    最后设置如下形式的字典: @{@"nested": @{@"name": @"foo"}}
        id obj = JSONDictionary;
        for (NSString *component in keyPathComponents) {
            if ([obj valueForKey:component] == nil) {
                [obj setValue:[NSMutableDictionary dictionary] forKey:component];
            }

            obj = [obj valueForKey:component];
        }

        [JSONDictionary setValue:value forKeyPath:JSONKeyPath];
    }];

    return JSONDictionary;
}
</code></pre>

<p>从上可以看出，该方法实际上最终获得的是一个字典。而获得字典后，再将其序列化为JSON串就容易了。</p>

<p>MTLJSONApadter也提供了一个简便的方法，来从一个model中获取一个JSON字典，其定义如下：</p>

<pre><code>+ (NSDictionary *)JSONDictionaryFromModel:(MTLModel&lt;MTLJSONSerializing&gt; *)model;
</code></pre>

<h3>MTLManagedObjectAdapter</h3>

<p>为了适应Core Data，Mantle专门定义了MTLManagedObjectAdapter类。该类用作MTLModel对象与NSManagedObject对象之前的转换。具体的我们在此不详细描述。</p>

<h2>技术点总结</h2>

<p>Mantle的功能主要是进行对象间数据的转换：即如何在一个MTLModel和一个JSON字典中进行数据的转换。因此，所使用的技术大都是Cocoa Foundation提供的功能。除了对于Core Data的处理之外，主要用到的技术的有如下几条：</p>

<ol>
<li>KVC的应用：这主要体现在对MTLModel子类的属性赋值中，通过KVC机制来验证值的有效性并为属性赋值。</li>
<li>NSValueTransform：这主要用于对JSON值转换为属性值的处理，我们可以自定义转换器来满足我们自己的转换需求。</li>
<li>NSInvocation：这主要用于统一处理针对特定key值的一些方法的调用。比如-merge<Key>FromModel:这一类方法。</li>
<li>Run time函数的使用：这主要用于对从一个字符串中获取到方法对应的字符串，然后通过sel_registerName函数来注册一个selector。</li>
</ol>


<p>当然在Mantle中还会涉及到其它的一些技术点，在此不多做叙述。</p>

<h2>参考</h2>

<ol>
<li><a href="https://github.com/Mantle/Mantle">Mantle工程</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工具篇：Mantle]]></title>
    <link href="http://southpeak.github.io/blog/2015/01/11/gong-ju-pian-:mantle/"/>
    <updated>2015-01-11T21:55:03+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/01/11/gong-ju-pian-:mantle</id>
    <content type="html"><![CDATA[<p>来源：<a href="https://github.com/Mantle/Mantle">https://github.com/Mantle/Mantle</a></p>

<p>版本：1.5.3</p>

<p><em>Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application.</em></p>

<p>由上面这句话可知，Mantle的目的是让我们能简化Cocoa和Cocoa Touch应用的model层。那先来看看通常我们是怎么处理model层的吧。</p>

<h2>解决的问题</h2>

<p>在我们写代码时，总要面对不同的数据来源。这些数据可能是来自网络服务器、本地数据库或者是内存中。通常我们需要将这些数据存储到一个Model中。一般情况下，我们会怎么去定义一个Model呢？以Mantle官方的例子为例，可能是这样的：</p>

<pre><code>typedef enum : NSUInteger {
    GHIssueStateOpen,
    GHIssueStateClosed
} GHIssueState;

@interface GHIssue : NSObject &lt;NSCoding, NSCopying&gt;

@property (nonatomic, copy, readonly) NSURL *URL;
@property (nonatomic, copy, readonly) NSURL *HTMLURL;
@property (nonatomic, copy, readonly) NSNumber *number;
@property (nonatomic, assign, readonly) GHIssueState state;
@property (nonatomic, copy, readonly) NSString *reporterLogin;
@property (nonatomic, copy, readonly) NSDate *updatedAt;
@property (nonatomic, strong, readonly) GHUser *assignee;
@property (nonatomic, copy, readonly) NSDate *retrievedAt;

@property (nonatomic, copy) NSString *title;
@property (nonatomic, copy) NSString *body;

- (id)initWithDictionary:(NSDictionary *)dictionary;

@end
</code></pre>

<p>假定我们从网络服务器上获取了一组GHIssue对应的JSON数据，并已经将其转换为字典后，我们便可以用这个字典对GHIssue对象进行初始化了，-initWithDictionary:的实现如下：</p>

<pre><code>- (id)initWithDictionary:(NSDictionary *)dictionary {
    self = [self init];
    if (self == nil) return nil;

    _URL = [NSURL URLWithString:dictionary[@"url"]];
    _HTMLURL = [NSURL URLWithString:dictionary[@"html_url"]];
    _number = dictionary[@"number"];

    if ([dictionary[@"state"] isEqualToString:@"open"]) {
        _state = GHIssueStateOpen;
    } else if ([dictionary[@"state"] isEqualToString:@"closed"]) {
        _state = GHIssueStateClosed;
    }

    _title = [dictionary[@"title"] copy];
    _retrievedAt = [NSDate date];
    _body = [dictionary[@"body"] copy];
    _reporterLogin = [dictionary[@"user"][@"login"] copy];
    _assignee = [[GHUser alloc] initWithDictionary:dictionary[@"assignee"]];

    _updatedAt = [self.class.dateFormatter dateFromString:dictionary[@"updated_at"]];

    return self;
}
</code></pre>

<p>如果GHIssue对象有归档需求，则还需要实现以下两个方法：</p>

<pre><code>- (id)initWithCoder:(NSCoder *)coder {
    self = [self init];
    if (self == nil) return nil;

    _URL = [coder decodeObjectForKey:@"URL"];
    _HTMLURL = [coder decodeObjectForKey:@"HTMLURL"];
    _number = [coder decodeObjectForKey:@"number"];
    _state = [coder decodeUnsignedIntegerForKey:@"state"];
    _title = [coder decodeObjectForKey:@"title"];
    _retrievedAt = [NSDate date];
    _body = [coder decodeObjectForKey:@"body"];
    _reporterLogin = [coder decodeObjectForKey:@"reporterLogin"];
    _assignee = [coder decodeObjectForKey:@"assignee"];
    _updatedAt = [coder decodeObjectForKey:@"updatedAt"];

    return self;
}

- (void)encodeWithCoder:(NSCoder *)coder {
    if (self.URL != nil) [coder encodeObject:self.URL forKey:@"URL"];
    if (self.HTMLURL != nil) [coder encodeObject:self.HTMLURL forKey:@"HTMLURL"];
    if (self.number != nil) [coder encodeObject:self.number forKey:@"number"];
    if (self.title != nil) [coder encodeObject:self.title forKey:@"title"];
    if (self.body != nil) [coder encodeObject:self.body forKey:@"body"];
    if (self.reporterLogin != nil) [coder encodeObject:self.reporterLogin forKey:@"reporterLogin"];
    if (self.assignee != nil) [coder encodeObject:self.assignee forKey:@"assignee"];
    if (self.updatedAt != nil) [coder encodeObject:self.updatedAt forKey:@"updatedAt"];

    [coder encodeUnsignedInteger:self.state forKey:@"state"];
}
</code></pre>

<p>额，好多代码。嗯，说实话，以前也经常写这种代码，真可谓又臭又长啊。也许我的工程中还有很多这样的Model，然后，然后&hellip;&hellip;靠，好烦啊。再然后，某天，服务端的同事告诉我有N个接口需要加字段，额～～崩溃中。而且，从上面的Model中，我无法将其还原为对应的JSON串，且如果某些信息变了，那么归档的数据可能就无法使用了。</p>

<p>Mantle就是针对这几个问题而开发的一个开源库。</p>

<h2>使用方法</h2>

<p>其实Mantle的使用还是很简单的，它最主要的就是二个类和一个协议，即：</p>

<ol>
<li>MTLModel类：通常是作为我们的Model的基类，该类提供了一些默认的行为来处理对象的初始化和归档操作，同时可以获取到对象所有属性的键值集合。</li>
<li>MTLJSONAdapter类：用于在MTLModel对象和JSON字典之间进行相互转换，相当于是一个适配器。</li>
<li>MTLJSONSerializing协议：需要与JSON字典进行相互转换的MTLModel的子类都需要实现该协议，以方便MTLJSONApadter对象进行转换。</li>
</ol>


<p>还以GHIssue为例，我们通常会以以下方式来定义我们的Model：</p>

<pre><code>@interface GHIssue : MTLModel &lt;MTLJSONSerializing&gt;

@property (nonatomic, copy, readonly) NSURL *URL;
@property (nonatomic, copy, readonly) NSURL *HTMLURL;
@property (nonatomic, copy, readonly) NSNumber *number;
@property (nonatomic, assign, readonly) GHIssueState state;

...

@end
</code></pre>

<p>可以看到，我们的Model继承了通常是MTLModel类，同时实现了MTLJSONSerializing协议。这样，我们不再需要像上面那样写一大堆的赋值代码和编码解码方法，而只需要实现MTLJSONSerializing协议的+JSONKeyPathsByPropertyKey类方法，将我们的属性名的键值与JSON字典的键值做一个映射，我们便可以在MTLJSONAdapter对象的帮助下自动进行赋值操作和编码解码操作。我们来看看GHIssue类的具体实现：</p>

<pre><code>@implementation GHIssue

...

+ (NSDictionary *)JSONKeyPathsByPropertyKey {
    return @{
        @"URL": @"url",
        @"HTMLURL": @"html_url",
        @"reporterLogin": @"user.login",
        @"assignee": @"assignee",
        @"updatedAt": @"updated_at"
    };
}

...

@end
</code></pre>

<p>可以看到，Model对象的属性与JSON数据之间的映射是通过字典来实现的。通过这种对应关系，Model对象便可以和JSON数据相互转换。需要注意的是返回中字典中的key值在Model对象中必须有对应的属性，否则Model对象将无法初始化成功。</p>

<p>当然这两者的值之间的转换关系可能需要我们自己来定义，这时我们就可以在Model中自定义+(NSValueTransformer *)<key>JSONTransformer方法来完成这一操作，如下代码所示：</p>

<pre><code>@implementation GHIssue

...

+ (NSValueTransformer *)URLJSONTransformer {
    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];
}

+ (NSValueTransformer *)HTMLURLJSONTransformer {
    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];
}

+ (NSValueTransformer *)stateJSONTransformer {
    return [NSValueTransformer mtl_valueMappingTransformerWithDictionary:@{
        @"open": @(GHIssueStateOpen),
        @"closed": @(GHIssueStateClosed)
    }];
}

...

@end
</code></pre>

<p>这样，在转换过程中，会自动调用这些方法来做数据的转换。而如果没有实现相应的方法，则会调用默认的+JSONTransformerForKey:来做处理，具体的实现可以参考<a href="http://southpeak.github.io/blog/2015/01/11/yuan-ma-pian-:mantle/">《源码篇：Mantle》</a>。</p>

<p>有了上面这些准备工作，我们就需要通过MTLJSONAdapter类来适配MTLModel对象和JSON数据了，这个更容易了，代码如下所示：</p>

<pre><code>NSError *error = nil;

NSDictionary *JSONDictionary = ...;

GHIssue *issue = [MTLJSONAdapter modelOfClass:GHIssue.class fromJSONDictionary:JSONDictionary error:&amp;error];
</code></pre>

<p>这样就根据一个JSON字典创建了一个GHIssue对象，而如果要从这个对象中获取到相应的JSON字典，则可以如下操作：</p>

<pre><code>NSDictionary *JSONDictionary = [MTLJSONAdapter JSONDictionaryFromModel:issue];
</code></pre>

<p>以上便是Mantle的简单使用，当然更多的使用方式还需要在实践中多挖掘了。</p>

<p>这里还需要注意的是：</p>

<ol>
<li>MTLModel的转换只针对我们定义的属性，而无法支持成员变量。</li>
<li>支持嵌套属性的转换，这对于对象属性来说非常有用。</li>
</ol>


<h2>导入工程</h2>

<p>想在我们的工程中使用Mantle，可以通过以下步骤导入：</p>

<ol>
<li>将Mantle库作为应用的子模块添加进来。</li>
<li>运行Mantle文件夹下的script/bootstrap脚本。</li>
<li>将Mantle.xcodeproj拖进我们的XCode工程或工作空间。</li>
<li>在程序target的Build Phases选项卡中，在Link Binary With Libraries下添加Mantle的相关信息。在iOS工程中，添加libMantle.a库。</li>
<li>在&#8221;Header Search Paths&#8221;设置中添加&#8221;$(BUILD_ROOT)/../IntermediateBuildFilesPath/UninstalledProducts/include&#8221; $(inherited)。</li>
<li>对于iOS目标，在&#8221;Other Linker Flags&#8221;设置中添加-ObjC。</li>
<li>如果我们将Mantle添加到工程(而不是工作空间)，则我们需要将Mantle依赖的库添加到程序的&#8221;Target Dependencies&#8221;中。</li>
</ol>


<p>不过，我还是喜欢用CocoaPods来处理，只需要在Podfile中添加以下代码：</p>

<pre><code>pod 'Mantle', '~&gt; 1.5.3'
</code></pre>

<p>然后在对应目录下运行pod install，稍等片刻便可以使用Mantle了。关于CocoaPods的使用，可参考<a href="https://github.com/CocoaPods/CocoaPods">github上的cocoapods工程</a>。</p>

<h2>不足之处</h2>

<p>Mantle使用简单方便，极大的简化了我们的代码，可以满足我们大部分的需求。不过有时候我们可能会遇到这样的情况，由服务端提供的两个接口A和B，其实际上返回的数据可以转换为程序的同一个Model，只不过由于提供接口的是两个人，而且没有相互约定；抑或是服务端接口返回的数据与本地数据库的数据可以转换化同一个Model，但由于历史原因，这两者的字段也没对应上，如下所示：</p>

<pre><code>// A接口返回的JSON数据为
{"user": "abc", "password": "abc"}

// B接口返回的JSON数据为
{"user": "123", "pwd": "123"}
</code></pre>

<p>这种情况下如何使用Mantle呢？看着实际上都一样，只是字段名不一样。这时似乎就不好处理了。因为+JSONKeyPathsByPropertyKey中，字典的key表示的是MTLModel的属性键值，是通过属性的键值去找相应的JSON数据的key。因此，这种情况下可能就得定义两个Model了。</p>

<p>在我们之前的工程中，也有做过类似Mantle的处理，只不过没有做得这么细致。针对上面的问题，我们的方案是刚好反过来，这个映射字典的key是JSON字典的key值，而映射字典的value是对象属性的key值。这样，我们就可以将不回数据来源的JSON字典的不同key映射到同一个Model对象的同一个属性上了。</p>

<p>另外一方面，由于转换过程涉及到一些映射查找操作，所以性能上也不如直接写赋值语句来得快。不过Mantle已以通过缓存对此做了优化，所以这一点还是可以接受的。</p>

<h2>参考与推荐</h2>

<ol>
<li><a href="https://github.com/Mantle/Mantle">Mantle工程</a></li>
<li><a href="http://southpeak.github.io/blog/2015/01/11/yuan-ma-pian-:mantle/">源码篇：Mantle</a></li>
<li><a href="http://ourui.github.io/blog/2014/01/22/mantle-use/">Mantle 初步使用</a></li>
<li><a href="http://blog.codingcoder.com/use-mantle-to-model/">使用Mantle处理Model层对象</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quartz 2D编程指南之十三：PDF文档的创建、显示及转换]]></title>
    <link href="http://southpeak.github.io/blog/2015/01/08/quartz-2dbian-cheng-zhi-nan-zhi-shi-san-:pdfwen-dang-de-chuang-jian-,-xian-shi-ji-zhuan-huan/"/>
    <updated>2015-01-08T22:51:40+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/01/08/quartz-2dbian-cheng-zhi-nan-zhi-shi-san-:pdfwen-dang-de-chuang-jian-,-xian-shi-ji-zhuan-huan</id>
    <content type="html"><![CDATA[<p>PDF文档存储依赖于分辨率的向量图形、文本和位图，并用于程序的一系列指令中。一个PDF文档可以包含多页的图形和文本。PDF可用于创建跨平台、只读的文档，也可用于绘制依赖于分辨率的图形。</p>

<p>Quartz为所有应用程序创建高保真的PDF文档，这些文档保留应用的绘制操作，如图13-1所示。PDF文档的结果将通过系统的其它部分或第三方法的产品来有针对性地进行优化。Quartz创建的PDF文档在Preview和Acrobat中都能正确的显示。</p>

<p>Figure 13-1  Quartz creates high-quality PDF documents</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/postscript_to_PDF.gif" alt="image" /></p>

<p>Quartz不仅仅只使用PDF作为它的数字页，它同样包含一些API来显示和生成PDF文件，及完成一些其它PDF相关的工作。</p>

<h2>打开和查看PDF</h2>

<p>Quartz提供了CGPDFDocumentRef数据类型来表示PDF文档。我们可以使用CGPDFDocumentCreateWithProvider或CGPDFDocumentCreateWithURL来创建CGPDFDocument对象。在创建CGPDFDocument对象后，我们可以将其绘制到图形上下文中。图13-2显示了在一个窗体中绘制PDF文档。</p>

<p>Figure 13-2  A PDF document</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rooster_up.gif" alt="image" /></p>

<p>代码清单13-1显示了如何创建一个CGPDFDocument对象及获取文档的页数。</p>

<p>Listing 13-1  Creating a CGPDFDocument object from a PDF file</p>

<pre><code>CGPDFDocumentRef MyGetPDFDocumentRef (const char *filename)
{
    CFStringRef path;
    CFURLRef url;
    CGPDFDocumentRef document;
    size_t count;

    path = CFStringCreateWithCString (NULL, filename,
                         kCFStringEncodingUTF8);
    url = CFURLCreateWithFileSystemPath (NULL, path, 
                        kCFURLPOSIXPathStyle, 0);
    CFRelease (path);
    document = CGPDFDocumentCreateWithURL (url);
    CFRelease(url);
    count = CGPDFDocumentGetNumberOfPages (document);
    if (count == 0) {
        printf("`%s' needs at least one page!", filename);
        return NULL;
    }
    return document;
}
</code></pre>

<p>代码清单显示了如何将一个PDF页绘制到图形上下文中。</p>

<p>Listing 13-2  Drawing a PDF page</p>

<pre><code>void MyDisplayPDFPage (CGContextRef myContext,
                    size_t pageNumber,
                    const char *filename)
{
    CGPDFDocumentRef document;
    CGPDFPageRef page;

    document = MyGetPDFDocumentRef (filename);
    page = CGPDFDocumentGetPage (document, pageNumber);
    CGContextDrawPDFPage (myContext, page);
    CGPDFDocumentRelease (document);
}
</code></pre>

<h2>为PDF页创建一个转换</h2>

<p>Quartz提供了函数CGPDFPageGetDrawingTransform来创建一个仿射变换，该变换基于将PDF页的BOX映射到指定的矩形中。函数原型是：</p>

<pre><code>CGAffineTransform CGPDFPageGetDrawingTransform (
        CGPPageRef page,
        CGPDFBox box,
        CGRect rect,
        int rotate,
        bool preserveAspectRatio
);
</code></pre>

<p>该函数通过如下算法来返回一个仿射变换：</p>

<ol>
<li>将在box参数中指定的PDF box的类型相关的矩形(media, crop, bleed, trim, art)与指定的PDF页的/MediaBox入口求交集。相交的部分即为一个有效的矩形(effectiverectangle)。</li>
<li>将effective rectangle旋转参数/Rotate入口指定的角度。</li>
<li>将得到的矩形放到rect参数指定的中间。</li>
<li>如果rotate参数是一个非零且是90的倍数，函数将effective rectangel旋转该值指定的角度。正值往右旋转；负值往左旋转。需要注意的是我们传入的是角度，而不是弧度。记住PDF页的/Rotate入口也包含一个旋转，我们提供的rotate参数是与/Rotate入口接合在一起的。</li>
<li>如果需要，可以缩放矩形，从而与我们提供的矩形保持一致。</li>
<li>如果我们通过传递true值给preserveAspectRadio参数以指定保持长宽比，则最后的矩形将与rect参数的矩形的边一致。</li>
</ol>


<p>【注：上面这段翻译得不是很好】</p>

<p>例如，我们可以使用这个函数来创建一个与图13-3类似的PDF浏览程序。如果我们提供一个Rotate Left/Rotate Right属性，则可以调用CGPDFPageGetDrawingTransform来根据当前的窗体大小和旋转设置计算出适当的转换。</p>

<p>Figure 13-3  A PDF page rotated 90 degrees to the right</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rooster_rotate.gif" alt="image" /></p>

<p>程序清单13-3显示了为一个PDF页创建及应用仿射变换，然后绘制PDF。</p>

<p>Listing 13-3  Creating an affine transform for a PDF page</p>

<pre><code>void MyDrawPDFPageInRect (CGContextRef context,
                    CGPDFPageRef page,
                    CGPDFBox box,
                    CGRect rect,
                    int rotation,
                    bool preserveAspectRatio)
{
    CGAffineTransform m;

    m = CGPDFPageGetDrawingTransform (page, box, rect, rotation,
                                    preserveAspectRato);
    CGContextSaveGState (context);
    CGContextConcatCTM (context, m);
    CGContextClipToRect (context,CGPDFPageGetBoxRect (page, box));
    CGContextDrawPDFPage (context, page);
    CGContextRestoreGState (context);
}
</code></pre>

<h2>创建PDF文件</h2>

<p>使用Quartz创建PDF与绘制其它图形上下文一下简单。我们指定一个PDF文件地址，设置一个PDF图形上下文，并使用与其它图形上下文一样的绘制程序。如代码清单13-4所示的MyCreatePDFFile函数，显示了创建一个PDF的所有工作。</p>

<p>注意，代码在CGPDFContextBeginPage和CGPDFContextEndPage中来绘制PDF。我们可以传递一个CFDictionary对象来指定页属性，包括media, crop, bleed,trim和art boxes。</p>

<p>Listing 13-4  Creating a PDF file</p>

<pre><code>void MyCreatePDFFile (CGRect pageRect, const char *filename)
{
    CGContextRef pdfContext;
    CFStringRef path;
    CFURLRef url;
    CFDataRef boxData = NULL;
    CFMutableDictionaryRef myDictionary = NULL;
    CFMutableDictionaryRef pageDictionary = NULL;

    path = CFStringCreateWithCString (NULL, filename, 
                                kCFStringEncodingUTF8);
    url = CFURLCreateWithFileSystemPath (NULL, path, 
                     kCFURLPOSIXPathStyle, 0);
    CFRelease (path);
    myDictionary = CFDictionaryCreateMutable(NULL, 0,
                        &amp;kCFTypeDictionaryKeyCallBacks,
                        &amp;kCFTypeDictionaryValueCallBacks); 
    CFDictionarySetValue(myDictionary, kCGPDFContextTitle, CFSTR("My PDF File"));
    CFDictionarySetValue(myDictionary, kCGPDFContextCreator, CFSTR("My Name"));
    pdfContext = CGPDFContextCreateWithURL (url, &amp;pageRect, myDictionary); 
    CFRelease(myDictionary);
    CFRelease(url);
    pageDictionary = CFDictionaryCreateMutable(NULL, 0,
                        &amp;kCFTypeDictionaryKeyCallBacks,
                        &amp;kCFTypeDictionaryValueCallBacks); 
    boxData = CFDataCreate(NULL,(const UInt8 *)&amp;pageRect, sizeof (CGRect));
    CFDictionarySetValue(pageDictionary, kCGPDFContextMediaBox, boxData);
    CGPDFContextBeginPage (pdfContext, pageDictionary); 
    myDrawContent (pdfContext);
    CGPDFContextEndPage (pdfContext);
    CGContextRelease (pdfContext);
    CFRelease(pageDictionary); 
    CFRelease(boxData);
}
</code></pre>

<h2>添加链接</h2>

<p>我们可以在PDF上下文中添加链接和锚点。Quartz提供了三个函数，每个函数都以PDF图形上下文作为参数，还有链接的信息：</p>

<ol>
<li>CGPDFContextSetURLForRect可以让我们指定在点击当前PDF页中的矩形时打开一个URL。</li>
<li>CGPDFContextSetDestinationForRect指定在点击当前PDF页中的矩形区域时设置目标以进行跳转。我们需要提供一个目标名。</li>
<li>CGPDFContextAddDestinationAtPoint指定在点击当前PDF页中的一个点时设置目标以进行跳转。我们需要提供一个目标名。</li>
</ol>


<h2>保护PDF内容</h2>

<p>为了保护PDF内容，我们可以在辅助字典中指定一些安全选项并传递给CGPDFContextCreate。我们可以通过包含如下关键字来设置所有者密码、用户密码、PDF是否可以被打印或拷贝：</p>

<ol>
<li>kCGPDFContextOwnerPassword: 定义PDF文档的所有者密码。如果指定该值，则文档使用所有者密码来加密；否则文档不加密。该关键字的值必须是ASCII编码的CFString对象。只有前32位是用于密码的。该值没有默认值。如果该值不能表示成ASCII，则无法创建文档并返回NULL。Quartz使用40-bit加密。</li>
<li>kCGPDFContextUserPassword: 定义PDF文档的用户密码。如果文档加密了，则该值是文档的用户密码。如果没有指定，则用户密码为空。该关键字的值必须是ASCII编码的CFString对象。只有前32位是用于密码的。如果该值不能表示成ASCII，则无法创建文档并返回NULL。</li>
<li>kCGPDFContextAllowsPrinting:指定当使用用户密码锁定时文档是否可以打印。该值必须是CFBoolean对象。默认值是kCGBooleanTrue。</li>
<li>kCGPDFContextAllowsCopying: 指定当使用用户密码锁定时文档是否可以拷贝。该值必须是CFBoolean对象。默认值是kCGBooleanTrue。</li>
</ol>


<p>代码清单14-4(下一章)显示了确认PDF文档是否被锁定，及用密码打开文档。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quartz 2D编程指南之十二：Core Graphics层绘制]]></title>
    <link href="http://southpeak.github.io/blog/2015/01/08/quartz-2dbian-cheng-zhi-nan-zhi-shi-er-:core-graphicsceng-hui-zhi/"/>
    <updated>2015-01-08T22:47:51+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/01/08/quartz-2dbian-cheng-zhi-nan-zhi-shi-er-:core-graphicsceng-hui-zhi</id>
    <content type="html"><![CDATA[<p>CGLayer对象(CGLayerRef数据类型)允许程序使用层来进行绘制。</p>

<p>层适合于以下几种情况：</p>

<ol>
<li>高质量离屏渲染，以绘制我们想重用的图形。例如，我们可能要建立一个场景并重用相同的背景。将背景场景绘制于一个层上，然后在需要的时候再绘制层。一个额外的好处是我们不需要知道颜色空间或其它设备依赖的信息来绘制层。</li>
<li>重复绘制。例如，我们可能想创建一个由相同元素反复绘制而组成的模式。将元素绘制到一个层中，然后重复绘制这个层，如图12-1所示。任何我们重复绘制的Quartz对象，包括CGPath, CGShading和CGPDFPage对象，都可以通过将其绘制到CGLayer来优化性能。注意一个层不仅仅是用于离屏绘制；我们也可以将其用于那些不是面向屏幕的图形上下文，如PDF图形上下文。</li>
<li>缓存。虽然我们可以将层用于此目的，但通常不需要这样做，因为Quartz Compositor已经做了此事。如果我们必须绘制一个缓存，则使用层来代替位图图形上下文。</li>
</ol>


<p>Figure 12-1  Repeatedly painting the same butterfly image</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/stamp_layers.gif" alt="image" /></p>

<p>CGLayer对象和透明层是与CGPath对象以及CGContext函数创建的路径并行的。对于一个CGLayer或者CGPath对象，我们可以将其绘制到一个抽象目标，之后可以将其完整地绘制到另一个目标，如显示器或才PDF中。当我们在透明层上绘制或者使用绘制路径的CGContext函数时，可以直接绘制到图形上下文表示的目标上，而不需要负责组装绘制的中间抽象目标。</p>

<h2>层如何工作</h2>

<p>一个层由CGLayerRef数据类型表示，是为优化性能而设计的。在可能的时候，Quartz使用合适的机制将一个CGLayer对象缓存到与之相关的Quartz图形上下文中。例如，与显卡相关的图形上下文可能将层缓存到显卡中，这样绘制在层中的内容时，就比渲染从一个位图图形上下文中构造的类似图像要快得多。基于这个原因，层比位图图形上下文更适用于离屏绘制。</p>

<p>所有的Quartz绘制函数都是绘制到图形上下文中。图形上下文提供了一个抽象的渲染目标，而将我们从目标的细节中解放出来。我们使用用户空间，Quartz执行必要的转换来将绘图正确地渲染到目标。当我们使用CGLayer对象来绘制时，我们也是绘制到图形上下文中。图12-1演示了层绘制的必要步骤。</p>

<p>Figure 12-2  Layer drawing</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/layer_context.gif" alt="image" /></p>

<p>所有在图形上下文中层的绘制都是以使用函数CGLayerCreateWithContext创建一个CGLayer对象开始的。用于创建CGLayer对象的图形上下文通常是一个window图形上下文。Quartz创建一个层，使得它具有图形上下文的所有特性：包括分辨率，颜色空间和图形状态设置。如果我们不想使用图形上下文的大小，则可以提供一个大小给层。在图12-2中，左侧显示了用于创建层的图形上下文。框右侧的灰色部分，即标记为CGLayer对象的部分表示新创建的层。</p>

<p>在我们可以绘制层之前，我们必须通过调用CGLayerGetContext函数来获取与层相关的图形上下文。这个图形上下文与用于创建层的图形上下文是差不多的。只要用于创建层的图形上下文是一个window图形上下文，则CGLayer图形上下文会尽可能地被缓存到GPU中。图12-2中位于框右侧的白色部分表示新创建的层图形上下文。</p>

<p>在层图形上下文中绘制与在其它图形上下文中绘制一样，将层图形上下文作为参数传给绘制函数。图12-2显示了一片绘制到层图形上下文的叶子。</p>

<p>当我们准备使用层的内容时，我们可以调用函数CGContextDrawLayerInRect或者CGContextDrawLayerAtPoint将层绘制到一个图形上下文。通常情况下，我们会将层绘制到创建层对象的图形上下文中，但这不是必须的。我们可以将层绘制到任意的图形上下文，记住：层带有创建层对象的图形上下文的所有特性，这可能会产生一些限制(如性能或分辨率)。例如，与屏幕关联的层可能会被缓存到显卡中。如果目标上下文是一个打印机或PDF上下文，则可能需要将层对象从显卡中取出并放到内存中，从而导致性能很差。</p>

<p>图12-2显示了层的内容&mdash;叶子&mdash;被重复地绘制到创建层对象的图形上下文中。我们可以在释放CGLayer对象之前，任意地重复使用层中的绘图。</p>

<h2>使用层来绘制</h2>

<p>我们需要按照如下几个步骤来使用层对象进行绘制：</p>

<ol>
<li>创建一个使用已存在的图形上下文初始化的层对象</li>
<li>为层获取图形上下文</li>
<li>绘制到CGLayer图形上下文</li>
<li>将层绘制到目标图形上下文</li>
</ol>


<p>我们将在下面详细描述这几个步骤。</p>

<h3>创建一个使用已存在的图形上下文初始化的层对象</h3>

<p>函数CGLayerCreateWithContext返回一个使用已存在的图形上下文初始化的层对象。这个层对象继承了该图形上下文的所有特性，包括颜色空间、大小、分辨率和像素格式。后期当我们绘制层对象到一个目标时，Quartz会自动对层与目标上下文进行颜色匹配。</p>

<p>函数CGLayerCreateWithContext带有三个参数：</p>

<ol>
<li>用于创建层的图形上下文。通常我们传递一个window图形上下文以便后面可以离屏绘制层。</li>
<li>层相对于图形上下文的大小。层的大小可以和图形上下文一样，或者更小。如果想要获得层的大小，我们可以调用函数CGLayerGetSize。</li>
<li>一个辅助字典。这个参数现在已经不用了，所以传递NULL即可。</li>
</ol>


<h3>为层获取图形上下文</h3>

<p>Quartz总是在一个图形上下文中进行绘制。现在我们有了一个层对象，我们必须创建一个与层相关的图形上下文。所有绘制到层图形上下文的内容都是层的一部分。</p>

<p>函数CGLayerGetContext获取一个层对象作为参数，并返回与之相关的图形上下文。</p>

<h3>绘制到CGLayer图形上下文</h3>

<p>在获取到与层相关的图形上下文之后，我们可以在层图形上下文中绘制任何东西。我们可以打开一个PDF文件或一个图像文件，并将文件内容绘制到层中。我们可以使用Quartz 2D的任何函数来绘制矩形、直线或其它绘制单元。图12-3显示了在层中绘制一个矩形和直线。</p>

<p>Figure 12-3  A layer that contains two rectangles and a series of lines</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rect_star_layer.gif" alt="image" /></p>

<p>例如，为了在CGLayer图形上下文中绘制一个填充矩形，我们调用函数CGContextFillRect，并提供从CGLayerGetContext函数中获取到的图形上下文作为参数。假设这个图形上下文命名为myLayerContext，则函数调用如下：</p>

<pre><code>CGContextFillRect (myLayerContext, myRect)
</code></pre>

<h3>将层绘制到目标图形上下文</h3>

<p>当我们已经准备好将层绘制到目标图形上下文时，我们可以使用以下任一一个函数：</p>

<ol>
<li>CGContextDrawLayerInRect：将层绘制到图形上下文中指定的矩形内。</li>
<li>CGContextDrawLayerAtPoint：将层绘制到图形上下文中指定的点。</li>
</ol>


<p>通常情况下，我们提供的目标图形上下文是一个window图形上下文，这也是我们用于创建层对象所使用的图形上下文。图12-4显示了重复绘制图12-3所绘制的层。为了达到模式效果，我们可以使用上面两个方法中的任意一个，只是每次改变偏移量而已。例如，我们每次绘制层时，可以调用函数CGContextTranslateCTM来改变坐标系统的原点。</p>

<p>Figure 12-4  Drawing a layer repeatedly</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rect_star_pattern.gif" alt="image" /></p>

<pre><code>注意：我们不必要将层绘制到初始层所使用的图形上下文中。然而，如果我们将层绘制到其它图形上下文中，原始图形上下文的所有限制都会反映到我们的绘图中。
</code></pre>

<h2>例子：使用多个CGLayer对象来绘制旗子</h2>

<p>这一节演示了如何使用CGLayer对象来在屏幕上绘制图12-5中的旗子。首先我们会看到如何将旗子分解成简单的绘制单元，然后会看到要完成这些任务的代码。</p>

<p>Figure 12-5  The result of using layers to draw the United States flag</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/us_flag.gif" alt="image" /></p>

<p>从上面可以看出，旗子主要分三部分：</p>

<ol>
<li>红色条纹和白色条纹的模式。我们可以将这个模式分解为一个单一的红色条纹，因为对于屏幕绘制来说，我们可以假设其背景颜色为白色。我们创建一个红色矩形，然后以变化的偏移量来重复绘制这个矩形，以创建美国国旗上的七条红色条纹。我们将红色矩形绘制到一个层，然后将其绘制到屏幕上七次。</li>
<li>一个蓝色矩形。我们只需要一个蓝色矩形，所以没有必要使用层。当绘制蓝色矩形时，直接将其绘制到屏幕上。</li>
<li>50个白色星星的模式。与红色条纹一下，可以使用层来绘制星星。我们创建星星边框的一个路径，然后使用白条来填充。将一个星星绘制到层，然后重复50次绘制这个层，每次绘制时适当调整偏移量。</li>
</ol>


<p>代码清单12-2完成了对图12-5的绘制。myDrawFlag例程在一个Cocoa程序中调用。这个程序传递一个window图形上下文和一个与图形上下文相关的视图的大小。</p>

<p>Listing 12-1  Code that uses layers to draw a flag</p>

<pre><code>void myDrawFlag (CGContextRef context, CGRect* contextRect)
{
    int          i, j,
                 num_six_star_rows = 5,
                 num_five_star_rows = 4;
    CGFloat      start_x = 5.0,
                 start_y = 108.0,
                 red_stripe_spacing = 34.0,
                 h_spacing = 26.0,
                 v_spacing = 22.0;
    CGContextRef myLayerContext1,
                 myLayerContext2;
    CGLayerRef   stripeLayer,
                 starLayer;
    CGRect       myBoundingBox,
                 stripeRect,
                 starField;
 // ***** Setting up the primitives *****
    CGPoint point1 = {5, 5}, point2 = {10, 15}, point3 = {10, 15}, point4 = {15, 5};
    CGPoint point5 = {15, 5}, point6 = {2.5, 11}, point7 = {2.5, 11}, point8 = {16.5, 11};
    CGPoint point9 = {16.5, 11}, point10 = {5, 5};
    const CGPoint myStarPoints[] = {point1, point2,
                                    point3, point4,
                                    point5, point6,
                                    point7, point8,
                                    point9, point10};

    stripeRect  = CGRectMake (0, 0, 400, 17); // stripe
    starField  =  CGRectMake (0, 102, 160, 119); // star field

    myBoundingBox = CGRectMake (0, 0, contextRect-&gt;size.width, 
                                      contextRect-&gt;size.height);

     // ***** Creating layers and drawing to them *****
    stripeLayer = CGLayerCreateWithContext (context, 
                            stripeRect.size, NULL);
    myLayerContext1 = CGLayerGetContext (stripeLayer);

    CGContextSetRGBFillColor (myLayerContext1, 1, 0 , 0, 1);
    CGContextFillRect (myLayerContext1, stripeRect);

    starLayer = CGLayerCreateWithContext (context,
                            starField.size, NULL);
    myLayerContext2 = CGLayerGetContext (starLayer);
    CGContextSetRGBFillColor (myLayerContext2, 1.0, 1.0, 1.0, 1);
    CGContextAddLines (myLayerContext2, myStarPoints, 10);
    CGContextFillPath (myLayerContext2);    

     // ***** Drawing to the window graphics context *****
    CGContextSaveGState(context);    
    for (i=0; i&lt; 7;  i++)   
    {
        CGContextDrawLayerAtPoint (context, CGPointZero, stripeLayer);
        CGContextTranslateCTM (context, 0.0, red_stripe_spacing);
    }
    CGContextRestoreGState(context);

    CGContextSetRGBFillColor (context, 0, 0, 0.329, 1.0);
    CGContextFillRect (context, starField);

    CGContextSaveGState (context);              
    CGContextTranslateCTM (context, start_x, start_y);      
    for (j=0; j&lt; num_six_star_rows;  j++)   
    {
        for (i=0; i&lt; 6;  i++)
        {
            CGContextDrawLayerAtPoint (context,CGPointZero,
                                            starLayer);
            CGContextTranslateCTM (context, h_spacing, 0);
        }
        CGContextTranslateCTM (context, (-i*h_spacing), v_spacing); 
    }
    CGContextRestoreGState(context);

    CGContextSaveGState(context);
    CGContextTranslateCTM (context, start_x + h_spacing/2, 
                                 start_y + v_spacing/2);
    for (j=0; j&lt; num_five_star_rows;  j++) 
    {
        for (i=0; i&lt; 5;  i++)
        {
        CGContextDrawLayerAtPoint (context, CGPointZero,
                            starLayer);
            CGContextTranslateCTM (context, h_spacing, 0);
        }
        CGContextTranslateCTM (context, (-i*h_spacing), v_spacing);
    }
    CGContextRestoreGState(context);

    CGLayerRelease(stripeLayer);
    CGLayerRelease(starLayer);        
}
</code></pre>

<p>在此不再翻译对代码的注释，请各位看官查看文档原文<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_layers/dq_layers.html#//apple_ref/doc/uid/TP30001066-CH219-TPXREF101">Core Graphics Layer Drawing</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quartz 2D编程指南之十一：位图与图像遮罩]]></title>
    <link href="http://southpeak.github.io/blog/2015/01/05/quartz-2dbian-cheng-zhi-nan-zhi-shi-%5B%3F%5D-:wei-tu-yu-tu-xiang-zhe-zhao/"/>
    <updated>2015-01-05T23:10:23+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/01/05/quartz-2dbian-cheng-zhi-nan-zhi-shi-[?]-:wei-tu-yu-tu-xiang-zhe-zhao</id>
    <content type="html"><![CDATA[<p>位图与图像遮罩和Quartz中的其它绘制元素一样。这两者在Quartz中都是用CGImageRef数据类型来表示。正如在本章后面看到的一样，我们有一系列的方法来创建一个图像。其中一些需要数据提供者或图像源来提供位图数据。另外一些函数则通过拷贝图像或在图像上应用操作来从已存在的图像中创建图像。不管我们是以何种方式来创建图像，我们都可以将图像绘制到任何类型的图形上下文。记住，位图是在指定分辨率下的一个字节数组。如果我们将位图绘制到一个依赖于分辨率的图形上下文中(如PDF图形上下文)，则位图受限于创建它的图形上下文的分辨率。</p>

<p>我们可以通过调用CGImageMaskCreate函数来创建一个Quartz图像遮罩。我们将在“创建图像遮罩”一节中看到如何创建遮罩。使用图像遮罩不是绘制遮罩的唯一方法，具体的我们都会在下面看到。</p>

<h2>位图和图像遮罩</h2>

<p>一个位图是一个像素数组。每一个像素表示图像中的一个点。JPEG, TIFF和PNG图像文件都是位图。应用程序的icon也是位图。位图被限定在一个矩形内。但是通过使用alpha分量，它们可以呈现不同的形式，也可以旋转或被裁剪，如图11-1所示：</p>

<p>Figure 11-1  Bitmap images</p>

<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/images.gif" alt="image" /></p>

<p>位图中的每一个采样包含特定颜色空间下的一个或更多颜色分量，以及一个额外的用于指定alpha值以表示透明度的分量。每一个分量可以是从1-32位。在Mac OS X中，Quartz支持浮点值分量。在Mac OS X和iOS中支持的格式将会在下文中介绍。ColorSync提供了位图支持的颜色空间。</p>

<p>Quartz同样支持图像遮罩(image masks)。一个图像遮罩也是一个位图，它指定了一个绘制区域，而不是颜色。从效果上来说，一个图像遮罩更像一个模块，它指定在page中绘制颜色的位置。Quartz使用当前的填充颜色来绘制一个图像遮罩。一个颜色遮罩可以有1-8位的深度。</p>

<h2>位图信息</h2>

<p>Quartz提供了很多图像格式并内建了多种常用的格式。在iOS中，这些格式包括JPEG, GIF, PNG, TIF, ICO, GMP, XBM, 和CUR。其它的位图格式或专有格式需要我们指定图像格式的详细信息，以便Quartz能正确地解析图像。我们提供给CGImageCreate函数的图像数据必须是以像素为单位的，而不是基于扫描线的。Quartz不支持平面数据。</p>

<p>这一节描述了与位图相关的信息。当我们创建并使用Quartz图像时(使用CGImageRef数据类型)，我们将看到一些Quartz图像创建函数需要我们指定所有的信息，而其它函数只需要部分信息。我们所需要提供的信息依赖于位图数据的编码，以及位图是表示一个图像还是图像遮罩。</p>

<pre><code>注意：当使用原始图像数据时，为了获得更好的性能，我们可以使用vImage框架。我们可以使用vImageBuffer_InitWithCGImage函数从一个CGImageRef引用导入图像数据到vImage中。
</code></pre>

<p>创建一个位图(CGImageRef)时，Quartz使用以下信息：</p>

<ol>
<li>位图数据源：可以是一个Quartz数据提供者或者是一个Quartz图像源。</li>
<li>可选的解码数组。(Decode Array)</li>
<li>插值设置：这是一个布尔值，指定Quartz在重置图像大小时是否使用插值算法。</li>
<li>渲染意图：指定如何映射位于图形上下文中的目标颜色空间中的颜色。该值在图像遮罩中不需要。</li>
<li>图像尺寸</li>
<li>像素格式，包括每个分量中的位数，每个像素的位数和每行中的字节数。</li>
<li>对于图像来说，颜色空间和位图布局信息描述了alpha的位置和位置是否使用浮点值。图像遮罩不需要这个信息。</li>
</ol>


<h3>解码数组</h3>

<p>一个解码数组将图像颜色值映射到其它颜色值，这对于诸如对一个图像做去饱和或者反转颜色值非常有用。数组包含每个颜色分量的一个数值对。当Quartz渲染图像时，它利用一个线性转换将原始分量值映射到一个目标颜色空间中的指定范围内一个相关值。例如，在RGB颜色空间中的一个图像的解码数组包含6个输入，分别用于红、绿、蓝颜色分量。</p>

<h3>像素格式</h3>

<p>像素格式包含以下信息：</p>

<ol>
<li>每个分量的位数，即在一个像素中每个独立颜色分量的位数。对于一个图像遮罩，这个值是源像素中遮罩bit的数目。例如，如果源图片是8-bit的遮罩，则指定每个分量是8位。</li>
<li>每个像素的位数，即一个源像素所占的总的位数。这个值必须至少是每个分量的位数乘以每个像素中分量的数目。</li>
<li>每行的字节数，即图像中水平行的字节数。</li>
</ol>


<h3>颜色空间和位图布局</h3>

<p>为了确保Quartz能正确的解析每个像素的位，我们必须指定：</p>

<ol>
<li>一个位图是否包含alpha通道。Quartz包含RGB,CMYK和灰度颜色空间。它也支持alpha，或者透明度，虽然并不是所有位图图像格式都支持alpha通道。当它可用时，alpha分量可以位于像素最显著的位置，也可以是最不显著的位置。</li>
<li>对于有alpha分量的位图，指定颜色分量是否已经乘以了alpha值。预乘alpha(Premultiplied alpha)表示一个已将颜色分量乘以了alpha值的源颜色。这种预处理通过消除每个颜色分量的额外的乘法运算来加速图片的渲染。</li>
<li>采样的数据格式&mdash;是整型还是浮点型。</li>
</ol>


<p>当我们使用CGImageCreate函数来创建一个图像时，我们提供一个类型为CGImageBitmapInfo的bitmapInfo参数，来指定位置布局信息。以下的常量指定了alpha分量的位置及颜色分量是否做预处理：</p>

<ol>
<li>kCGImageAlphaLast：alpha分量存储在每个像素中最不显著的位置，如RGBA。</li>
<li>kCGImageAlphaFirst：alpha分量存储在每个像素中最显著的位置，如ARGB。</li>
<li>kCGImageAlphaPremultipliedLast：alpha分量存储在每个像素中最不显著的位置，但颜色分量已经乘以了alpha值。</li>
<li>kCGImageAlphaPremultipliedFirst：alpha分量存储在每个像素中最显著的位置，同时颜色分量已经乘以了alpha值。</li>
<li>kCGImageAlphaNoneSkipLast：没有alpha分量。如果像素的总大小大于颜色空间中颜色分量数目所需要的空间，则最不显著位置的位将被忽略。</li>
<li>kCGImageAlphaNoneSkipFirst：没有alpha分量。如果像素的总大小大于颜色空间中颜色分量数目所需要的空间，则最显著位置的位将被忽略。</li>
<li>kCGImageAlphaNone：等于kCGImageAlphaNoneSkipLast。</li>
</ol>


<p>我们使用常量kCGBitmapFloatComponents来标识一个位图格式使用浮点值。对于浮点格式，我们将这个常量与上而描述的合适的常量进行逻辑OR操作。例如，对于每个像素有128位的使用预处理的浮点格式，同时alpha值位于像素中最不显示位置，我们将以下信息提供给Quartz：</p>

<pre><code>kCGImageAlphaPremultipliedLast | kCGBitmapFloatComponents
</code></pre>

<p>图11-2演示了一个像素在使用16-或32-bit整型像素格式的CMYK和RGB颜色空间中如何表示。32-bit整型像素格式中，每个分量占8位。16-bit整型像素格式中每个分量占5位。Quartz同样支持128-bit浮点像素格式，每个分量占32位。128-bit格式没有显示在下图中。</p>

<p>Figure 11-2  32-bit and 16-bit pixel formats for CMYK and RGB color spaces in Quartz 2D</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/colorformatrgba32.gif" alt="image" /></p>

<h2>创建图像</h2>

<p>表11-1罗列了Quartz提供的用于创建CGImageRef对象的函数。函数的选择依赖于图像的数据源。最常用的函数是CGImageCreate。它可以从任何类型的位图数据来创建一个图像。然而，它是最复杂的函数，因为需要提供所有的位图信息。为了使用这个函数，我们需要熟悉上面讨论的位图图像信息的内容。</p>

<p>如果我们想从一个标准的图像格式，如PNG或JPEG，来创建一个CGImage对象，则最简单的方法是调用函数CGImageSourceCreateWithURL来创建一个图像源，然后调用CGImageSourceCreateImageAtIndex以使用从图像源中索引index指定的图像数据来创建一个图像。如果源图像文件只包含一个图像，则索引为0。如果图像文件格式支持包含多个图像的文件，则需要提供所需要图像的索引值，记住起始值是0。</p>

<p>如果我们已经将内容渲染到一个位图图形上下文，并想要从中获取到CGImage对象，则调用CGBitmapContextCreateImage函数。</p>

<p>有几个函数可以操作已有的图像，如拷贝、创建一个缩略图，或从一个大图像中创建一个图像。不管如何创建一个图像对象，我们都使用函数CGContextDrawImage将图像绘制到一个图形上下文中。记住CGImage是不可变的。当不再需要一个CGImage对象时，调用CGImageRelease函数来释放它。</p>

<p><img src="http://a3.qpic.cn/psb?/V130i6W71atwfr/W9ZJHCPpoB6QElZy*ePoumPixMBNcMaHrVryzqP12b0!/b/dBmKcHUpFAAA&amp;bo=pAaAAgAAAAADBwI!&amp;rf=viewer_4" alt="image" /></p>

<p>接下来将讨论如何创建：</p>

<ol>
<li>从一个已存在图像中创建一个子图像</li>
<li>从一个图像图形上下文中创建一个图像</li>
</ol>


<h3>从一个大图片中创建一个图像</h3>

<p>我们可以使用CGImageCreateWithImageInRect函数从一个大图像中创建一个图像。图11-3演示了这一情形。</p>

<p>Figure 11-3  A subimage created from a larger image</p>

<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/subimage.gif" alt="image" /></p>

<p>函数CGImageCreateWithImageInRect返回的图像保留了源图像的一个引用，这意味着我们在调用完这个函数后可以释放源图像。</p>

<p>图11-4是另外一个例子。在这种情况下，公鸡的头部被从大图中提取出来，然后绘制到一个大于子图像的矩形中。</p>

<p>代码清单11-1显示了创建并绘制子图像的过程。CGContextDrawImage函数绘制公鸡头部的矩形区域是所提取的子图像的四倍大小。清单中的只是一个代码片断。我们需要声明合适的变量，创建公鸡头像，并部署公鸡图像及公鸡头部子图像。因为只是代码片断，所以没有演示如何创建一个图形上下文。我们可以使用任何我们所喜欢的图形上下文。创建图形上下文的例子可以查看“图形上下文”一章。</p>

<p>Figure 11-4  An image, a subimage taken from it and drawn so it’s enlarged</p>

<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/rooster_image_zoom.gif" alt="image" /></p>

<p>Listing 11-1  Code that creates a subimage and draws it enlarged</p>

<pre><code>myImageArea = CGRectMake (rooster_head_x_origin, rooster_head_y_origin,
                            myWidth, myHeight);
mySubimage = CGImageCreateWithImageInRect (myRoosterImage, myImageArea);
myRect = CGRectMake(0, 0, myWidth*2, myHeight*2);
CGContextDrawImage(context, myRect, mySubimage);
</code></pre>

<h3>从一个位图图形上下文创建一个图像</h3>

<p>为了从一个已存在的位图图形上下文创建一个图像，我们可以调用函数CGBitmapContextCreateImage，如以下：</p>

<pre><code>CGImageRef myImage;
myImage = CGBitmapContextCreateImage (myBitmapContext);
</code></pre>

<p>这个函数返回的CGImage对象是通过一个拷贝操作创建的。因此我们对位图图形上下文所做的修改都不会影响到已返回的CGImage对象。在一些情况下，这个拷贝操作实际上沿用了copy-on-write语义，即只有当位图图形上下文中的数据被修改时才会去实际拷贝这些数据。我们可能需要在绘制额外数据到位图图形上下文之前使用结果数据或者释放它们，以便我们可以避免实际去拷贝这些数据。</p>

<p>如何创建一个位图图形上下文，可以参考&#8221;创建图形上下文&#8221;相关的内容。</p>

<h2>创建一个图像遮罩</h2>

<p>一个Quartz位图图像遮罩如同艺术家使用丝网印刷品(silkscreen)一样。一个位图图像遮罩定义了如何转换颜色，而不是使用哪些颜色。图像遮罩中的每个采样值指定了在特定位置中，当前填充颜色值被遮罩的数量。采样值指定了遮罩的不透明度。值越大，表示越不透明，Quartz在指定位置绘制的颜色越少。我们可以将采样值当成alpha值的反转。1表示透明的，而0表示不透明。</p>

<p>图像遮罩的每个分量可能是1，2，4或者8位。对于1-bit的遮罩，采样值1指定遮罩的区域掩盖了当前的填充颜色。值为0表示当绘制遮罩时，显示当前的填充颜色。我们可以将1-bit遮罩当成黑色和白色；要么完全遮挡，要么完全显示。</p>

<p>每个分量中有2，4，8位的图像遮罩代表灰度值。每个分量使用以下的公式将值映射到[0, 1]之间的值：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/inline_equations.jpg" alt="image" /></p>

<p>例如，一个4-bit的遮罩其值位于[0, 1]之间，且增长的步长为1/15。0和1这两个值分别是最小和最大值&mdash;分别表示完全遮盖或完全透明。0和1之间的值使用(1-MaskSampleValue)这个公式来处理局部绘制。例如，如果一个8-bit遮罩的采样值设置为0.7，则那些alpha值为(1-0.7)，即0.3的颜色将会被绘制。</p>

<p>函数CGImageMaskCreate从我们提供的位图图像信息中创建一个Quartz图像遮罩。我们提供的信息与创建图像所提供的信息是一样的，只是不需要提供颜色空间信息，位图信息常量或渲染意图，我们可以从代码清单11-2中看到这个函数原型：</p>

<p>Listing 11-2  The prototype for the function CGImageMaskCreate</p>

<pre><code>CGImageRef CGImageMaskCreate (
        size_t width,
        size_t height,
        size_t bitsPerComponent,
        size_t bitsPerPixel,
        size_t bytesPerRow,
        CGDataProviderRef provider,
        const CGFloat decode[],
        bool shouldInterpolate
);
</code></pre>

<h2>遮罩图像</h2>

<p>遮罩技术可以让我们通过控制图片的哪一部分被绘制，以生成很多有趣的效果，我们可以：</p>

<ol>
<li>在一个图像上使用图像遮罩。我们也可以把一个图像作为遮罩图，以获取同使用图像遮罩相反的效果。</li>
<li>使用颜色来遮罩图像的一部分，其中包含被称为颜色遮罩的技术</li>
<li>将图形上下文剪切到一个图像或图像遮罩，当Quartz绘制内容到剪切的图形上下文时来遮罩一个图像。</li>
</ol>


<h3>使用一个图像遮罩来遮罩图像</h3>

<p>函数CGImageCreateWithMask通过将图像遮罩使用到一个图像上的方式来创建一个图像。这个函数带有两个参数：</p>

<ol>
<li>原始图像，遮罩将用于其上。这个图像不能是图像遮罩，也不能有与之相关的遮罩颜色。</li>
<li>一个图像遮罩，通过调用CGImageMaskCreate函数创建的。也可以提供一个图像来替代图像遮罩，但这将给出非常不同的结果。这将在下面描述。</li>
</ol>


<p>一个图像遮罩的采样如同一个反转的alpha值。一个图像遮罩采样值(S)：</p>

<ol>
<li>为1时，则不会绘制对应的图像样本。</li>
<li>为0时，则允许完全绘制对应的图像样本。</li>
<li>0和1之间的值，则让对应的图像样本的alpha的值为(1-S)。</li>
</ol>


<p>图11-5显示了一个由Quartz图像创建函数创建的图像，而图11-6显示了一个使用CGImageMaskCreate函数创建的图像遮罩。图11-7则显示了一个使用CGImageCreateWithMask函数将图像遮罩应用于一个图像的效果。</p>

<p>Figure 11-5  The original image</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/two_tigers.gif" alt="image" /></p>

<p>Figure 11-6  An image mask</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/two_tiger_mask.gif" alt="image" /></p>

<p>注意，源图像中与遮罩黑色区域对应的区域绘制出来，而与白色区域对应的部分则没有绘制出来。而与遮罩灰色区域对应的区域则使用一个与(1-图像遮罩采样值)相同的alpha值来绘制。</p>

<p>Figure 11-7  The image that results from applying the image mask to the original image</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/image_create_w_mask.gif" alt="image" /></p>

<h3>使用一个图像来遮罩一个图像</h3>

<p>我们可以使用函数CGImageCreateWithMask来用一个图像遮罩另一个图像，而不是使用一个图像遮罩。我们可以使用这种方式来达到与使用图像遮罩相反的效果。那此时我们传递给CGImageCreateWithMask函数的就不是一个图像遮罩了，而是传递一个通过Quartz图像创建函数创建的图像。</p>

<p>用于遮罩的图像的采样也是操作alpha值。一个图像采样值(S)：</p>

<ol>
<li>为1时，则允许完全绘制对应的图像样本。</li>
<li>为0时，则不会绘制对应的图像样本。</li>
<li>0和1之间的值，则让对应的图像样本的alpha的值为S。</li>
</ol>


<p>图11-8显示了调用CGImageCreateWithMask函数将图11-6中的图像作为遮罩应用于图11-5中的图像上的效果。在这个例子中，我们假定图11-6中的图像是使用Quartz图像创建函数(如CGImageCreate)创建的。比较图11-8与图11-7，可以看出使用图像采样时，可以获取与使用图像遮罩采样相反的效果。</p>

<p>在图11-8的结果图像中，源图像中与图像的黑色区域对应的区域没有绘制出来。与白色区域对应的区域则绘制出来了。在遮罩中与灰色区域对应的区域则使用与遮罩图像采样值相同的alpha值来绘制。</p>

<p>Figure 11-8  The image that results from masking the original image with an image</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/image_mask_image.gif" alt="image" /></p>

<h3>使用颜色来遮罩图像</h3>

<p>函数CGImageCreateWithMaskingColors通过遮罩一种颜色或一个颜色范围内的颜色来创建一个图像。使用这个函数，我们可以执行如图11-9所示的颜色遮罩，当然也可以遮罩一个范围内的颜色，如图11-11、11-12和11-13所示的效果。</p>

<p>函数CGImageCreateWithMaskingColors有两个参数：</p>

<ol>
<li>一个图像，它不能是遮罩图像，也不能是使用过图像遮罩或颜色遮罩的图像。</li>
<li>一个颜色分量数组，指定了一个颜色或一组颜色值，以用于遮罩图像。</li>
</ol>


<p>Figure 11-9  Chroma key masking</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/chroma_key.gif" alt="image" /></p>

<p>颜色分量数组中元素的个数必须等于图像所在颜色空间的颜色分量数目的两倍。对于颜色空间中的每一个颜色分量，提供一个最小值和一个最大值来限定遮罩颜色的范围。如果只使用一个颜色，则设置最大值等于最小值即可。颜色分量数组中的值按以下顺序来提供：</p>

<pre><code>{min[1], max[1], ... min[N], max[N]}，其中N是分量的数目
</code></pre>

<p>如果图像使用整型像素分量，则颜色分量数组中的每个值必须在[0 .. 2<sup>bitsPerComponent</sup> &ndash; 1]范围之内。如果图像使用浮点像素分量，则值可以是表示任何有效的颜色分量值的浮点数。</p>

<p>一个图像采样如果其颜色值在以下范围内，则不会被绘制：</p>

<pre><code>{c[1], ... c[N]}，其中min[i] &lt;= c[i] &lt;= max[i] for 1 &lt;= i &lt;= N
</code></pre>

<p>图11-10中两只老虎的图像使用了每个分量有8位的RGB颜色空间。为了在这个图像上屏蔽一组颜色，我们提供一组在[0, 255]区间内的最小和最大颜色分量值。</p>

<p>Figure 11-10  The original image</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/two_tigers1.gif" alt="image" /></p>

<p>代码清单11-3演示了如何设置颜色分量数组，并将其提供给CGImageCreateWithMaskingColors函数以达到图11-11的效果。</p>

<p>Listing 11-3  Masking light to mid-range brown colors in an image</p>

<pre><code>CGImageRef myColorMaskedImage;
const CGFloat myMaskingColors[6] = {124, 255,  68, 222, 0, 165};
myColorMaskedImage = CGImageCreateWithMaskingColors (image,
                                        myMaskingColors);
CGContextDrawImage (context, myContextRect, myColorMaskedImage);
</code></pre>

<p>Figure 11-11  An image with light to midrange brown colors masked out</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/beige_brown_masking.gif" alt="image" /></p>

<p>代码清单11-14同样操作图11-10并得到图11-12的效果。这个例子遮罩了一组暗色。</p>

<p>Listing 11-4  Masking shades of brown to black</p>

<pre><code>CGImageRef myMaskedImage;
const CGFloat myMaskingColors[6] = { 0, 124, 0, 68, 0, 0 };
myColorMaskedImage = CGImageCreateWithMaskingColors (image,
                                        myMaskingColors);
CGContextDrawImage (context, myContextRect, myColorMaskedImage);
</code></pre>

<p>Figure 11-12  A image after masking colors from dark brown to black</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/brown_black_masking_colors.gif" alt="image" /></p>

<p>我们同样可以设置一个填充颜色来作为图像的遮罩颜色，以达到图11-13的效果，其中被遮罩区域使用了填充颜色。代码清单11-15演示了这一过程</p>

<p>Listing 11-5  Masking a range of colors and setting a fill color and</p>

<pre><code>CGImageRef myMaskedImage;
const CGFloat myMaskingColors[6] = { 0, 124, 0, 68, 0, 0 };
myColorMaskedImage = CGImageCreateWithMaskingColors (image,
                                        myMaskingColors);
CGContextSetRGBFillColor (myContext, 0.6373,0.6373, 0, 1);
CGContextFillRect(context, rect);
CGContextDrawImage(context, rect, myColorMaskedImage);
</code></pre>

<p>Figure 11-13  An image drawn after masking a range of colors and setting a fill color</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/fill_color_with_mask.gif" alt="image" /></p>

<h3>通过裁减上下文来遮罩一个图片</h3>

<p>函数CGContextClipToMask将遮罩映射为一个矩形并将其与图形上下文的当前裁减区域求个交集。我们提供以下参数：</p>

<ol>
<li>需要裁减的图形上下文</li>
<li>要使用遮罩的矩形区域</li>
<li>一个图像遮罩，其通过CGImageMaskCreate函数创建。我们可以使用图像来替代图像遮罩以达到相反的效果。但图像必须使用Quartz图像创建函数来创建，但不能是使用过图像遮罩或颜色遮罩的图像。</li>
</ol>


<p>裁减区域的结果依赖于是否提供了一个图像遮罩或图像给CGContextClipToMask函数。</p>

<p>我们看看图11-14.假设它是通过调用CGImageMaskCreate函数创建的一个图像遮罩，然后将其作为CGContextClipToMask函数的参数。结果上下文允许绘制黑色区域，而不绘制白色区域，并使用(1-S)的alpha值来绘制灰色区域，其中S是图像遮罩的采样值。如果使用CGContextDrawImage函数来将一个图像绘制到裁减上下文，则可以获得图11-15所示的结果。</p>

<p>Figure 11-14  A masking image</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/the_mask.gif" alt="image" /></p>

<p>Figure 11-15  An image drawn to a context after clipping the content with an image mask</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/mask_as_mask.gif" alt="image" /></p>

<p>当遮罩图像被当成一个图像时，可以获得相反的结果，如图11-16所示：</p>

<p>Figure 11-16  An image drawn to a context after clipping the content with an image</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/inverse_mask_clip.gif" alt="image" /></p>

<h2>在图像中使用混合模式</h2>

<p>此处略，类似于在颜色中使用混合模式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quartz 2D编程指南之十：Quartz 2D中的数据管理]]></title>
    <link href="http://southpeak.github.io/blog/2014/12/11/quartz-2dbian-cheng-zhi-nan-zhi-shi-:quartz-2dzhong-de-shu-ju-guan-li/"/>
    <updated>2014-12-11T09:19:08+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/12/11/quartz-2dbian-cheng-zhi-nan-zhi-shi-:quartz-2dzhong-de-shu-ju-guan-li</id>
    <content type="html"><![CDATA[<p>管理数据是每一个图形应用程序所需要处理的工作。对于Quartz来说，数据管理涉及为Quartz 2D程序提供数据，及从中获取数据。一些Quartz 2D程序将数据传输到Quartz中，如从文件或程序其它部分获取图片或PDF数据。另一些程序则获取Quartz数据，如将图像或PDF数据写入到文件，或提供给程序其它部分这些数据。</p>

<p>Quartz提供了一系列的函数来管理数据。通过学习本章，我们可以了解到哪些函数是最适合我们的程序的。</p>

<pre><code>注：我们推荐使用图像I/O框架来读取和写入数据，该框架在iOS 4、Mac OS X 10.4或者更高版本中可用。查看《Image I/OProgramming Guide 》可以获取更多关于CGImageSourceRef和CGImageDestinationRef的信息。图像源和目标不仅提供了访问图像数据的方法，不提供了更多访问图像原数据的方法。
</code></pre>

<p>Quartz可识别三种类型的数据源和目标：</p>

<ol>
<li>URL：通过URL指定的数据可以作为数据的提供者和接收者。我们使用Core Foundation数据类型CFURLRef作为参数传递给Quartz函数。</li>
<li>CFData：Core Foundation数据类型CFDataRef和CFMutableDataRef可简化Core Foundation对象的内存分配行为。CFData是一个”toll-freebridged”类，CocoaFoundation中对应的类是NSData；如果在Quartz 2D中使用Cocoa框架，你可以传递一个NSData对象给Quartz方法，以取代CFData对象。</li>
<li>原始数据：我们可以提供一个指向任何类型数据的指针，连同处理这些数据基本内存管理的回调函数集合。</li>
</ol>


<p>这些数据，无论是URL、CFData对象，还是数据缓存，都可以是图像数据或PDF数据。图像数据可以是任何格式的数据。Quartz能够解析大部分常用的图像文件格式。一些Quartz数据管理函数专门用于处理图像数据，一些只处理PDF数据，还有一些可同时处理PDF和图像数据。</p>

<p>URL，CFData和原始数据源和目标中的数据都是在Mac OS X 或者iOS图像领域范围之外的，如图10-1所示。Mac OS X或iOS的其它图像技术通常会提供它们自己的方式来和Quartz通信。例如，一个Mac OS X 应用程序可以传输一个Quartz图像给Core Image，并使用Core Image来实现更复杂的效果。</p>

<p>Figure 10-1  Moving data to and from Quartz 2D in Mac OS X</p>

<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/movingdata.gif" alt="image" /></p>

<h2>传输数据给Quartz 2D</h2>

<p>表10-1列出了从数据源获取数据的方法。所有的这些函数，除了CGPDFDocumentCreateWithURL，都返回一个图像源(CGImageSourceRef)或者数据提供者(CGDataProviderRef)。图像源和数据提供者抽象了数据访问工作，并避免了程序去管理原始内存缓存。</p>

<p>图像源是将图像数据传输给Quartz的首先方式。图像源可表示很多种图像数据。一个图像源可表示多于一个图像，也可表示缩略图、图像的属性和图像文件。当我们拥有CGImageSourceRef对象后，我们可以完成如下工作：</p>

<ol>
<li>使用函数CGImageSourceCreateImageAtIndex,CGImageSourceCreateThumbnailAtIndex, CGImageSourceCreateIncremental创建图像(CGImageRef). 一个CGImageRef数据类型表示一个单独的Quartz图像。</li>
<li>通过函数CGImageSourceUpdateData或CGImageSourceUpdateDataProvider来添加内容到图像源中。</li>
<li>使用函数CGImageSourceGetCount, CGImageSourceCopyProperties和CGImageSourceCopyTypeIdentifiers获取图像源的信息。</li>
</ol>


<p>CFPDFDocumentCreateWithURL函数可以方便地从URL指定的文件创建PDF文档。</p>

<p>数据提供者是比较老的机制，它有很多限制。它们可用于获取图像或PDF数据。</p>

<p>我们可以将数据提供者用于：</p>

<ol>
<li>一个图像创建函数，如CGImageCreate,CGImageCreateWithPNGDataProvider或者CGImageCreateWithJPEGDataProvider。</li>
<li>PDF文档的创建函数CGPDFDocumentCreateWithProvider.</li>
<li>函数CGImageSourceUpdateDataProvider用于更新已存在的图像源。</li>
</ol>


<p>关于图像的更多信息，可查看“Bitmap Images andImage Masks”。</p>

<p><img src="http://cc.cocimg.com/bbs/attachment/thumb/Fid_6/6_38018_23d72ec7c568bf5.png" alt="image" /></p>

<h2>获取Quartz 2D的数据</h2>

<p>表10-2列出地从Quartz 2D中获取数据的方法。所有这些方法，除了CGPDFContextCreateWithURL，都返回一个图像目标(CGImageDestinationRef)或者是数据消费者(CGDataComsumerRef)。图像目标和数据消费者抽象的数据写入工作，让Quartz来处理细节。</p>

<p>一个图像目标是获取Quartz数据的首先方法。与图像源一样，图像目标也可以表示很多图像数据，如一个单独图片、多个图片、缩略图、图像属性或者图片文件。在获取到CGImageDestinationRef后，我们可以完成以下工作：</p>

<ol>
<li>使用函数CGImageDestinationAddImage或者CGImageDestinationAddImageFromSource添加一个图像(CGImageRef)到目标中。一个CGImageRef表示一个图片。</li>
<li>使用函数CGImageDestinationSetProperties设置属性</li>
<li>使用函数CGImageDestinationCopyTypeIdentifiers和CGImageDestinationGetTypeID从图像目标中获取信息。</li>
</ol>


<p>函数CGPDFContextCreateWithURL可以方便地将PDF数据写入URL指定的位置。</p>

<p>数据消费者是一种老的机制，有很多限制。它们用于写图像或PDF数据。我们可以将数据消费者用于：</p>

<ol>
<li>PDF上下文创建函数CGPDFContextCreate。该函数返回一个图形上下文，用于记录一系列的PDF绘制命令。</li>
<li>函数CGImageDestinationCreateWithDataConsumer，用于从数据消费者中创建图像目标。</li>
</ol>


<p>关于图像的更多信息，可查看“Bitmap Images andImage Masks”。</p>

<p><img src="http://cc.cocimg.com/bbs/attachment/thumb/Fid_6/6_38018_ad38140dfa05446.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quartz 2D编程指南之九：透明层]]></title>
    <link href="http://southpeak.github.io/blog/2014/12/10/quartz-2dbian-cheng-zhi-nan-zhi-jiu-:tou-ming-ceng/"/>
    <updated>2014-12-10T09:13:04+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/12/10/quartz-2dbian-cheng-zhi-nan-zhi-jiu-:tou-ming-ceng</id>
    <content type="html"><![CDATA[<p>透明层(TransparencyLayers)通过组合两个或多个对象来生成一个组合图形。组合图形被看成是单一对象。当需要在一组对象上使用特效时，透明层非常有用，如图9-1所示的给三个圆使用阴影的效果。</p>

<p>Figure 9-1  Three circles as a composite in a transparency layer</p>

<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/trans_layer1.gif" alt="image" /></p>

<p>如果没有使用透明层来渲染图9-1中的三个圆，对它们使用阴影的效果将是如图9-2所示：</p>

<p>Figure 9-2  Three circles painted as separate entities</p>

<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/trans_layer2.gif" alt="image" /></p>

<h2>透明层的工作方式</h2>

<p>Quartz的透明层类似于许多流行的图形应用中的层。层是独立的实体。Quartz维护为每个上下文维护一个透明层栈，并且透明层是可以嵌套的。但由于层通常是栈的一部分，所以我们不能单独操作它们。</p>

<p>我们通过调用函数CGContextBeginTransparencyLayer来开始一个透明层，该函数需要两个参数：图形上下文与CFDictionary对象。字典中包含我们所提供的指定层额外信息的选项，但由于Quartz 2D API中没有使用字典，所以我们传递一个NULL。在调用这个函数后，图形状态参数保持不变，除了alpha值[默认设置为1]、阴影[默认关闭]、混合模式[默认设置为normal]、及其它影响最终组合的参数。</p>

<p>在开始透明层操作后，我们可以绘制任何想显示在层上的对象。指定上下文中的绘制操作将被当成一个组合对象绘制到一个透明背景上。这个背景被当作一个独立于图形上下文的目标缓存。</p>

<p>当绘制完成后，我们调用函数CGContextEndTransparencyLayer。Quartz将结合对象放入上下文，并使用上下文的全局alpha值、阴影状态及裁减区域作用于组合对象。</p>

<h2>在透明层中进行绘制</h2>

<p>在透明层中绘制需要三步：</p>

<ol>
<li>调用函数CGContextBeginTransparencyLayer</li>
<li>在透明层中绘制需要组合的对象</li>
<li>调用函数CGContextEndTransparencyLayer</li>
</ol>


<p>图9-3显示了在透明层中绘制三个矩形，其中将这三个矩形当成一个整体来渲染阴影。</p>

<p>Figure 9-3  Three rectangles painted to a transparency layer</p>

<p><img src="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/trans_code.gif" alt="image" /></p>

<p>代码清单9-1显示了如何利用透明层生成图9-3所示的矩形。</p>

<p>Listing 9-1  Painting to a transparency layer</p>

<pre><code>void MyDrawTransparencyLayer (CGContext myContext, float wd,float ht)
{
    CGSize myShadowOffset = CGSizeMake (10, -20);
    CGContextSetShadow (myContext, myShadowOffset, 10);   
    CGContextBeginTransparencyLayer (myContext, NULL);

    // Your drawing code here
    CGContextSetRGBFillColor (myContext, 0, 1, 0, 1);
    CGContextFillRect (myContext, CGRectMake (wd/3+ 50,ht/2 ,wd/4,ht/4));
    CGContextSetRGBFillColor (myContext, 0, 0, 1, 1);
    CGContextFillRect (myContext, CGRectMake (wd/3-50,ht/2-100,wd/4,ht/4));
    CGContextSetRGBFillColor (myContext, 1, 0, 0, 1);
    CGContextFillRect (myContext, CGRectMake (wd/3,ht/2-50,wd/4,ht/4));
    CGContextEndTransparencyLayer (myContext);
}
</code></pre>
]]></content>
  </entry>
  
</feed>
