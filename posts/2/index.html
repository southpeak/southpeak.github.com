
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>南峰子的技术博客</title>
  <meta name="author" content="南峰子">
      
  <meta name="baidu-site-verification" content="HoscFhWICI" />

  
  <meta name="description" content="我们的App与用户进行交互，基本上是依赖于各种各样的事件。例如，用户点击界面上的按钮，我们需要触发一个按钮点击事件，并进行相应的处理，以给用户一个响应。UIView的三大职责之一就是处理事件，一个视图是一个事件响应者，可以处理点击等事件，而这些事件就是在UIResponder类中定义的。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://southpeak.github.io/posts/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="南峰子的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <!-- googleapis is fucked by gfw -->
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">南峰子的技术博客</a></h1>
  
    <h2>攀登，一步一个脚印，方能知其乐</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:southpeak.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/categories/ios">iOS开发</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/07/uiresponder/">UIResponder</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-07T18:54:23+08:00" pubdate data-updated="true">Mar 7<sup>th</sup>, 2015</time>
        
        
           | <a href="/blog/2015/03/07/uiresponder/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我们的App与用户进行交互，基本上是依赖于各种各样的事件。例如，用户点击界面上的按钮，我们需要触发一个按钮点击事件，并进行相应的处理，以给用户一个响应。UIView的三大职责之一就是处理事件，一个视图是一个事件响应者，可以处理点击等事件，而这些事件就是在UIResponder类中定义的。</p>

<p>一个UIResponder类为那些需要响应并处理事件的对象定义了一组接口。这些事件主要分为两类：触摸事件(touch events)和运动事件(motion events)。UIResponder类为每两类事件都定义了一组接口，这个我们将在下面详细描述。</p>

<p>在UIKit中，UIApplication、UIView、UIViewController这几个类都是直接继承自UIResponder类。另外SpriteKit中的SKNode也是继承自UIResponder类。因此UIKit中的视图、控件、视图控制器，以及我们自定义的视图及视图控制器都有响应事件的能力。这些对象通常被称为响应对象，或者是响应者(以下我们统一使用响应者)。</p>

<p>本文将详细介绍一个UIResponder类提供的基本功能。不过在此之前，我们先来了解一下事件响应链机制。</p>

<h2>响应链</h2>

<p>大多数事件的分发都是依赖响应链的。响应链是由一系列链接在一起的响应者组成的。一般情况下，一条响应链开始于第一响应者，结束于application对象。如果一个响应者不能处理事件，则会将事件沿着响应链传到下一响应者。</p>

<p>那这里就会有三个问题：</p>

<ol>
<li>响应链是何时构建的</li>
<li>系统是如何确定第一响应者的</li>
<li>确定第一响应者后，系统又是按照什么样的顺序来传递事件的</li>
</ol>


<h3>构建响应链</h3>

<p>我们都知道在一个App中，所有视图是按一定的结构组织起来的，即树状层次结构。除了根视图外，每个视图都有一个父视图；而每个视图都可以有0个或多个子视图。而在这个树状结构构建的同时，也构建了一条条的事件响应链。</p>

<h3>确定第一响应者</h3>

<p>当用户触发某一事件(触摸事件或运动事件)后，UIKit会创建一个事件对象(UIEvent)，该对象包含一些处理事件所需要的信息。然后事件对象被放到一个事件队列中。这些事件按照先进先出的顺序来处理。当处理事件时，程序的UIApplication对象会从队列头部取出一个事件对象，将其分发出去。通常首先是将事件分发给程序的主window对象，对于触摸事件来讲，window对象会首先尝试将事件分发给触摸事件发生的那个视图上。这一视图通常被称为hit-test视图，而查找这一视图的过程就叫做hit-testing。</p>

<p>系统使用hit-testing来找到触摸下的视图，它检测一个触摸事件是否发生在相应视图对象的边界之内(即视图的frame属性，这也是为什么子视图如果在父视图的frame之外时，是无法响应事件的)。如果在，则会递归检测其所有的子视图。包含触摸点的视图层次架构中最底层的视图就是hit-test视图。在检测出hit-test视图后，系统就将事件发送给这个视图来进行处理。</p>

<p>我们通过一个示例来演示hit-testing的过程。图1是一个视图层次结构，</p>

<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png" alt="image" /></p>

<p>假设用户点击了视图E，系统按照以下顺序来查找hit-test视图：</p>

<ol>
<li>点击事件发生在视图A的边界内，所以检测子视图B和C；</li>
<li>点击事件不在视图B的边界内，但在视图C的边界范围内，所以检测子图片D和E；</li>
<li>点击事件不在视图D的边界内，但在视图E的边界范围内；</li>
</ol>


<p>视图E是包含触摸点的视图层次架构中最底层的视图(倒树结构)，所以它就是hit-test视图。</p>

<p>hit-test视图可以最先去处理触摸事件，如果hit-test视图不能处理事件，则事件会沿着响应链往上传递，直到找到能处理它的视图。</p>

<h3>事件传递</h3>

<p>最有机会处理事件的对象是hit-test视图或第一响应者。如果这两者都不能处理事件，UIKit就会将事件传递到响应链中的下一个响应者。每一个响应者确定其是否要处理事件或者是通过nextResponder方法将其传递给下一个响应者。这一过程一直持续到找到能处理事件的响应者对象或者最终没有找到响应者。</p>

<p>图2演示了这样一个事件传递的流程，</p>

<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png" alt="image" /></p>

<p>当系统检测到一个事件时，将其传递给初始对象，这个对象通常是一个视图。然后，会按以下路径来处理事件(我们以左图为例)：</p>

<ol>
<li>初始视图(initial view)尝试处理事件。如果它不能处理事件，则将事件传递给其父视图。</li>
<li>初始视图的父视图(superview)尝试处理事件。如果这个父视图还不能处理事件，则继续将视图传递给上层视图。</li>
<li>上层视图(topmost view)会尝试处理事件。如果这个上层视图还是不能处理事件，则将事件传递给视图所在的视图控制器。</li>
<li>视图控制器会尝试处理事件。如果这个视图控制器不能处理事件，则将事件传递给窗口(window)对象。</li>
<li>窗口(window)对象尝试处理事件。如果不能处理，则将事件传递给单例app对象。</li>
<li>如果app对象不能处理事件，则丢弃这个事件。</li>
</ol>


<p>从上面可以看到，视图、视图控制器、窗口对象和app对象都能处理事件。另外需要注意的是，手势也会影响到事件的传递。</p>

<p>以上便是响应链的一些基本知识。有了这些知识，我们便可以来看看UIResponder提供给我们的一些方法了。</p>

<h2>管理响应链</h2>

<p>UIResponder提供了几个方法来管理响应链，包括让响应对象成为第一响应者、放弃第一响应者、检测是否是第一响应者以及传递事件到下一响应者的方法，我们分别来介绍一下。</p>

<p>上面提到在响应链中负责传递事件的方法是nextResponder，其声明如下：</p>

<pre><code>- (UIResponder *)nextResponder
</code></pre>

<p>UIResponder类并不自动保存或设置下一个响应者，该方法的默认实现是返回nil。子类的实现必须重写这个方法来设置下一响应者。UIView的实现是返回管理它的UIViewController对象(如果它有)或者其父视图。而UIViewController的实现是返回它的视图的父视图；UIWindow的实现是返回app对象；而UIApplication的实现是返回nil。所以，响应链是在构建视图层次结构时生成的。</p>

<p>一个响应对象可以成为第一响应者，也可以放弃第一响应者。为此，UIResponder提供了一系列方法，我们分别来介绍一下。</p>

<p>如果想判定一个响应对象是否是第一响应者，则可以使用以下方法：</p>

<pre><code>- (BOOL)isFirstResponder
</code></pre>

<p>如果我们希望将一个响应对象作为第一响应者，则可以使用以下方法：</p>

<pre><code>- (BOOL)becomeFirstResponder
</code></pre>

<p>如果对象成为第一响应者，则返回YES；否则返回NO。默认实现是返回YES。子类可以重写这个方法来更新状态，或者来执行一些其它的行为。</p>

<p>一个响应对象只有在当前响应者能放弃第一响应者状态(canResignFirstResponder)且自身能成为第一响应者(canBecomeFirstResponder)时才会成为第一响应者。</p>

<p>这个方法相信大家用得比较多，特别是在希望UITextField获取焦点时。另外需要注意的是只有当视图是视图层次结构的一部分时才调用这个方法。如果视图的window属性不为空时，视图才在一个视图层次结构中；如果该属性为nil，则视图不在任何层次结构中。</p>

<p>上面提到一个响应对象成为第一响应者的一个前提是它可以成为第一响应者，我们可以使用canBecomeFirstResponder方法来检测，</p>

<pre><code>- (BOOL)canBecomeFirstResponder
</code></pre>

<p>需要注意的是我们不能向一个不在视图层次结构中的视图发送这个消息，其结果是未定义的。</p>

<p>与上面两个方法相对应的是响应者放弃第一响应者的方法，其定义如下：</p>

<pre><code>- (BOOL)resignFirstResponder
- (BOOL)canResignFirstResponder
</code></pre>

<p>resignFirstResponder默认也是返回YES。需要注意的是，如果子类要重写这个方法，则在我们的代码中必须调用super的实现。</p>

<p>canResignFirstResponder默认也是返回YES。不过有些情况下可能需要返回NO，如一个输入框在输入过程中可能需要让这个方法返回NO，以确保在编辑过程中能始终保证是第一响应者。</p>

<h2>管理输入视图</h2>

<p>所谓的输入视图，是指当对象为第一响应者时，显示另外一个视图用来处理当前对象的信息输入，如UITextView和UITextField两个对象，在其成为第一响应者是，会显示一个系统键盘，用来输入信息。这个系统键盘就是输入视图。输入视图有两种，一个是inputView，另一个是inputAccessoryView。这两者如图3所示：</p>

<p><img src="http://images.cnblogs.com/cnblogs_com/kuku/b.jpg" alt="image" /></p>

<p>与inputView相关的属性有如下两个，</p>

<pre><code>@property(nonatomic, readonly, retain) UIView *inputView
@property(nonatomic, readonly, retain) UIInputViewController *inputViewController
</code></pre>

<p>这两个属性提供一个视图(或视图控制器)用于替代为UITextField和UITextView弹出的系统键盘。我们可以在子类中将这两个属性重新定义为读写属性来设置这个属性。如果我们需要自己写一个键盘的，如为输入框定义一个用于输入身份证的键盘(只包含0-9和X)，则可以使用这两个属性来获取这个键盘。</p>

<p>与inputView类似，inputAccessoryView也有两个相关的属性：</p>

<pre><code>@property(nonatomic, readonly, retain) UIView *inputAccessoryView
@property(nonatomic, readonly, retain) UIInputViewController *inputAccessoryViewController
</code></pre>

<p>设置方法与前面相同，都是在子类中重新定义为可读写属性，以设置这个属性。</p>

<p>另外，UIResponder还提供了以下方法，在对象是第一响应者时更新输入和访问视图，</p>

<pre><code>- (void)reloadInputViews
</code></pre>

<p>调用这个方法时，视图会立即被替换，即不会有动画之类的过渡。如果当前对象不是第一响应者，则该方法是无效的。</p>

<h2>响应触摸事件</h2>

<p>UIResponder提供了如下四个大家都非常熟悉的方法来响应触摸事件：</p>

<pre><code>// 当一个或多个手指触摸到一个视图或窗口
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
// 当与事件相关的一个或多个手指在视图或窗口上移动时
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
// 当一个或多个手指从视图或窗口上抬起时
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
// 当一个系统事件取消一个触摸事件时
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event
</code></pre>

<p>这四个方法默认都是什么都不做。不过，UIKit中UIResponder的子类，尤其是UIView，这几个方法的实现都会把消息传递到响应链上。因此，为了不阻断响应链，我们的子类在重写时需要调用父类的相应方法；而不要将消息直接发送给下一响应者。</p>

<p>默认情况下，多点触摸是被禁用的。为了接受多点触摸事件，我们需要设置响应视图的multipleTouchEnabled属性为YES。</p>

<h2>响应移动事件</h2>

<p>与触摸事件类似，UIResponder也提供了几个方法来响应移动事件：</p>

<pre><code>// 移动事件开始
- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event
// 移动事件结束
- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event
// 取消移动事件
- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event
</code></pre>

<p>与触摸事件不同的是，运动事件只有开始与结束操作；它不会报告类似于晃动这样的事件。这几个方法的默认操作也是什么都不做。不过，UIKit中UIResponder的子类，尤其是UIView，这几个方法的实现都会把消息传递到响应链上。</p>

<h2>响应远程控制事件</h2>

<p>远程控制事件来源于一些外部的配件，如耳机等。用户可以通过耳机来控制视频或音频的播放。接收响应者对象需要检查事件的子类型来确定命令(如播放，子类型为UIEventSubtypeRemoteControlPlay)，然后进行相应处理。</p>

<p>为了响应远程控制事件，UIResponder提供了以下方法，</p>

<pre><code>- (void)remoteControlReceivedWithEvent:(UIEvent *)event
</code></pre>

<p>我们可以在子类中实现该方法，来处理远程控制事件。不过，为了允许分发远程控制事件，我们必须调用UIApplication的beginReceivingRemoteControlEvents方法；而如果要关闭远程控制事件的分发，则调用endReceivingRemoteControlEvents方法。</p>

<h2>获取Undo管理器</h2>

<p>默认情况下，程序的每一个window都有一个undo管理器，它是一个用于管理undo和redo操作的共享对象。然而，响应链上的任何对象的类都可以有自定义undo管理器。例如，UITextField的实例的自定义管理器在文件输入框放弃第一响应者状态时会被清理掉。当需要一个undo管理器时，请求会沿着响应链传递，然后UIWindow对象会返回一个可用的实例。</p>

<p>UIResponder提供了一个只读方法来获取响应链中共享的undo管理器，</p>

<pre><code>@property(nonatomic, readonly) NSUndoManager *undoManager
</code></pre>

<p>我们可以在自己的视图控制器中添加undo管理器来执行其对应的视图的undo和redo操作。</p>

<h2>验证命令</h2>

<p>在我们的应用中，经常会处理各种菜单命令，如文本输入框的&#8221;复制&#8221;、&#8221;粘贴&#8221;等。UIResponder为此提供了两个方法来支持此类操作。首先使用以下方法可以启动或禁用指定的命令：</p>

<pre><code>- (BOOL)canPerformAction:(SEL)action withSender:(id)sender
</code></pre>

<p>该方法默认返回YES，我们的类可以通过某种途径处理这个命令，包括类本身或者其下一个响应者。子类可以重写这个方法来开启菜单命令。例如，如果我们希望菜单支持&#8221;Copy&#8221;而不支持&#8221;Paser&#8221;，则在我们的子类中实现该方法。需要注意的是，即使在子类中禁用某个命令，在响应链上的其它响应者也可能会处理这些命令。</p>

<p>另外，我们可以使用以下方法来获取可以响应某一行为的接收者：</p>

<pre><code>- (id)targetForAction:(SEL)action withSender:(id)sender
</code></pre>

<p>在对象需要调用一个action操作时调用该方法。默认的实现是调用canPerformAction:withSender:方法来确定对象是否可以调用action操作。如果可以，则返回对象本身，否则将请求传递到响应链上。如果我们想要重写目标的选择方式，则应该重写这个方法。下面这段代码演示了一个文本输入域禁用拷贝/粘贴操作：</p>

<pre><code>- (id)targetForAction:(SEL)action withSender:(id)sender
{
    UIMenuController *menuController = [UIMenuController sharedMenuController];
    if (action == @selector(selectAll:) || action == @selector(paste:) ||action == @selector(copy:) || action == @selector(cut:)) {
        if (menuController) {
            [UIMenuController sharedMenuController].menuVisible = NO;
        }
        return nil;
    }
    return [super targetForAction:action withSender:sender];
}
</code></pre>

<h2>访问快捷键命令</h2>

<p>我们的应用可以支持外部设备，包括外部键盘。在使用外部键盘时，使用快捷键可以大大提高我们的输入效率。因此从iOS7后，UIResponder类新增了一个只读属性keyCommands，来定义一个响应者支持的快捷键，其声明如下：</p>

<pre><code>@property(nonatomic, readonly) NSArray *keyCommands
</code></pre>

<p>一个支持硬件键盘命令的响应者对象可以重新定义这个方法并使用它来返回一个其所支持快捷键对象(UIKeyCommand)的数组。每一个快捷键命令表示识别的键盘序列及响应者的操作方法。</p>

<p>我们用这个方法返回的快捷键命令数组被用于整个响应链。当与快捷键命令对象匹配的快捷键被按下时，UIKit会沿着响应链查找实现了响应行为方法的对象。它调用找到的第一个对象的方法并停止事件的处理。</p>

<h2>管理文本输入模式</h2>

<p>文本输入模式标识当响应者激活时的语言及显示的键盘。UIResponder为此定义了一个属性来返回响应者对象的文本输入模式：</p>

<pre><code>@property(nonatomic, readonly, retain) UITextInputMode *textInputMode
</code></pre>

<p>对于响应者而言，系统通常显示一个基于用户语言设置的键盘。我们可以重新定义这个属性，并让它返回一个不同的文本输入模式，以让我们的响应者使用一个特定的键盘。用户在响应者被激活时仍然可以改变键盘，在切换到另一个响应者时，可以再恢复到指定的键盘。</p>

<p>如果我们想让UIKit来跟踪这个响应者的文本输入模式，我们可以通过textInputContextIdentifier属性来设置一个标识，该属性的声明如下：</p>

<pre><code>@property(nonatomic, readonly, retain) NSString *textInputContextIdentifier
</code></pre>

<p>该标识指明响应者应保留文本输入模式的信息。在跟踪模式下，任何对文本输入模式的修改都会记录下来，当响应者激活时再用于恢复处理。</p>

<p>为了从程序的user default中清理输入模式信息，UIResponder定义了一个类方法，其声明如下：</p>

<pre><code>+ (void)clearTextInputContextIdentifier:(NSString *)identifier
</code></pre>

<p>调用这个方法可以从程序的user default中移除与指定标识相关的所有文本输入模式。移除这些信息会让响应者重新使用默认的文本输入模式。</p>

<h2>支持User Activities</h2>

<p>从iOS 8起，苹果为我们提供了一个非常棒的功能，即Handoff。使用这一功能，我们可以在一部iOS设备的某个应用上开始做一件事，然后在另一台iOS设备上继续做这件事。Handoff的基本思想是用户在一个应用里所做的任何操作都可以看作是一个Activity，一个Activity可以和一个特定iCloud用户的多台设备关联起来。在编写一个支持Handoff的应用时，会有以下三个交互事件：</p>

<ol>
<li>为将在另一台设备上继续做的事创建一个新的User Activity；</li>
<li>当需要时，用新的数据更新已有的User Activity；</li>
<li>把一个User Activity传递到另一台设备上。</li>
</ol>


<p>为了支持这些交互事件，在iOS 8后，UIResponder类新增了几个方法，我们在此不讨论这几个方法的实际使用，想了解更多的话，可以参考<a href="http://www.cocoachina.com/ios/20150115/10926.html">iOS 8 Handoff 开发指南</a>。我们在此只是简单描述一下这几个方法。</p>

<p>在UIResponder中，已经为我们提供了一个userActivity属性，它是一个NSUserActivity对象。因此我们在UIResponder的子类中不需要再去声明一个userActivity属性，直接使用它就行。其声明如下：</p>

<pre><code>@property(nonatomic, retain) NSUserActivity *userActivity
</code></pre>

<p>由UIKit管理的User Activities会在适当的时间自动保存。一般情况下，我们可以重写UIResponder类的updateUserActivityState:方法来延迟添加表示User Activity的状态数据。当我们不再需要一个User Activity时，我们可以设置userActivity属性为nil。任何由UIKit管理的NSUserActivity对象，如果它没有相关的响应者，则会自动失效。</p>

<p>另外，多个响应者可以共享一个NSUserActivity实例。</p>

<p>上面提到的updateUserActivityState:是用于更新给定的User Activity的状态。其定义如下：</p>

<pre><code>- (void)updateUserActivityState:(NSUserActivity *)activity
</code></pre>

<p>子类可以重写这个方法来按照我们的需要更新给定的User Activity。我们需要使用NSUserActivity对象的addUserInfoEntriesFromDictionary:方法来添加表示用户Activity的状态。</p>

<p>在我们修改了User Activity的状态后，如果想将其恢复到某个状态，则可以使用以下方法：</p>

<pre><code>- (void)restoreUserActivityState:(NSUserActivity *)activity
</code></pre>

<p>子类可以重写这个方法来使用给定User Activity的恢复响应者的状态。系统会在接收到数据时，将数据传递给application:continueUserActivity:restorationHandler:以做处理。我们重写时应该使用存储在user activity的userInfo字典中的状态数据来恢复对象。当然，我们也可以直接调用这个方法。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class">UIResponder Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html">Event Handling Guide for iOS</a></li>
<li><a href="http://www.cnblogs.com/kuku/archive/2011/11/12/2246389.html">iOS UIResponder 学习笔记</a></li>
<li><a href="http://firestudio.cn/blog/2013/12/26/ru-he-rang-ni-de-ios7ying-yong-zhi-chi-jian-pan-kuai-jie-jian/">如何让你的iOS7应用支持键盘快捷键</a></li>
<li><a href="http://www.cocoachina.com/ios/20150115/10926.html">iOS 8 Handoff 开发指南</a></li>
<li><a href="http://southpeak.github.io/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/">iOS 8 Handoff Tutorial</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/">翻译篇：iOS 8 Handoff Tutorial</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-01T12:33:51+08:00" pubdate data-updated="true">Mar 1<sup>st</sup>, 2015</time>
        
        
           | <a href="/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文由Soheil Azarpour发表于raywenderlich，地址是<a href="http://www.raywenderlich.com/84174/ios-8-handoff-tutorial">iOS 8 Handoff Tutorial</a></p>

<p>Handoff是iOS 8和OS X Yosemite中的一个新特性。它让我们在不同的设备间切换时，可以不间断地继续一个Activity，而不需要重新配置任何设备。</p>

<p>我们可以为在iOS 8和Yosemite上的应用添加Handoff特性。在这篇指南中，我们将学习Handoff的基本功能和如何在非基于文档的app中使用Handoff。</p>

<h2>Handoff概览</h2>

<p>在开始写代码前，我们需要先来了解一下handoff的一些基本概念。</p>

<h3>起步</h3>

<p>Handoff不仅可以将当前的activity从一个iOS设备传递到OS X设备，还可以将activity在不同的iOS设备传递。目前在模拟器上还不能使用Handoff功能，所以需要在iOS设备上运行我们的实例。</p>

<h4>设备兼容性：iOS</h4>

<p>为了查看我们的iOS设备是否支持handoff功能，我们可以查看“设置”->“通用”列表。如果在列表中看到“Handoff与建议的应用程序”，则设备具备Handoff功能。以下截图显示了iPhone 5s(具备Handoff功能)和iPad3(不具备Handoff功能)的对比：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/settings_screenshots-436x320.jpg" alt="image" /></p>

<p>Handoff功能依赖于以下几点：</p>

<ol>
<li>一个iCloud账户：我们必须在希望使用Handoff功能的多台设备上登录同一个iCloud账户。</li>
<li>低功耗蓝牙(Bluetooth LE 4.0)：Handoff是通过低功耗蓝牙来广播activities的，所以广播设备和接收设备都必须支持Bluetooth LE 4.0。</li>
<li>iCloud配对：设备必须已经通过iCloud配对。当在支持Handoff的设备上登录iCloud账户后，每台设备都会与其它支持Handoff的设备进行配对。</li>
</ol>


<p>此时，我们需要确保已经使用同一iCloud账号在两台支持Handoff功能且运行iOS 8+系统的设备上登录了。(译者注：具体配置可以参考<a href="https://support.google.com/chrome/answer/6153783?hl=zh-Hans">在 Chrome（iOS 版）中使用 Handoff</a>)</p>

<h3>User Activities</h3>

<p>Handoff是基于User Activity的。User Activity是一个独立的信息集合单位，可以不依赖于任何其它信息而进行传输(be handed off)。</p>

<p>NSUserActivity对象表示一个User Activity实例。它封装了程序的一些状态，这些状态可以在其它设备相关的程序中继续使用。</p>

<p>有三种方法和一个NSUserActivity对象交互：</p>

<p>1) 创建一个user activity：原始应用程序创建一个NSUserActivity实例并调用becomeCurrent()以开启一个广播进程。下面是一个实例：</p>

<pre><code>let activity = NSUserActivity(activityType: "com.razeware.shopsnap.view")
activity.title = "Viewing"
activity.userInfo = ["shopsnap.item.key": ["Apple", "Orange", "Banana"]]
self.userActivity = activity;
self.userActivity?.becomeCurrent()
</code></pre>

<p>我们可以使用NSUserActivity的userInfo字典来传递本地数据类型对象或可编码的自定义对象以将其传输到接收设备。本地数据类型包括NSArray, NSData, NSDate, NSDictionary, NSNull, NSNumber, NSSet, NSString, NSUUID和NSURL。通过NSURL可能会有点棘手。在使用NSURL前可以先参考一下下面的“最佳实践”一节。</p>

<p>2) 更新user activity：一旦一个NSUserActivity成为当前的activity，则iOS会在最上层的视图控制器中调用updateUserActivityState(activity:)方法，以让我们有机会来更新user activity。下面是一个实例：</p>

<pre><code>override func updateUserActivityState(activity: NSUserActivity) {
  let activityListItems = // ... get updated list of items
  activity.addUserInfoEntriesFromDictionary(["shopsnap.item.key": activityListItems])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>注意我们不要将userInfo设置为一个新的字典或直接更新它，而是应该使用便捷方法addUserInfoEntriesFromDictionary()。</p>

<p>在下文中，我们将学习如何按需求强制刷新user activity，或者是在程序的app delegate级别来获取一个相似功能的回调。</p>

<p>3) 接收user activity：当我们的接收程序以Handoff的方式启动时，程序代理会调用application(:willContinueUserActivityWithType:)方法。注意这个方法的参数不是NSUserActivity对象，因为接收程序在下载并传递NSUserActivity数据需要花费一定的时间。在user activity已经被下载完成后，会调用以下的回调函数：</p>

<pre><code>func application(application: UIApplication!, 
                 continueUserActivity userActivity: NSUserActivity!,
                 restorationHandler: (([AnyObject]!) -&gt; Void)!) 
                 -&gt; Bool {

  // Do some checks to make sure you can proceed
  if let window = self.window {
    window.rootViewController?.restoreUserActivityState(userActivity)
  }
  return true
}
</code></pre>

<p>然后我们可以使用存储在NSUserActivity对象中的数据来重新创建用户的activity。在这里，我们更新我们的应用以继续相关的activity。</p>

<h3>Activity类型</h3>

<p>当创建一个user activity后，我们必须为其指定一个activity类型。一个activity类型是一个简单的唯一字符串，通常使用反转DNS语义，如com.razeware.shopsnap.view。</p>

<p>每一个可以接收user activity的程序都必须声明其可接收的activity类型。这类似于在程序中声明支持的URL方案(URL scheme)。对于非基于文本的程序，activity类型需要在Info.plist文件中定义，其键值为NSUserActivityTypes，如下所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/image10-38-480x259.png" alt="image" /></p>

<p>对于支持一个给定activity的程序来说，需要满足三个要求：</p>

<ol>
<li>相同的组：两个程序都必须源于使用同一开发者组ID(developer Team ID)的开发者。</li>
<li>相同的activity类型：发送程序创建某一activity类型的user activity，接收程序必须有相应类型的NSUserActivityTypes入口。</li>
<li>签约：两个程序必须通过App store来发布或使用同一开发者账号来签约。</li>
</ol>


<p>现在我们已经学习了user activities和activity类型的基础知识，接下来让我们来看一个实例。</p>

<h2>启动工程</h2>

<p>本指南的启动工程可以在“<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/10/ShopSnap-Starter.zip">启动工程</a>”中下载。下载后，使用Xcode打开工程并在iPhone模拟器中运行。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/App_Screenshots-700x412.jpg" alt="image" /></p>

<p>工程名是ShopSnap，我们可以在这个程序中构建一个简单的购物清单。一个购物项由一个字符串表示，然后我们将购物项存储在一个字符串的数组中。点击+按钮添加一个新的项目到清单中，而轻扫可以移除项目。</p>

<p>我们将在程序中定义两个独立的user activity：</p>

<ol>
<li>查看清单。如果用户当前正在查看清单，我们将传输整个数组。</li>
<li>添加或编译项目。如果用户当前正在添加新的项目，我们将传递一个单一项目的“编辑”activity。</li>
</ol>


<h3>设置开发组</h3>

<p>为了让Handoff工作，发送和接收app都必须使用相同的开发组来签约。由于这个示例程序即是发送者也是接收者，所以这很简单！</p>

<p>选择ShopSnap工程，在“通用”选项卡中，在&#8221;Team&#8221;中选择自己的开发组：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/10/image15-49-700x232.png" alt="image" /></p>

<p>在支持Handoff的设备中编译并运行程序，以确保运行正常，然后继续。</p>

<h3>配置activity类型</h3>

<p>接下来是配置程序所支持的activity类型。打开&#8221;Supporting Files\Info.plist&#8221;，点击&#8221;Information Property List&#8221;旁边的&#8221;+&ldquo;按钮，在&#8221;Information Property List&#8221;中添加一个新的选项：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image16-52-480x268.png" alt="image" /></p>

<p>键名为&#8221;NSUserActivityTypes&#8221;，类型设备为数组类型，如下所示：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/10/image17-55-480x233.png" alt="image" /></p>

<p>在NSUserActivityTypes下添加两项并设置类型为字符串。Item 0的值为com.razeware.shopsnap.view，Item 1的值为com.razeware.shopsnap.edit。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image18-58-480x85.png" alt="image" /></p>

<p>这些任意的activity类型对于我们的程序来说是特定和唯一的。因为我们将在程序的不同地方引用它们，所以在独立的文件中将其添加为常量是一种好的实践。</p>

<p>在工程导航中右键点击ShopSnap组，选择&#8221;New File \ iOS \ Source \ Swift File&#8221;。将文件命名为Constants.swift并确保新类被添加到ShopSnap target中。</p>

<p>在类中添加以下代码：</p>

<pre><code>let ActivityTypeView = "com.razeware.shopsnap.view"
let ActivityTypeEdit = "com.razeware.shopsnap.edit"

let ActivityItemsKey = "shopsnap.items.key"
let ActivityItemKey  = "shopsnap.item.key"
</code></pre>

<p>然后我们就可以使用这两个activity类型的常量。同时我们定义一些用于user activity的userInfo字典的键名字符串。</p>

<h3>快速端到端测试</h3>

<p>让我们来运行一个快速端到端测试以确保设备可以正确地通信。</p>

<p>打开ListViewController.swift并添加以下两个函数：</p>

<pre><code>// 1.
func startUserActivity() {
  let activity = NSUserActivity(activityType: ActivityTypeView)
  activity.title = "Viewing Shopping List"
  activity.userInfo = [ActivityItemsKey: ["Ice cream", "Apple", "Nuts"]]
  userActivity = activity
  userActivity?.becomeCurrent()
}

// 2.
override func updateUserActivityState(activity: NSUserActivity) {
  activity.addUserInfoEntriesFromDictionary([ActivityItemsKey: ["Ice cream", "Apple", "Nuts"]])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>我们通过硬编码一个user activity来快速测试，以确保我们可以在另一端正常接收。</p>

<p>上面的代码做了以下两件事：</p>

<ol>
<li>startUserActivity()是一个辅助函数，它使用一个硬编码的购物清单来创建了一个NSUserActivity实例。然后调用becomeCurrent()来广播这个activity。</li>
<li>在调用becomeCurrent()后，系统将定期调用updateUserActivityState()。UIViewController从UIResponder类中继承了这个方法，我们应该重写它来更新我们的userActivity的状态。在这里，我们像前面一样使用硬编码来更新购物清单。注意，我们应该使用addUserInfoEntriesFromDictionary方法来修改NSUserActivity的userInfo字典。我们应该总是在方法的结尾调用super.updateUserActivityState()。</li>
</ol>


<p>注意，我们只需要调用上面的起始方法。在viewDidLoad()起始行下面添加以下代码</p>

<pre><code>startUserActivity()
</code></pre>

<p>开始广播至少需要以上步骤。现在来看看接收者。打开AppDelegate.swift并添加以下代码：</p>

<pre><code>func application(application: UIApplication!, 
                 continueUserActivity userActivity: NSUserActivity!, 
                 restorationHandler: (([AnyObject]!) -&gt; Void)!) 
                 -&gt; Bool {

  let userInfo = userActivity.userInfo as NSDictionary
  println("Received a payload via handoff: \(userInfo)")
  return true
}
</code></pre>

<p>AppDelegate中的这个方法在所有事情都准备好，且一个userActivity被成功传送后调用。在这里我们简单打印userActivity中的userInfo字典。我们返回true来标识我们处理了user activity。</p>

<p>让我们来试试！要想在两台设备中正常工作，还需要做一些协调工作，所以还得仔细跟着。</p>

<ol>
<li>在第一台设备上安装并运行程序。</li>
<li>在第二台设备上安装并运行程序。确保在Xcode中调用程序以便我们能看到打印输出。</li>
<li><p>按下电源按钮让第二台设备休眠。在同一台设备上，按下Home键。如果所有事件都正常运行，我们应该可以看到ShopSnap程序的icon显示在屏幕的左下角上。从这里我们可以启动程序，然后在Xcode控制台可以看到以下的日志信息：</p>

<p> Received a payload via handoff: {
     &ldquo;shopsnap.items.key&rdquo; = (
     &ldquo;Ice cream&rdquo;,
     Apple,
     Nuts
   );
 }</p></li>
</ol>


<p>如果在锁屏下没有看到程序的icon，则在源设备上关闭并重新打开程序。这将强制系统重新广播信息。同时确认一下设备的控制台以查看是否有来自于Handoff的错误消息。</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/10/image20-63-180x320.png" alt="image" /></p>

<h2>创建一个新的Activity</h2>

<p>现在我们有一个基本上可以工作的Handoff程序，是时候来扩展它了。打开ListViewController.swift，更新startUserActivity()方法，这次我们传入实际的购物清单以代码硬编码。使用以下代码来更新方法：</p>

<pre><code>func startUserActivity() {
  let activity = NSUserActivity(activityType: ActivityTypeView)
  activity.title = "Viewing Shopping List"
  activity.userInfo = [ActivityItemsKey: items]
  userActivity = activity
  userActivity?.becomeCurrent()
}
</code></pre>

<p>同样，更新ListViewController.swift的updateUserActivityState(activity:)方法，传递购物清单数组：</p>

<pre><code>override func updateUserActivityState(activity: NSUserActivity) {
  activity.addUserInfoEntriesFromDictionary([ActivityItemsKey: items])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>现在，更新ListViewController.swift中的viewDidLoad()，在从前面的代码中成功获取到清单后开启userActivity，如下所示：</p>

<pre><code>override func viewDidLoad() {
  title = "Shopping List"
  weak var weakSelf = self
  PersistentStore.defaultStore().fetchItems({ (items:[String]) in
    if let unwrapped = weakSelf {
      unwrapped.items = items
      unwrapped.tableView.reloadData()
      if items.isEmpty == false {
        unwrapped.startUserActivity()
      }
    }
  })
  super.viewDidLoad()
}
</code></pre>

<p>当然，如果程序开始时，清单是空的，则程序不会去广播user activity。我们需要解决这个问题：在用户第一次添加一个购物项到列表时开启user activity。</p>

<p>为了做到这一点，更新ListViewController.swift中代理回调detailViewController(controller:didFinishWithUpdatedItem:)的实现，如下所示：</p>

<pre><code>func detailViewController(#controller: DetailViewController,
                          didFinishWithUpdatedItem item: String) {
    // ... some code
    if !items.isEmpty {
      startUserActivity()
    }
}
</code></pre>

<p>在此有三种可能：</p>

<ol>
<li>用于更新一个已存在的购物项</li>
<li>用户删除一个存在的购物项</li>
<li>用户添加一个新的购物项</li>
</ol>


<p>现存的代码处理了所有的可能性；我们只需要添加一些检测代码，以在有一个非空的清单时开始一个activity。</p>

<p>在两台设备上编译并运行。此时，我们应该可以在一台设备上添加新的项目，然后将其发送给另外一台设备。</p>

<h3>收尾</h3>

<p>当用户开始添加一个新的项目或编辑一个已存在的项目时，用户可能不是在查看购物清单。所以我们需要停止广播当前activity。同样，当清单中的所有项目被删除时，没有理由去继续广播当前activiry。在ListViewController.swift中添加以下辅助方法：</p>

<pre><code>func stopUserActivity() {
  userActivity?.invalidate()
}
</code></pre>

<p>在stopUserActivity()中，我们废止已存在的NSUserActivity。这让handoff停止广播。</p>

<p>现在有了stopUserActivity()，是时候在适当的地方调用它了。</p>

<p>在ListViewController.swift中，更新prepareForSegue(segue:, sender:)方法的实现，如下所示：</p>

<pre><code>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject!) {
    // ... some code
    stopUserActivity()
}
</code></pre>

<p>当用户选择一行或者点击添加按钮时，ListViewController准备导航到详情视图。我们废弃当前的清单查看activity。</p>

<p>在同一文件中，更新tableView(_:commitEditingStyle:forRowAtIndexPath:)的实现，如下所示：</p>

<pre><code>override func tableView(tableView: UITableView, 
                        commitEditingStyle editingStyle: UITableViewCellEditingStyle,
                        forRowAtIndexPath indexPath: NSIndexPath) {
  // ... some code
  if items.isEmpty {
    stopUserActivity()
  } else {
    userActivity?.needsSave = true
  }
}
</code></pre>

<p>当用户从清单中删除一项时，我们需要相应地更新user activity。如果移除清单中的所有项目，我们停止广播。否则，我们设置userActivity的needsSave属性为true。当我们这样做时，系统会立即回调updateUserActivityState(activity:)，在这里我们会更新userActivity。</p>

<p>结束这一节之前，还有一种情况需要考虑，用户点击取消按钮，然后从DetailViewController中返回。这触发了一个已存在的场景。我们需要重新开始userActivity。更新unwindDetailViewController(unwindSegue:)的实现，如下所示：</p>

<pre><code>@IBAction func unwindDetailViewController(unwindSegue: UIStoryboardSegue) {
  // ... some code
  startUserActivity()
}
</code></pre>

<p>编译并运行，确保所有事情运行正常。尝试添加一些项目到清单中，确保它们在设备间传输。</p>

<h2>创建一个编辑Activity</h2>

<p>接下来，我们以类似的方式来处理DetailViewController。这一次，我们广播另一个activity类型。</p>

<p>打开DetailViewController.swift并修改textFieldDidBeginEditing(textField:)，如下所示：</p>

<pre><code>func textFieldDidBeginEditing(textField: UITextField!) {
  // Broadcast what we have, if there is anything!
  let activity = NSUserActivity(activityType: ActivityTypeEdit)
  activity.title = "Editing Shopping List Item"
  let activityItem = (countElements(textField.text!) &gt; 0) ? textField.text : ""
  activity.userInfo = [ActivityItemKey: activityItem]
  userActivity = activity
  userActivity?.becomeCurrent()
}
</code></pre>

<p>上面的方法使用项目的字符串的当前内容创建一个“编辑”activity。</p>

<p>当用户继续编辑项目时，我们需要更新user activity。仍然是在DetailViewController.swift中，更新textFieldTextDidChange(notification:)的实现，如下所示：</p>

<pre><code>func textFieldTextDidChange(notification: NSNotification) {
  if let text = textField!.text {
    item = text
  }

  userActivity?.needsSave = true
}
</code></pre>

<p>现在我们已经标记了activity需要更新，接下来实现updateUserActivityState(activity:)，以备系统的更新需求：</p>

<pre><code>override func updateUserActivityState(activity: NSUserActivity) {
  let activityListItem = (countElements(textField!.text!) &gt; 0) ? textField!.text : ""
  activity.addUserInfoEntriesFromDictionary([ActivityItemKey: activityListItem])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>这里我们简单地更新了当前项为文本输入框中的文本。</p>

<p>编译并运行。此时，如果我们在一个设备中开始添加一个新项或编辑已存在的项目，我们可以将编辑进程同步给另一个设备。</p>

<h3>收尾</h3>

<p>因为needsSave是一个轻量级的操作，在上面的代码中，你可以根据需要来设置它，然后在每次按键时更新userInfo。</p>

<p>这里有一个小细节你可能已经注意到了。视图控制器在iPad和iPhone的景观模式下中是一个分离视图。这样可以在清单的项目间切换而不需要收起键盘。这种情况发生时，textFieldDidBeginEditing(textField:)方法不会被调用，导致我们的user activity不会更新为新的文本。</p>

<p>为了解决这个问题，更新DetailViewController.swift中item属性的didSet观察者，如下所示：</p>

<pre><code>var item: String? {
  didSet {
    if let textField = self.textField {
      textField.text = item
    }
    if let activity = userActivity {
      activity.needsSave = true
    }
  }
}
</code></pre>

<p>当用户点击ListViewController中的一个项目时，DetailViewController的item属性被设置。一个简单解决方案是让视图控制器知道，在项目更新时它必须更新activity。</p>

<p>最后，当用户离开DetailViewController时，我们需要废止userActivity，以让编辑activity不再被广播。</p>

<p>在DetailViewController.swift的textFieldShouldReturn(_:)方法的起始位置添加以下代码：</p>

<pre><code>userActivity?.invalidate()
</code></pre>

<p>编译并运行程序，确保程序工作正常。接下来，我们将处理接收的activity。</p>

<h2>接收Activity</h2>

<p>当用户通过Handoff启动程序时，处理接收的NSUserActivity的任务大部分是由程序的delegate来完成的。</p>

<p>假设所有事情运行正常，数据成功传输，iOS会调用application(_:continueUserActivity:restorationHandler:)方法。这是我们与NSUserActivity实例交互的第一次机会。</p>

<p>我们在前面的章节中已经有一个该方法的实现了。现在，我们做如下修改：</p>

<pre><code>func application(application: UIApplication!, 
                 continueUserActivity userActivity: NSUserActivity!,
                 restorationHandler: (([AnyObject]!) -&gt; Void)!)
                 -&gt; Bool {

  if let window = self.window {
    window.rootViewController?.restoreUserActivityState(userActivity)
  }
  return true
}
</code></pre>

<p>我们将userActivity传递给程序的window对象的rootViewController，然后返回true。这告诉系统成功处理了Handoff行为。从这里开始，我们将自己转发调用并恢复activity。</p>

<p>我们在rootViewController中调用的方法是restoreUserActivityState(activity:)。这是在UIResponder中声明的一个标准方法。系统使用这个方法来告诉接收者恢复一个NSUserActivivty实例。</p>

<p>我们现在的任务是沿着视图控制器架构往下，将activity从父视图控制器传递到子视图控制器，直到到达需要使用activity的地方：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image22-691-700x360.png" alt="image" /></p>

<p>根视图控制器是一个TraitOverrideViewController对象，它的任务是管理程序的size classes；它对我们的user activity不感兴趣。打开TraitOverrideViewController.swift并添加以下代码：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  let nextViewController = childViewControllers.first as UIViewController
  nextViewController.restoreUserActivityState(activity)
  super.restoreUserActivityState(activity)
}
</code></pre>

<p>在这里，我们获取TraitOverrideViewController的第一个子视图控制器，然后将activity往下传递。这样做是安全的，因为我们知道程序的视图控制器只包含一个子视图控制器。</p>

<p>层级架构中的下一个视图控制器是SplitViewController，在这里事情会变得更有趣一些。</p>

<p>打开SplitViewController.swift并添加以下代码：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  // What type of activity is it?
  let activityType = activity.activityType

  // This is an activity for ListViewController.
  if activityType == ActivityTypeView {
    let controller = viewControllerForViewing()
    controller.restoreUserActivityState(activity)

  } else if activityType == ActivityTypeEdit {
    // This is an activity for DetailViewController.
    let controller = viewControllerForEditing()
    controller.restoreUserActivityState(activity)
  }

  super.restoreUserActivityState(activity)
}
</code></pre>

<p>SplitViewController知道ListViewController和DetailViewController。如果NSUserActivity是一个列表查看activity类型，则将其传递给ListViewController；否则，如果是一个编辑activity类型，则传递给DetailViewController。</p>

<p>我们将所有的activity传递给正确的对象，现在是时候从这些activity中获取数据了。</p>

<p>打开ListViewController.swift并实现restoreUserActivityState(activity:)，如下所示：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  // Get the list of items.
  if let userInfo = activity.userInfo {
    if let importedItems = userInfo[ActivityItemsKey] as? NSArray {
      // Merge it with what we have locally and update UI.
      for anItem in importedItems {
        addItemToItemsIfUnique(anItem as String)
      }
      PersistentStore.defaultStore().updateStoreWithItems(items)
      PersistentStore.defaultStore().commit()
      tableView.reloadData()
    }
  }
  super.restoreUserActivityState(activity)
}
</code></pre>

<p>在上面的方法中，我们终于可以继续一个查看activity了。因为我们需要维护一个唯一的购物清单时，我们只需要将这些唯一的项目添加到本地列表中，然后保存并更新UI。</p>

<p>编译并运行。现在我们可以看到通过Handoff从另一台设备上同步过来的清单数据了。</p>

<p>编辑activity以类似的方法来处理。打开DetailViewController.swift并实现restoreUserActivityState(activity:)，如下所示：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  if let userInfo = activity.userInfo {
    var activityItem: AnyObject? = userInfo[ActivityItemKey]
    if let itemToRestore = activityItem as? String {
      item = itemToRestore
      textField?.text = item
    }
  }
  super.restoreUserActivityState(activity)
}
</code></pre>

<p>这里获取编辑activity的信息并更新文本域的内容。</p>

<p>编译并运行，查看运行结果！</p>

<h3>收尾</h3>

<p>当用户在另一台设备上点击程序的icon以表明他们想要继续一个user activity时，系统启动相应的程序。一旦程序启动后，系统调用application(_, willContinueUserActivityWithType:)方法。打开AppDelegate.swift并添加以下方法：</p>

<pre><code>func application(application: UIApplication,
                 willContinueUserActivityWithType userActivityType: String!)
                 -&gt; Bool {
  return true
}
</code></pre>

<p>到这里，我们的程序已经下载了NSUserActivity实例及其userInfo有效载荷。现在我们只是简单返回true。这强制程序在每次用户初始Handoff进程时接收activity。如果想要通知用户activity正在处理，则这是个好地方。</p>

<p>到这里，系统开始将数据从一台设备同步到另一台设备上。我们已经覆盖了任务正常运行的所有情况。但是可以想象Handoff的activity在某些情况下会失败。</p>

<p>将以下方法添加到AppDelegate.swift中来处理这种情况：</p>

<pre><code>func application(application: UIApplication!, 
                 didFailToContinueUserActivityWithType userActivityType: String!,
                 error: NSError!) {

  if error.code != NSUserCancelledError {
    let message = "The connection to your other device may have been interrupted. Please try again. \(error.localizedDescription)"
    let alertView = UIAlertView(title: "Handoff Error", message: message, delegate: nil, cancelButtonTitle: "Dismiss")
    alertView.show()
  }
}
</code></pre>

<p>如果我们接收到除了NSUserCancelledError之外的任何信息，则发生了某些错误，且我们不能恢复activity。在这种情况下，我们显示一个适当的消息给用户。然而，如果用户显示取消Handoff行为，则在这里我们不需要做任何事情，只需要放弃操作。</p>

<h2>版本支持</h2>

<p>使用Handoff的最佳实践之一是版本化。处理这的一个策略是为每个发送的Handoff添加一个版本号，并且只接收来自这个版本号(或者更早的)handoff。让我们来试试。</p>

<p>打开Constants.swift并添加以下常量：</p>

<pre><code>let ActivityVersionKey = "shopsnap.version.key"
let ActivityVersionValue = "1.0"
</code></pre>

<p>上面的版本键名和值是我们为这个版本的程序随意挑选的键值对。</p>

<p>如果我们回顾一下上面的章节，系统会定期并自动调用restoreUserActivityState(activity:)方法。这个方法的实现聚集于并限定于实现它的对象的范围内。例如，ListViewController重写了这个方法来更新带有购物清单的userActivity，而DetailViewController的实现是更新当前正在被编辑的项目。</p>

<p>如果涉及到的东西对于userActivity来说是通用的，可用于所有的user activity，如版本号，则处理它的最好的地方就是在AppDelegate中了。</p>

<p>任何时候调用restoreUserActivityState(activity:)，系统都会紧接着调用程序delegate的application(application:, didUpdateUserActivity userActivity:)方法。我们使用这个方法来为我们的Handoff添加版本支持。</p>

<p>打开AppDelegate.swift并添加以下代码：</p>

<pre><code>func application(application: UIApplication, 
                 didUpdateUserActivity userActivity: NSUserActivity) {
  userActivity.addUserInfoEntriesFromDictionary([ActivityVersionKey: ActivityVersionValue])
}
</code></pre>

<p>在这里我们简单地使用了程序的版本号来更新了userInfo字典。</p>

<p>仍然是在AppDelegate.swift中，更新application(_:, continueUserActivity: restorationHandler:)的实现，如下所示：</p>

<pre><code>func application(application: UIApplication!,
                 continueUserActivity userActivity: NSUserActivity!,
                 restorationHandler: (([AnyObject]!) -&gt; Void)!)
                 -&gt; Bool {

  if let userInfo: NSDictionary = userActivity.userInfo {
    if let version = userInfo[ActivityVersionKey] as? String {
      // Pass it on.
      if let window = self.window {
        window.rootViewController?.restoreUserActivityState(userActivity)
      }
      return true
    }
  }
  return false
}
</code></pre>

<p>在这里我们检查userAcitivty的版本，只有当版本号与我们知道的相匹配时才传递。编译并运行，确保程序运行正常。</p>

<h2>Handoff最佳实践</h2>

<p>在结束之前，我们来看看Handoff的最佳实践：</p>

<ol>
<li><p>NSURL：在NSUserActivity的userInfo字典中使用NSURL有点棘手。唯一可以安全地在Handoff中传输的NSURLs是使用HTTP/HTTPS和iCloud文档的web网址。我们不能传递本地文件的URL，因为在接收者端，接收者不能正确地转换并映射这些URL。传输文件链接的最好的方式是传递相对路径，然后在接收者端重新构建我们的URL。</p></li>
<li><p>平台特定值：避免使用平台特定值，如滑动视图的内容偏移量；更好的方法是使用相对位置。例如，如果用户查看table view中的一些项目时，在我们的user activity中传递table view最上面的可视项的index path，而不是传递table view可视区域的内容偏移量。</p></li>
<li><p>版本：想想在程序中使用版本和将来的更新。我们可以在程序的未来版本中添加一些新数据格式或者从userInfo字典中移除值。版本让我们可以理好地控制我们的user activity在当前和将来版本的程序中的行为。</p></li>
</ol>


<h2>下一步是哪</h2>

<p>这里是<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/ShopSnap-Final.zip">示例工程</a>的最终版本。</p>

<p>如果想了解更多的关于Handoff，流和基于文档的Handoff，则可以查看Handoff的开发文档<a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/Handoff/HandoffFundamentals/HandoffFundamentals.html">Apple’s Handoff Programming Guide</a>以获取更多的信息。</p>

<p>如果喜欢这篇文章，则可以下载我们的书<a href="http://www.raywenderlich.com/store/ios-8-by-tutorials">iOS 8 by Tutorials</a>，这里塞满了这样的教程。</p>

<p>如果有更多的总量或关于这篇文章的评论，那么可以加入下面的讨论。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/11/nscache/">NSCache</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-11T21:45:14+08:00" pubdate data-updated="true">Feb 11<sup>th</sup>, 2015</time>
        
        
           | <a href="/blog/2015/02/11/nscache/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>NSCache是一个类似于集合的容器，即缓存。它存储key-value对，这一点类似于NSDictionary类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。如果对象被丢弃了，则下次使用时需要重新计算。</p>

<p>当一个key-value对在缓存中时，缓存维护它的一个强引用。存储在NSCache中的通用数据类型通常是实现了NSDiscardableContent协议的对象。在缓存中存储这类对象是有好处的，因为当不再需要它时，可以丢弃这些内容，以节省内存。默认情况下，缓存中的NSDiscardableContent对象在其内容被丢弃时，会被移除出缓存，尽管我们可以改变这种缓存策略。如果一个NSDiscardableContent被放进缓存，则在对象被移除时，缓存会调用discardContentIfPossible方法。</p>

<p>NSCache与可变集合有几点不同：</p>

<ol>
<li>NSCache类结合了各种自动删除策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用。</li>
<li>NSCache是线程安全的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域。</li>
<li>不像NSMutableDictionary对象，一个缓存对象不会拷贝key对象。</li>
</ol>


<p>这些特性对于NSCache类来说是必须的，因为在需要释放内存时，缓存必须异步地在幕后决定去自动修改自身。</p>

<h2>缓存限制</h2>

<p>NSCache提供了几个属性来限制缓存的大小，如属性countLimit限定了缓存最多维护的对象的个数。声明如下：</p>

<pre><code>@property NSUInteger countLimit
</code></pre>

<p>默认值为0，表示不限制数量。但需要注意的是，这不是一个严格的限制。如果缓存的数量超过这个数量，缓存中的一个对象可能会被立即丢弃、或者稍后、也可能永远不会，具体依赖于缓存的实现细节。</p>

<p>另外，NSCache提供了totalCostLimit属性来限定缓存能维持的最大内存。其声明如下：</p>

<pre><code>@property NSUInteger totalCostLimit
</code></pre>

<p>默认值也是0，表示没有限制。当我们添加一个对象到缓存中时，我们可以为其指定一个消耗(cost)，如对象的字节大小。如果添加这个对象到缓存导致缓存总的消耗超过totalCostLimit的值，则缓存会自动丢弃一些对象，直到总消耗低于totalCostLimit值。不过被丢弃的对象的顺序无法保证。</p>

<p>需要注意的是totalCostLimit也不是一个严格限制，其策略是与countLimit一样的。</p>

<h2>存取方法</h2>

<p>NSCache提供了一组方法来存取key-value对，类似于NSMutableDictionary类。如下所示：</p>

<pre><code>- (id)objectForKey:(id)key

- (void)setObject:(id)obj forKey:(id)key

- (void)removeObjectForKey:(id)key

- (void)removeAllObjects
</code></pre>

<p>如上所述，与NSMutableDictionary不同的就是它不会拷贝key对象。</p>

<p>此外，我们在存储对象时，可以为对象指定一个消耗值，如下所示：</p>

<pre><code>- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)num
</code></pre>

<p>这个消耗值用于计算缓存中所有对象的一个消耗总和。当内存受限或者总消耗超过了限定的最大总消耗，则缓存应该开启一个丢弃过程以移除一些对象。不过，这个过程不能保证被丢弃对象的顺序。其结果是，如果我们试图操作这个消耗值来实现一些特殊的行为，则后果可能会损害我们的程序。通常情况下，这个消耗值是对象的字节大小。如果这些信息不是现成的，则我们不应该去计算它，因为这样会使增加使用缓存的成本。如果我们没有可用的值传递，则直接传递0，或者是使用-setObject:forKey:方法，这个方法不需要传入一个消耗值。</p>

<h2>NSDiscardableContent协议</h2>

<p>NSDiscardableContent是一个协议，实现这个协议的目的是为了让我们的对象在不被使用时，可以将其丢弃，以让程序占用更少的内存。</p>

<p>一个NSDiscardableContent对象的生命周期依赖于一个“counter”变量。一个NSDiscardableContent对象实际是一个可清理内存块，这个内存记录了对象当前是否被其它对象使用。如果这块内存正在被读取，或者仍然被需要，则它的counter变量是大于或等于1的；当它不再被使用时，就可以丢弃，此时counter变量将等于0。当counter变量等于0时，如果当前时间点内存比较紧张的话，内存块就可能被丢弃。</p>

<p>为了丢弃这些内容，可以调用对象的discardContentIfPossible方法，该方法的声明如下：</p>

<pre><code>- (void)discardContentIfPossible
</code></pre>

<p>这样当counter变量等于0时将会释放相关的内存。而如果counter变量不为0，则该方法什么也不做。</p>

<p>默认情况下，NSDiscardableContent对象的counter变量初始值为1，以确保对象不会被内存管理系统立即释放。从这个点开始，我们就需要去跟踪counter变量的状态。为此。协议声明了两个方法：beginContentAccess和endContentAccess。</p>

<p>其中调用beginContentAccess方法会增加对象的counter变量(+1)，这样就可以确保对象不会被丢弃。该方法声明如下：</p>

<pre><code>- (BOOL)beginContentAccess
</code></pre>

<p>通常我们在对象被需要或者将要使用时调用这个方法。具体的实现类可以决定在对象已经被丢弃的情况下是否重新创建这些内存，且重新创建成功后返回YES。协议的实现者在NSDiscardableContent对象被使用，而又没有调用它的beginContentAccess方法时，应该抛出一个异常。</p>

<p>函数的返回值如果是YES，则表明可丢弃内存仍然可用且已被成功访问；否则返回NO。另外需要注意的是，该方法是在实现类中必须实现(required)。</p>

<p>与beginContentAccess相对应的是endContentAccess。如果可丢弃内存不再被访问时调用。其声明如下：</p>

<pre><code>- (void)endContentAccess
</code></pre>

<p>该方法会减少对象的counter变量，通常是让对象的counter值变回为0，这样在对象的内容不再被需要时，就要以将其丢弃。</p>

<p>NSCache类提供了一个属性，来标识缓存是否自动舍弃那些内存已经被丢弃的对象(discardable-content object)，其声明如下：</p>

<pre><code>@property BOOL evictsObjectsWithDiscardedContent
</code></pre>

<p>如果设置为YES，则在对象的内存被丢弃时舍弃对象。默认值为YES。</p>

<h2>NSCacheDelegate代理</h2>

<p>NSCache对象还有一个代理属性，其声明如下：</p>

<pre><code>@property(assign) id&lt; NSCacheDelegate &gt; delegate
</code></pre>

<p>实现NSCacheDelegate代理的对象会在对象即将从缓存中移除时执行一些特定的操作，因此代理对象可以实现以下方法：</p>

<pre><code>- (void)cache:(NSCache *)cache willEvictObject:(id)obj
</code></pre>

<p>需要注意的是在这个代理方法中不能修改cache对象。</p>

<h2>小结</h2>

<p>实际上，我们常用的SDWebImage图片下载库的缓存机制就是通过NSCache来实现的。《Effective Objective-C 2.0》中也专门用一小篇的内容来介绍NSCache的使用(第50条：构建缓存时选用NSCache而非NSDictionary)，里面有更精彩的内容。如果我们需要构建缓存机制，则应该使用NSCache，而不是NSDictionary，这样可以减少我们应用对内存的占用，从而达到优化内存的目标。</p>

<p><em>题外话：最近好好久不用的微博整理了一下，重新开始混微博圈了，哈哈，还是个菜鸟。还望大家多提意见啊。微博号：南峰子_老驴(<a href="http://weibo.com/touristdiary">http://weibo.com/touristdiary</a>)</em></p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/">NSCache Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSDiscardableContent_Protocol/index.html">NSDiscardableContent Protocol Reference</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSCacheDelegate_Protocol/index.html">NSCacheDelegate Protocol Reference</a></li>
<li><a href="http://www.15yan.com/story/45toOUzFGlr/">Objective-C中的缓存: NSCache介绍</a></li>
<li><a href="http://nshipster.cn/nscache/">NSCache</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/07/yuan-ma-pian-:sdwebimage/">源码篇：SDWebImage</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-07T23:30:45+08:00" pubdate data-updated="true">Feb 7<sup>th</sup>, 2015</time>
        
        
           | <a href="/blog/2015/02/07/yuan-ma-pian-:sdwebimage/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>源码来源：<a href="https://github.com/rs/SDWebImage">https://github.com/rs/SDWebImage</a></p>

<p>版本: 3.7</p>

<p>SDWebImage是一个开源的第三方库，它提供了UIImageView的一个分类，以支持从远程服务器下载并缓存图片的功能。它具有以下功能：</p>

<ol>
<li>提供UIImageView的一个分类，以支持网络图片的加载与缓存管理</li>
<li>一个异步的图片加载器</li>
<li>一个异步的内存+磁盘图片缓存</li>
<li>支持GIF图片</li>
<li>支持WebP图片</li>
<li>后台图片解压缩处理</li>
<li>确保同一个URL的图片不被下载多次</li>
<li>确保虚假的URL不会被反复加载</li>
<li>确保下载及缓存时，主线程不被阻塞</li>
</ol>


<p>从github上对SDWebImage使用情况就可以看出，SDWebImage在图片下载及缓存的处理方面还是很被认可的。在本文中，我们主要从源码的角度来分析一下SDWebImage的实现机制。讨论的内容将主要集中在图片的下载及缓存，而不包含对GIF图片及WebP图片的支持操作。</p>

<h2>下载</h2>

<p>在SDWebImage中，图片的下载是由SDWebImageDownloader类来完成的。它是一个异步下载器，并对图像加载做了优化处理。下面我们就来看看它的具体实现。</p>

<h3>下载选项</h3>

<p>在下载的过程中，程序会根据设置的不同的下载选项，而执行不同的操作。下载选项由枚举SDWebImageDownloaderOptions定义，具体如下</p>

<pre><code>typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) {
    SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0,
    SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,

    // 默认情况下请求不使用NSURLCache，如果设置该选项，则以默认的缓存策略来使用NSURLCache
    SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,

    // 如果从NSURLCache缓存中读取图片，则使用nil作为参数来调用完成block
    SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,

    // 在iOS 4+系统上，允许程序进入后台后继续下载图片。该操作通过向系统申请额外的时间来完成后台下载。如果后台任务终止，则操作会被取消
    SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,

    // 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie
    SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,

    // 允许不受信任的SSL证书。主要用于测试目的。
    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,

    // 将图片下载放到高优先级队列中
    SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,
};
</code></pre>

<p>可以看出，这些选项主要涉及到下载的优先级、缓存、后台任务执行、cookie处理以认证几个方面。</p>

<h3>下载顺序</h3>

<p>SDWebImage的下载操作是按一定顺序来处理的，它定义了两种下载顺序，如下所示</p>

<pre><code>typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) {

    // 以队列的方式，按照先进先出的顺序下载。这是默认的下载顺序
    SDWebImageDownloaderFIFOExecutionOrder,

    // 以栈的方式，按照后进先出的顺序下载。
    SDWebImageDownloaderLIFOExecutionOrder
};
</code></pre>

<h3>下载管理器</h3>

<p>SDWebImageDownloader下载管理器是一个单例类，它主要负责图片的下载操作的管理。图片的下载是放在一个NSOperationQueue操作队列中来完成的，其声明如下：</p>

<pre><code>@property (strong, nonatomic) NSOperationQueue *downloadQueue;
</code></pre>

<p>默认情况下，队列最大并发数是6。如果需要的话，我们可以通过SDWebImageDownloader类的<strong>maxConcurrentDownloads</strong>属性来修改。</p>

<p>所有下载操作的网络响应序列化处理是放在一个自定义的并行调度队列中来处理的，其声明及定义如下：</p>

<pre><code>@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t barrierQueue;

- (id)init {
    if ((self = [super init])) {
        ...
        _barrierQueue = dispatch_queue_create("com.hackemist.SDWebImageDownloaderBarrierQueue", DISPATCH_QUEUE_CONCURRENT);
        ...
    }
    return self;
}
</code></pre>

<p>每一个图片的下载都会对应一些回调操作，如下载进度回调，下载完成回调等，这些回调操作是以block形式来呈现，为此在SDWebImageDownloader.h中定义了几个block，如下所示：</p>

<pre><code>// 下载进度
typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);
// 下载完成
typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data, NSError *error, BOOL finished);
// Header过滤
typedef NSDictionary *(^SDWebImageDownloaderHeadersFilterBlock)(NSURL *url, NSDictionary *headers);
</code></pre>

<p>图片下载的这些回调信息存储在SDWebImageDownloader类的<strong>URLCallbacks</strong>属性中，该属性是一个字典，key是图片的URL地址，value则是一个数组，包含每个图片的多组回调信息。由于我们允许多个图片同时下载，因此可能会有多个线程同时操作URLCallbacks属性。为了保证URLCallbacks操作(添加、删除)的线程安全性，SDWebImageDownloader将这些操作作为一个个任务放到barrierQueue队列中，并设置屏障来确保同一时间只有一个线程操作URLCallbacks属性，我们以添加操作为例，如下代码所示：</p>

<pre><code>- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback {

    ...

    // 1. 以dispatch_barrier_sync操作来保证同一时间只有一个线程能对URLCallbacks进行操作
    dispatch_barrier_sync(self.barrierQueue, ^{
        ...

        // 2. 处理同一URL的同步下载请求的单个下载
        NSMutableArray *callbacksForURL = self.URLCallbacks[url];
        NSMutableDictionary *callbacks = [NSMutableDictionary new];
        if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];
        if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];
        [callbacksForURL addObject:callbacks];
        self.URLCallbacks[url] = callbacksForURL;

        ...
    });
}
</code></pre>

<p>整个下载管理器对于下载请求的管理都是放在downloadImageWithURL:options:progress:completed:方法里面来处理的，该方法调用了上面所提到的addProgressCallback:andCompletedBlock:forURL:createCallback:方法来将请求的信息存入管理器中，同时在创建回调的block中创建新的操作，配置之后将其放入downloadQueue操作队列中，最后方法返回新创建的操作。其具体实现如下：</p>

<pre><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock {
    ...

    [self addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^{
        ...

        // 1. 创建请求对象，并根据options参数设置其属性
        // 为了避免潜在的重复缓存(NSURLCache + SDImageCache)，如果没有明确告知需要缓存，则禁用图片请求的缓存操作
        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];
        ...

        // 2. 创建SDWebImageDownloaderOperation操作对象，并进行配置
        // 配置信息包括是否需要认证、优先级
        operation = [[wself.operationClass alloc] initWithRequest:request
                                                          options:options
                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) {
                                                             // 3. 从管理器的callbacksForURL中找出该URL所有的进度处理回调并调用
                                                             ...
                                                             for (NSDictionary *callbacks in callbacksForURL) {
                                                                 SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];
                                                                 if (callback) callback(receivedSize, expectedSize);
                                                             }
                                                         }
                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) {
                                                             // 4. 从管理器的callbacksForURL中找出该URL所有的完成处理回调并调用，
                                                             // 如果finished为YES，则将该url对应的回调信息从URLCallbacks中删除
                                                            ...
                                                            if (finished) {
                                                                [sself removeCallbacksForURL:url];
                                                            }
                                                            for (NSDictionary *callbacks in callbacksForURL) {
                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];
                                                                if (callback) callback(image, data, error, finished);
                                                            }
                                                        }
                                                        cancelled:^{
                                                            // 5. 取消操作将该url对应的回调信息从URLCallbacks中删除
                                                            SDWebImageDownloader *sself = wself;
                                                            if (!sself) return;
                                                            [sself removeCallbacksForURL:url];
                                                        }];

        ...

        // 6. 将操作加入到操作队列downloadQueue中
        // 如果是LIFO顺序，则将新的操作作为原队列中最后一个操作的依赖，然后将新操作设置为最后一个操作
        [wself.downloadQueue addOperation:operation];
        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {
            [wself.lastAddedOperation addDependency:operation];
            wself.lastAddedOperation = operation;
        }
    }];

    return operation;
}
</code></pre>

<p>另外，每个下载操作的超时时间可以通过downloadTimeout属性来设置，默认值为15秒。</p>

<h3>下载操作</h3>

<p>每个图片的下载都是一个Operation操作。我们在上面分析过这个操作的创建及加入操作队列的过程。现在我们来看看单个操作的具体实现。</p>

<p>SDWebImage定义了一个协议，即<strong>SDWebImageOperation</strong>作为图片下载操作的基础协议。它只声明了一个cancel方法，用于取消操作。协议的具体声明如下：</p>

<pre><code>@protocol SDWebImageOperation &lt;NSObject&gt;

- (void)cancel;

@end
</code></pre>

<p>SDWebImage自定义了一个Operation类，即<strong>SDWebImageDownloaderOperation</strong>，它继承自NSOperation，并采用了SDWebImageOperation协议。除了继承而来的方法，该类只向外暴露了一个方法，即上面所用到的初始化方法initWithRequest:options:progress:completed:cancelled:。</p>

<p>对于图片的下载，SDWebImageDownloaderOperation完全依赖于URL加载系统中的NSURLConnection类(并未使用7.0以后的NSURLSession类)。我们先来分析一下SDWebImageDownloaderOperation类中对于图片实际数据的下载处理，即NSURLConnection各代理方法的实现。</p>

<p>首先，SDWebImageDownloaderOperation在分类中采用了NSURLConnectionDataDelegate协议，并实现了该协议的以下几个方法：</p>

<pre><code>- connection:didReceiveResponse:
- connection:didReceiveData:
- connectionDidFinishLoading:
- connection:didFailWithError:
- connection:willCacheResponse:
- connectionShouldUseCredentialStorage:
- connection:willSendRequestForAuthenticationChallenge:
</code></pre>

<p>我们在此不逐一分析每个方法的实现，就重点分析一下-connection:didReceiveData:方法。该方法的主要任务是接收数据。每次接收到数据时，都会用现有的数据创建一个CGImageSourceRef对象以做处理。在首次获取到数据时(width+height==0)会从这些包含图像信息的数据中取出图像的长、宽、方向等信息以备使用。而后在图片下载完成之前，会使用CGImageSourceRef对象创建一个图片对象，经过缩放、解压缩操作后生成一个UIImage对象供完成回调使用。当然，在这个方法中还需要处理的就是进度信息。如果我们有设置进度回调的话，就调用这个进度回调以处理当前图片的下载进度。</p>

<p><em>注：缩放操作可以查看SDWebImageCompat文件中的SDScaledImageForKey函数；解压缩操作可以查看SDWebImageDecoder文件+decodedImageWithImage方法</em></p>

<pre><code>- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
    // 1. 附加数据
    [self.imageData appendData:data];

    if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0 &amp;&amp; self.completedBlock) {

        // 2. 获取已下载数据总大小
        const NSInteger totalSize = self.imageData.length;

        // 3. 更新数据源，我们需要传入所有数据，而不仅仅是新数据
        CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)self.imageData, NULL);

        // 4. 首次获取到数据时，从这些数据中获取图片的长、宽、方向属性值
        if (width + height == 0) {
            CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL);
            if (properties) {
                NSInteger orientationValue = -1;
                CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);
                if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;height);
                ...
                CFRelease(properties);

                // 5. 当绘制到Core Graphics时，我们会丢失方向信息，这意味着有时候由initWithCGIImage创建的图片
                //    的方向会不对，所以在这边我们先保存这个信息并在后面使用。
                orientation = [[self class] orientationFromPropertyValue:(orientationValue == -1 ? 1 : orientationValue)];
            }
        }

        // 6. 图片还未下载完成
        if (width + height &gt; 0 &amp;&amp; totalSize &lt; self.expectedSize) {
            // 7. 使用现有的数据创建图片对象，如果数据中存有多张图片，则取第一张
            CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(imageSource, 0, NULL);

#ifdef TARGET_OS_IPHONE
            // 8. 适用于iOS变形图像的解决方案。我的理解是由于iOS只支持RGB颜色空间，所以在此对下载下来的图片做个颜色空间转换处理。
            if (partialImageRef) {
                const size_t partialHeight = CGImageGetHeight(partialImageRef);
                CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
                CGContextRef bmContext = CGBitmapContextCreate(NULL, width, height, 8, width * 4, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);
                CGColorSpaceRelease(colorSpace);

                if (bmContext) {
                    CGContextDrawImage(bmContext, (CGRect){.origin.x = 0.0f, .origin.y = 0.0f, .size.width = width, .size.height = partialHeight}, partialImageRef);
                    CGImageRelease(partialImageRef);
                    partialImageRef = CGBitmapContextCreateImage(bmContext);
                    CGContextRelease(bmContext);
                }
                else {
                    CGImageRelease(partialImageRef);
                    partialImageRef = nil;
                }
            }
#endif

            // 9. 对图片进行缩放、解码操作
            if (partialImageRef) {
                UIImage *image = [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation];
                NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];
                UIImage *scaledImage = [self scaledImageForKey:key image:image];
                image = [UIImage decodedImageWithImage:scaledImage];
                CGImageRelease(partialImageRef);
                dispatch_main_sync_safe(^{
                    if (self.completedBlock) {
                        self.completedBlock(image, nil, nil, NO);
                    }
                });
            }
        }

        CFRelease(imageSource);
    }

    if (self.progressBlock) {
        self.progressBlock(self.imageData.length, self.expectedSize);
    }
}
</code></pre>

<p>我们前面说过SDWebImageDownloaderOperation类是继承自NSOperation类。它没有简单的实现main方法，而是采用更加灵活的start方法，以便自己管理下载的状态。</p>

<p>在start方法中，创建了我们下载所使用的NSURLConnection对象，开启了图片的下载，同时抛出一个下载开始的通知。当然，如果我们期望下载在后台处理，则只需要配置我们的下载选项，使其包含SDWebImageDownloaderContinueInBackground选项。start方法的具体实现如下：</p>

<pre><code>- (void)start {
    @synchronized (self) {
        // 管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES
        if (self.isCancelled) {
            self.finished = YES;
            [self reset];
            return;
        }

#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0
        // 1. 如果设置了在后台执行，则进行后台执行
        if ([self shouldContinueWhenAppEntersBackground]) {
            __weak __typeof__ (self) wself = self;
            self.backgroundTaskId = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
                ...
                }
            }];
        }
#endif

        self.executing = YES;
        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];
        self.thread = [NSThread currentThread];
    }

    [self.connection start];

    if (self.connection) {
        if (self.progressBlock) {
            self.progressBlock(0, NSURLResponseUnknownLength);
        }

        // 2. 在主线程抛出下载开始通知
        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];
        });

        // 3. 启动run loop
        if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) {
            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);
        }
        else {
            CFRunLoopRun();
        }

        // 4. 如果未完成，则取消连接
        if (!self.isFinished) {
            [self.connection cancel];
            [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@{NSURLErrorFailingURLErrorKey : self.request.URL}]];
        }
    }
    else {
        ... 
    }

#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0
    if (self.backgroundTaskId != UIBackgroundTaskInvalid) {
        [[UIApplication sharedApplication] endBackgroundTask:self.backgroundTaskId];
        self.backgroundTaskId = UIBackgroundTaskInvalid;
    }
#endif
}
</code></pre>

<p>当然，在下载完成或下载失败后，需要停止当前线程的run loop，清除连接，并抛出下载停止的通知。如果下载成功，则会处理完整的图片数据，对其进行适当的缩放与解压缩操作，以提供给完成回调使用。具体可参考-connectionDidFinishLoading:与-connection:didFailWithError:的实现。</p>

<h3>小结</h3>

<p>下载的核心其实就是利用NSURLConnection对象来加载数据。每个图片的下载都由一个Operation操作来完成，并将这些操作放到一个操作队列中。这样可以实现图片的并发下载。</p>

<h2>缓存</h2>

<p>为了减少网络流量的消耗，我们都希望下载下来的图片缓存到本地，下次再去获取同一张图片时，可以直接从本地获取，而不再从远程服务器获取。这样做的另一个好处是提升了用户体验，用户第二次查看同一幅图片时，能快速从本地获取图片直接呈现给用户。</p>

<p>SDWebImage提供了对图片缓存的支持，而该功能是由SDImageCache类来完成的。该类负责处理内存缓存及一个可选的磁盘缓存。其中磁盘缓存的写操作是异步的，这样就不会对UI操作造成影响。</p>

<h3>内存缓存及磁盘缓存</h3>

<p>内存缓存的处理是使用NSCache对象来实现的。NSCache是一个类似于集合的容器。它存储key-value对，这一点类似于NSDictionary类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。</p>

<p>磁盘缓存的处理则是使用NSFileManager对象来实现的。图片存储的位置是位于Cache文件夹。另外，SDImageCache还定义了一个串行队列，来异步存储图片。</p>

<p>内存缓存与磁盘缓存相关变量的声明及定义如下：</p>

<pre><code>@interface SDImageCache ()

@property (strong, nonatomic) NSCache *memCache;
@property (strong, nonatomic) NSString *diskCachePath;
@property (strong, nonatomic) NSMutableArray *customPaths;
@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t ioQueue;

@end

- (id)initWithNamespace:(NSString *)ns {
    if ((self = [super init])) {
        NSString *fullNamespace = [@"com.hackemist.SDWebImageCache." stringByAppendingString:ns];

        ...

        _ioQueue = dispatch_queue_create("com.hackemist.SDWebImageCache", DISPATCH_QUEUE_SERIAL);

        ...

        // Init the memory cache
        _memCache = [[NSCache alloc] init];
        _memCache.name = fullNamespace;

        // Init the disk cache
        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
        _diskCachePath = [paths[0] stringByAppendingPathComponent:fullNamespace];

        dispatch_sync(_ioQueue, ^{
            _fileManager = [NSFileManager new];
        });

        ...
    }

    return self;
}
</code></pre>

<p>SDImageCache提供了大量方法来缓存、获取、移除及清空图片。而对于每个图片，为了方便地在内存或磁盘中对它进行这些操作，我们需要一个key值来索引它。在内存中，我们将其作为NSCache的key值，而在磁盘中，我们用这个key作为图片的文件名。对于一个远程服务器下载的图片，其url是作为这个key的最佳选择了。我们在后面会看到这个key值的重要性。</p>

<h3>存储图片</h3>

<p>我们先来看看图片的缓存操作，该操作会在内存中放置一份缓存，而如果确定需要缓存到磁盘，则将磁盘缓存操作作为一个task放到串行队列中处理。在iOS中，会先检测图片是PNG还是JPEG，并将其转换为相应的图片数据，最后将数据写入到磁盘中(文件名是对key值做MD5摘要后的串)。缓存操作的基础方法是-storeImage:recalculateFromImage:imageData:forKey:toDisk，它的具体实现如下：</p>

<pre><code>- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk {
    ...

    // 1. 内存缓存，将其存入NSCache中，同时传入图片的消耗值
    [self.memCache setObject:image forKey:key cost:image.size.height * image.size.width * image.scale * image.scale];

    if (toDisk) {
        // 2. 如果确定需要磁盘缓存，则将缓存操作作为一个任务放入ioQueue中
        dispatch_async(self.ioQueue, ^{
            NSData *data = imageData;

            if (image &amp;&amp; (recalculate || !data)) {
#if TARGET_OS_IPHONE

                // 3. 需要确定图片是PNG还是JPEG。PNG图片容易检测，因为有一个唯一签名。PNG图像的前8个字节总是包含以下值：137 80 78 71 13 10 26 10
                // 在imageData为nil的情况下假定图像为PNG。我们将其当作PNG以避免丢失透明度。而当有图片数据时，我们检测其前缀，确定图片的类型
                BOOL imageIsPng = YES;

                if ([imageData length] &gt;= [kPNGSignatureData length]) {
                    imageIsPng = ImageDataHasPNGPreffix(imageData);
                }

                if (imageIsPng) {
                    data = UIImagePNGRepresentation(image);
                }
                else {
                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);
                }
#else
                data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];
#endif
            }

            // 4. 创建缓存文件并存储图片
            if (data) {
                if (![_fileManager fileExistsAtPath:_diskCachePath]) {
                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];
                }

                [_fileManager createFileAtPath:[self defaultCachePathForKey:key] contents:data attributes:nil];
            }
        });
    }
}
</code></pre>

<h3>查询图片</h3>

<p>如果我们想在内存或磁盘中查询是否有key指定的图片，则可以分别使用以下方法：</p>

<pre><code>- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key;
- (UIImage *)imageFromDiskCacheForKey:(NSString *)key;
</code></pre>

<p>而如果只是想查看本地是否在key指定的图片，则不管是在内存还是在磁盘上，则可以使用以下方法：</p>

<pre><code>- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock {
    ...

    // 1. 首先查看内存缓存，如果查找到，则直接回调doneBlock并返回
    UIImage *image = [self imageFromDiskCacheForKey:key];
    if (image) {
        doneBlock(image, SDImageCacheTypeMemory);
        return nil;
    }

    // 2. 如果内存中没有，则在磁盘中查找。如果找到，则将其放到内存缓存，并调用doneBlock回调
    NSOperation *operation = [NSOperation new];
    dispatch_async(self.ioQueue, ^{
        if (operation.isCancelled) {
            return;
        }

        @autoreleasepool {
            UIImage *diskImage = [self diskImageForKey:key];
            if (diskImage) {
                CGFloat cost = diskImage.size.height * diskImage.size.width * diskImage.scale * diskImage.scale;
                [self.memCache setObject:diskImage forKey:key cost:cost];
            }

            dispatch_async(dispatch_get_main_queue(), ^{
                doneBlock(diskImage, SDImageCacheTypeDisk);
            });
        }
    });

    return operation;
}
</code></pre>

<h3>移除图片</h3>

<p>图片的移除操作则可以使用以下方法：</p>

<pre><code>- (void)removeImageForKey:(NSString *)key;
- (void)removeImageForKey:(NSString *)key withCompletion:(SDWebImageNoParamsBlock)completion;
- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk;
- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion;
</code></pre>

<p>我们可以选择同时移除内存及磁盘上的图片。</p>

<h3>清理图片</h3>

<p>磁盘缓存图片的清理操作可以分为完全清空和部分清理。完全清空操作是直接把缓存的文件夹移除，清空操作有以下两个方法：</p>

<pre><code>- (void)clearDisk;
- (void)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion;
</code></pre>

<p>而部分清理则是根据我们设定的一些参数值来移除一些文件，这里主要有两个指标：文件的缓存有效期及最大缓存空间大小。文件的缓存有效期可以通过maxCacheAge属性来设置，默认是1周的时间。如果文件的缓存时间超过这个时间值，则将其移除。而最大缓存空间大小是通过maxCacheSize属性来设置的，如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。清理的操作在-cleanDiskWithCompletionBlock:方法中，其实现如下：</p>

<pre><code>- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock {
    dispatch_async(self.ioQueue, ^{
        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];
        NSArray *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];

        // 1. 该枚举器预先获取缓存文件的有用的属性
        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL
                                                   includingPropertiesForKeys:resourceKeys
                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles
                                                                 errorHandler:NULL];

        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];
        NSMutableDictionary *cacheFiles = [NSMutableDictionary dictionary];
        NSUInteger currentCacheSize = 0;

        // 2. 枚举缓存文件夹中所有文件，该迭代有两个目的：移除比过期日期更老的文件；存储文件属性以备后面执行基于缓存大小的清理操作
        NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init];
        for (NSURL *fileURL in fileEnumerator) {
            NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:NULL];

            // 3. 跳过文件夹
            if ([resourceValues[NSURLIsDirectoryKey] boolValue]) {
                continue;
            }

            // 4. 移除早于有效期的老文件
            NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];
            if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) {
                [urlsToDelete addObject:fileURL];
                continue;
            }

            // 5. 存储文件的引用并计算所有文件的总大小，以备后用
            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];
            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];
            [cacheFiles setObject:resourceValues forKey:fileURL];
        }

        for (NSURL *fileURL in urlsToDelete) {
            [_fileManager removeItemAtURL:fileURL error:nil];
        }

        // 6.如果磁盘缓存的大小大于我们配置的最大大小，则执行基于文件大小的清理，我们首先删除最老的文件
        if (self.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.maxCacheSize) {
            // 7. 以设置的最大缓存大小的一半作为清理目标
            const NSUInteger desiredCacheSize = self.maxCacheSize / 2;

            // 8. 按照最后修改时间来排序剩下的缓存文件
            NSArray *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent
                                                            usingComparator:^NSComparisonResult(id obj1, id obj2) {
                                                                return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];
                                                            }];

            // 9. 删除文件，直到缓存总大小降到我们期望的大小
            for (NSURL *fileURL in sortedFiles) {
                if ([_fileManager removeItemAtURL:fileURL error:nil]) {
                    NSDictionary *resourceValues = cacheFiles[fileURL];
                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];
                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];

                    if (currentCacheSize &lt; desiredCacheSize) {
                        break;
                    }
                }
            }
        }
                                if (completionBlock) {
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock();
            });
        }
    });
}
</code></pre>

<h3>小结</h3>

<p>以上分析了图片缓存操作，当然，除了上面讲的几个操作，SDImageCache类还提供了一些辅助方法。如获取缓存大小、缓存中图片的数量、判断缓存中是否存在某个key指定的图片。另外，SDImageCache类提供了一个单例方法的实现，所以我们可以将其当作单例对象来处理。</p>

<h2>SDWebImageManager</h2>

<p>在实际的运用中，我们并不直接使用SDWebImageDownloader类及SDImageCache类来执行图片的下载及缓存。为了方便用户的使用，SDWebImage提供了SDWebImageManager对象来管理图片的下载与缓存。而且我们经常用到的诸如UIImageView+WebCache等控件的分类都是基于SDWebImageManager对象的。该对象将一个下载器和一个图片缓存绑定在一起，并对外提供两个只读属性来获取它们，如下代码所示：</p>

<pre><code>@interface SDWebImageManager : NSObject

@property (weak, nonatomic) id &lt;SDWebImageManagerDelegate&gt; delegate;

@property (strong, nonatomic, readonly) SDImageCache *imageCache;
@property (strong, nonatomic, readonly) SDWebImageDownloader *imageDownloader;

...

@end
</code></pre>

<p>从上面的代码中我们还可以看到有一个delegate属性，其是一个id&lt;SDWebImageManagerDelegate>对象。SDWebImageManagerDelegate声明了两个可选实现的方法，如下所示：</p>

<pre><code>// 控制当图片在缓存中没有找到时，应该下载哪个图片
- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;

// 允许在图片已经被下载完成且被缓存到磁盘或内存前立即转换
- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;
</code></pre>

<p>这两个代理方法会在SDWebImageManager的-downloadImageWithURL:options:progress:completed:方法中调用，而这个方法是SDWebImageManager类的核心所在。我们来看看它的具体实现：</p>

<pre><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url
                                         options:(SDWebImageOptions)options
                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock {

    ...

    // 前面省略n行。主要作了如下处理：
    // 1. 判断url的合法性
    // 2. 创建SDWebImageCombinedOperation对象
    // 3. 查看url是否是之前下载失败过的
    // 4. 如果url为nil，或者在不可重试的情况下是一个下载失败过的url，则直接返回操作对象并调用完成回调

    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) {
        ...

        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) {

            // 下载
            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) {
                if (weakOperation.isCancelled) {
                    // 操作被取消，则不做任务事情
                }
                else if (error) {
                    // 如果出错，则调用完成回调，并将url放入下载挫败url数组中
                    ...
                }
                else {
                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);

                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) {
                        // Image refresh hit the NSURLCache cache, do not call the completion block
                    }
                    else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) {
                        // 在全局队列中并行处理图片的缓存
                        // 首先对图片做个转换操作，该操作是代理对象实现的
                        // 然后对图片做缓存处理
                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];

                            if (transformedImage &amp;&amp; finished) {
                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];
                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:data forKey:key toDisk:cacheOnDisk];
                            }

                            ...
                        });
                    }
                    else {
                        if (downloadedImage &amp;&amp; finished) {
                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];
                        }

                        ...
                    }
                }

                // 下载完成并缓存后，将操作从队列中移除
                if (finished) {
                    @synchronized (self.runningOperations) {
                        [self.runningOperations removeObject:operation];
                    }
                }
            }];

            // 设置取消回调
            operation.cancelBlock = ^{
                [subOperation cancel];

                @synchronized (self.runningOperations) {
                    [self.runningOperations removeObject:weakOperation];
                }
            };
        }
        else if (image) {
            ...
        }
        else {
            ...
        }
    }];

    return operation;
}
</code></pre>

<p>对于这个方法，我们没有做过多的解释。其主要就是下载图片并根据操作选项来缓存图片。上面这个下载方法中的操作选项参数是由枚举SDWebImageOptions来定义的，这个操作中的一些选项是与SDWebImageDownloaderOptions中的选项对应的。我们来看看这个SDWebImageOptions选项都有哪些：</p>

<pre><code>typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) {

    // 默认情况下，当URL下载失败时，URL会被列入黑名单，导致库不会再去重试，该标记用于禁用黑名单
    SDWebImageRetryFailed = 1 &lt;&lt; 0,

    // 默认情况下，图片下载开始于UI交互，该标记禁用这一特性，这样下载延迟到UIScrollView减速时
    SDWebImageLowPriority = 1 &lt;&lt; 1,

    // 该标记禁用磁盘缓存
    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,

    // 该标记启用渐进式下载，图片在下载过程中是渐渐显示的，如同浏览器一下。
    // 默认情况下，图像在下载完成后一次性显示
    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,

    // 即使图片缓存了，也期望HTTP响应cache control，并在需要的情况下从远程刷新图片。
    // 磁盘缓存将被NSURLCache处理而不是SDWebImage，因为SDWebImage会导致轻微的性能下载。
    // 该标记帮助处理在相同请求URL后面改变的图片。如果缓存图片被刷新，则完成block会使用缓存图片调用一次
    // 然后再用最终图片调用一次
    SDWebImageRefreshCached = 1 &lt;&lt; 4,

    // 在iOS 4+系统中，当程序进入后台后继续下载图片。这将要求系统给予额外的时间让请求完成
    // 如果后台任务超时，则操作被取消
    SDWebImageContinueInBackground = 1 &lt;&lt; 5,

    // 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES;来处理存储在NSHTTPCookieStore中的cookie
    SDWebImageHandleCookies = 1 &lt;&lt; 6,

    // 允许不受信任的SSL认证
    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,

    // 默认情况下，图片下载按入队的顺序来执行。该标记将其移到队列的前面，
    // 以便图片能立即下载而不是等到当前队列被加载
    SDWebImageHighPriority = 1 &lt;&lt; 8,

    // 默认情况下，占位图片在加载图片的同时被加载。该标记延迟占位图片的加载直到图片已以被加载完成
    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,

    // 通常我们不调用动画图片的transformDownloadedImage代理方法，因为大多数转换代码可以管理它。
    // 使用这个票房则不任何情况下都进行转换。
    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,
};
</code></pre>

<p>大家在看-downloadImageWithURL:options:progress:completed:，可以看到两个SDWebImageOptions与SDWebImageDownloaderOptions中的选项是如何对应起来的，在此不多做解释。</p>

<h2>视图扩展</h2>

<p>我在使用SDWebImage的时候，使用得最多的是UIImageView+WebCache中的针对UIImageView的扩展方法，这些扩展方法将UIImageView与WebCache集成在一起，来让UIImageView对象拥有异步下载和缓存远程图片的能力。其中最核心的方法是-sd_setImageWithURL:placeholderImage:options:progress:completed:，其使用SDWebImageManager单例对象下载并缓存图片，完成后将图片赋值给UIImageView对象的image属性，以使图片显示出来，其具体实现如下：</p>

<pre><code>- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock {
    ...

    if (url) {
        __weak UIImageView *wself = self;

        // 使用SDWebImageManager单例对象来下载图片
        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
            if (!wself) return;
            dispatch_main_sync_safe(^{
                if (!wself) return;

                // 图片下载完后显示图片
                if (image) {
                    wself.image = image;
                    [wself setNeedsLayout];
                } else {
                    if ((options &amp; SDWebImageDelayPlaceholder)) {
                        wself.image = placeholder;
                        [wself setNeedsLayout];
                    }
                }
                if (completedBlock &amp;&amp; finished) {
                    completedBlock(image, error, cacheType, url);
                }
            });
        }];
        [self sd_setImageLoadOperation:operation forKey:@"UIImageViewImageLoad"];
    } else {
        ...
    }
}
</code></pre>

<p>除了扩展UIImageView之外，SDWebImage还扩展了UIView、UIButton、MKAnnotationView等视图类，大家可以参考源码。</p>

<p>当然，如果不想使用这些扩展，则可以直接使用SDWebImageManager来下载图片，这也是很OK的。</p>

<h2>技术点</h2>

<p>SDWebImage的主要任务就是图片的下载和缓存。为了支持这些操作，它主要使用了以下知识点：</p>

<ol>
<li><p>dispatch_barrier_sync函数：该方法用于对操作设置屏幕，确保在执行完任务后才会执行后续操作。该方法常用于确保类的线程安全性操作。</p></li>
<li><p>NSMutableURLRequest：用于创建一个网络请求对象，我们可以根据需要来配置请求报头等信息。</p></li>
<li><p>NSOperation及NSOperationQueue：操作队列是Objective-C中一种高级的并发处理方法，现在它是基于GCD来实现的。相对于GCD来说，操作队列的优点是可以取消在任务处理队列中的任务，另外在管理操作间的依赖关系方面也容易一些。对SDWebImage中我们就看到了如何使用依赖将下载顺序设置成后进先出的顺序。</p></li>
<li><p>NSURLConnection：用于网络请求及响应处理。在iOS7.0后，苹果推出了一套新的网络请求接口，即NSURLSession类。</p></li>
<li><p>开启一个后台任务。</p></li>
<li><p>NSCache类：一个类似于集合的容器。它存储key-value对，这一点类似于NSDictionary类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。</p></li>
<li><p>清理缓存图片的策略：特别是最大缓存空间大小的设置。如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。</p></li>
<li><p>对图片的解压缩操作：这一操作可以查看SDWebImageDecoder.m中+decodedImageWithImage方法的实现。</p></li>
<li><p>对GIF图片的处理</p></li>
<li><p>对WebP图片的处理</p></li>
</ol>


<p>感兴趣的同学可以深入研究一下这些知识点。当然，这只是其中一部分，更多的知识还有待大家去发掘。</p>

<h2>参考</h2>

<ol>
<li><a href="https://github.com/rs/SDWebImage">SDWebImage工程</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/">Grand Central Dispatch (GCD) Reference</a></li>
<li><a href="http://objccn.io/issue-2-2/">常见的后台实践</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/">NSOperation Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/">NSCache Class Reference</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/31/nsobjectzhi-er/">NSObject之二</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-31T22:41:09+08:00" pubdate data-updated="true">Jan 31<sup>st</sup>, 2015</time>
        
        
           | <a href="/blog/2015/01/31/nsobjectzhi-er/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前面一章我们整理了NSObject类，这一章我们来看看NSObject协议的内容。</p>

<p>NSObject协议提供了一组方法作为Objective-C对象的基础。其实我们对照一个NSObject类和NSObject协议，可以看到很多方法的方法名都是一样的，只不过NSObject类提供的是类方法，是基于类级别的操作；而NSObject协议提供的是实例方法，是基于实例对象级别的操作。</p>

<p>如果一个对象如果采用了这个协议，则可以被看作是一级对象。我们可以从这个对象获取以下信息：</p>

<ol>
<li>类信息，以及类所在的继承体系。</li>
<li>协议信息</li>
<li>响应特定消息的能力</li>
</ol>


<p>实际上，Cocoa的根类NSObject就采用了这个类，所以所有继承自NSObject类的对象都具备NSObject协议中描述的功能。接下来，我们参照NSObject类，整理一下这些功能。</p>

<h2>识别对象</h2>

<p>类似于NSObject类，NSObject协议提供了一些方法来识别类。</p>

<p>如果想获取对象的类对象，则可以使用如下方法：</p>

<pre><code>- (Class)class
</code></pre>

<p>如果想获取对象父类的类对象，则可以使用以下只读属性：</p>

<pre><code>@property(readonly) Class superclass
</code></pre>

<p>如果想查看某个对象是否是给定类的实例或者是给定类子类的实例，则可以使用以下方法：</p>

<pre><code>- (BOOL)isKindOfClass:(Class)aClass
</code></pre>

<p>这个方法应该是大家常用的方法。需要注意的是在类簇中使用这个方法。在类簇中，我们获取到的对象类型可能并不是我们期望的类型。如果我们调用一个返回类簇的方法，则这个方法返回的实际类型会是最能标识这个类能做些什么的类型。例如，如果一个方法返回一个指向NSArray对象的指针，则不能使用isKindOfClass:方法查看经是否是一个可变数组，如以下代码：</p>

<pre><code>if ([myArray isKindOfClass:[NSMutableArray class]])
{
    // Modify the object
}
</code></pre>

<p>如果我们使用这样的代码，我们可能会认为修改一个实际上不应该被修改的对象是没问题的。这样做可能会对那些期望对象保持不要变的代码产生影响。</p>

<p>另外，查看对象是否是指定类的一个实例还可以使用以下方法：</p>

<pre><code>- (BOOL)isMemberOfClass:(Class)aClass
</code></pre>

<p>注意，这个方法无法确定对象是否是指定类子类的实例。另外，类对象可能是编译器创建的对象，但它仍然支持这一概念。</p>

<h2>测试对象</h2>

<p>对于对象的测试，NSObject协议也定义了两个方法，其中respondsToSelector:方法用于测试对象是否能响应指定的消息，这个方法可以是类自定义的实例方法，也可以是继承而来的实例方法。其声明如下：</p>

<pre><code>- (BOOL)respondsToSelector:(SEL)aSelector
</code></pre>

<p>不过我们不能使用super关键字来调用respondsToSelector:，以查看对象是否是从其父类继承了某个方法。因为我们可以从super的定义可知，消息的最终实际接收者还是self本身，因此测试的还是对象的整个体系(包括对象所在类本身)，而不仅仅是父类。不过，我们可以使用父类来调用NSObject类的类方法instancesRespondToSelector:来达到这个目的，如下所示：</p>

<pre><code>if( [MySuperclass instancesRespondToSelector:@selector(aMethod)] ) {
    // invoke the inherited method
    [super aMethod];
}
</code></pre>

<p>我们不能简单地使用[[self superclass] instancesRespondToSelector:@selector(aMethod)]，因为如果由一个子类来调用，则可能导致方法的失败。</p>

<p>还需要注意的是，如果对象能够转发消息，则也可以响应这个消息，不过这个方法会返回NO。</p>

<p>如果想查看对象是否实现了某个类，则可以使用如下方法：</p>

<pre><code>- (BOOL)conformsToProtocol:(Protocol *)aProtocol
</code></pre>

<p>这个方法与NSObject类的类方法conformsToProtocol:是一样的。它只是提供了一个便捷方法，我们不需要先去取对象的类，再调用类方法conformsToProtocol:。</p>

<h2>标识和比较对象</h2>

<p>如果我们想获取对象本身，则可以使用以下方法：</p>

<pre><code>- (instancetype)self
</code></pre>

<p>比较两个对象是否相同，则可以使用以下方法：</p>

<pre><code>- (BOOL)isEqual:(id)anObject
</code></pre>

<p>这个方法定义了对象相同的意义。例如，一个容器对象可能会按照特定规则来定义两个对象是否相等，如其所有元素的isEqual:请求都返回YES。我们在自定义子类时，可以重写这个方法，以使用我们自己的规则来评判两个对象相等。</p>

<p>如果两个对象相等，则它们必须拥有相同的hash值。在子类中定义isEqual:方法并打算把子类的实例放入集合中时，这一点非常重要。因此在子类中必须同时定义hash。</p>

<p>hash值是一个整数值，它可以用于在hash表结构中作为一个表地址。其声明如下：</p>

<pre><code>@property(readonly) NSUInteger hash
</code></pre>

<p>如果一个可变对象被添加到一个以hash值来确定对象位置的集合中，则当对象还在集合中时，其由hash方法返回的值不能改变。因此，hash方法不能依赖于对象内部的任何状态信息，或许我们必须确保对象在集合中时，不能改变其内部状态信息。比如，一个可变字典可以放到一个hash表中，但当它还在表中时，不能改变它。</p>

<h2>发送消息</h2>

<p>在NSObject类中，定义了一系列的发送消息的方法，用于在目标线程中执行方法。NSObject协议也定义了如下几个方法，来执行发送消息的任务：</p>

<pre><code>- (id)performSelector:(SEL)aSelector

- (id)performSelector:(SEL)aSelector withObject:(id)anObject

- (id)performSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject
</code></pre>

<p>这三个方法基本相同，只不过后面两个方法能为selector指定的方法携带参数。因此我们以performSelector:为例。</p>

<p>performSelector:方法的使用与直接将消息发送给对象的效果是一样的，如下面几个操作，做的事情是一样的：</p>

<pre><code>id myClone = [anObject copy];
id myClone = [anObject performSelector:@selector(copy)];
id myClone = [anObject performSelector:sel_getUid("copy")];
</code></pre>

<p>区别在于，performSelector:允许在运行时再去确定对象是否能处理消息。而[anObject copy]中，如果anObject不能处理copy，编译器就直接会报错。</p>

<p>如果方法的参数过多，以至于上面几个方法都无法处理，则可以考虑使用NSInvocation对象。</p>

<h2>描述对象</h2>

<p>描述对象的方法与NSObject类中描述类的方法其方法名相同，都是description，其声明如下：</p>

<pre><code>@property(readonly, copy) NSString *description
</code></pre>

<p>这个方法用于创建一个对象的文本表达方式，例如：</p>

<pre><code>ClassName *anObject = &lt;#An object#&gt;;
NSString *string = [NSString stringWithFormat:@"anObject is %@", anObject];
</code></pre>

<p>为了便于调试，NSObject协议还定义debugDescription方法，该方法声明如下：</p>

<pre><code>@property(readonly, copy) NSString *debugDescription
</code></pre>

<p>该方法返回一个在调试器中显示的用于描述对象内容的字符串。在调试器中打印一个对象时，会调用这个方法。NSObject类实现这个方法时只是调用了description方法，所以默认情况下，这两个方法的输出都是一样的。我们在子类中可以重写这个方法的实现。</p>

<h2>总结</h2>

<p>NSObject协议的定义的很多方法都是我们平常经常使用的。我们在创建NSObject类的子类时，默认都继承了NSObject类对于NSObject协议的实现。如果有特殊的需求，我们可以重写这些方法。</p>

<p>当然，NSObject协议还定义了一些方法，如我们非常熟悉的retain, release, autorelease, retainCount方法，不过这些方法在ARC时代已经过时了，我们在此不过多说明。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html">NSObject Protocol Reference</a></li>
</ol>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
<section>
<h1>分类</h1>
<ul>
  <li><a href='/blog/categories/ios'>ios (64)</a></li>
  <li><a href='/blog/categories/network'>network (3)</a></li>
  <li><a href='/blog/categories/reactivecocoa'>reactivecocoa (3)</a></li>
  <li><a href='/blog/categories/swift'>swift (7)</a></li>
  <li><a href='/blog/categories/system'>system (1)</a></li>
  <li><a href='/blog/categories/网络'>网络 (8)</a></li>
</ul>
</section>

<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/05/10/ioszhi-shi-xiao-ji-di-%5B%3F%5D-qi-2015-dot-05-dot-10/">iOS知识小集 第一期(2015.05.10)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/23/nskeyvalueobserving-kvo/">NSKeyValueObserving(KVO)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/24/yuan-ma-pian-:mbprogresshud/">源码篇：MBProgressHUD</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/20/nsnotificationcenter/">NSNotificationCenter</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/14/nsnotificationyu-duo-xian-cheng/">Notification与多线程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/07/uiresponder/">UIResponder</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/">翻译篇：iOS 8 Handoff Tutorial</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/11/nscache/">NSCache</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/07/yuan-ma-pian-:sdwebimage/">源码篇：SDWebImage</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/31/nsobjectzhi-er/">NSObject之二</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 南峰子 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  











</body>
</html>
