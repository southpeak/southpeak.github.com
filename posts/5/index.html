
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>南峰子的技术博客</title>
  <meta name="author" content="南峰子">
      
  <meta name="baidu-site-verification" content="HoscFhWICI" />

  
  <meta name="description" content="一个Graphics Context表示一个绘制目标。它包含绘制系统用于完成绘制指令的绘制参数和设备相关信息。Graphics Context定义了基本的绘制属性，如颜色、裁减区域、线条宽度和样式信息、字体信息、混合模式等。 我们可以通过几种方式来获取Graphics Context： &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://southpeak.github.io/posts/5">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="南峰子的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <!-- googleapis is fucked by gfw -->
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">南峰子的技术博客</a></h1>
  
    <h2>攀登，一步一个脚印，方能知其乐</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:southpeak.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/categories/ios">iOS开发</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/11/quartz-2dbian-cheng-zhi-nan-zhi-er-:tu-xing-shang-xia-wen-graphics-contexts/">Quartz 2D编程指南之二：图形上下文(Graphics Contexts)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-11T23:14:44+08:00" pubdate data-updated="true">Nov 11<sup>th</sup>, 2014</time>
        
        
           | <a href="/blog/2014/11/11/quartz-2dbian-cheng-zhi-nan-zhi-er-:tu-xing-shang-xia-wen-graphics-contexts/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一个Graphics Context表示一个绘制目标。它包含绘制系统用于完成绘制指令的绘制参数和设备相关信息。Graphics Context定义了基本的绘制属性，如颜色、裁减区域、线条宽度和样式信息、字体信息、混合模式等。</p>

<p>我们可以通过几种方式来获取Graphics Context：Quartz提供的创建函数、Mac OS X框架或IOS的UIKit框架提供的函数。Quartz提供了多种Graphics Context的创建函数，包括bitmap和PDF，我们可以使用这些Graphics Context创建自定义的内容。</p>

<p>本章介绍了如何为不同的绘制目标创建Graphics Context。在代码中，我们用CGContextRef来表示一个Graphics Context。当获得一个Graphics Context后，可以使用Quartz 2D函数在上下文(context)中进行绘制、完成操作(如平移)、修改图形状态参数(如线宽和填充颜色)等。</p>

<h2>在iOS中的视图Graphics Context进行绘制</h2>

<p>在iOS应用程序中，如果要在屏幕上进行绘制，需要创建一个UIView对象，并实现它的drawRect:方法。视图的drawRect:方法在视图显示在屏幕上及它的内容需要更新时被调用。在调用自定义的drawRect:后，视图对象自动配置绘图环境以便代码能立即执行绘图操作。作为配置的一部分，视图对象将为当前的绘图环境创建一个Graphics Context。我们可以通过调用UIGraphicsGetCurrentContext函数来获取这个Graphics Context。</p>

<p>UIKit默认的坐标系统与Quartz不同。在UIKit中，原点位于左上角，y轴正方向为向下。UIView通过将修改Quartz的Graphics Context的CTM[原点平移到左下角，同时将y轴反转(y值乘以-1)]以使其与UIView匹配。</p>

<h2>在Mac OS X中创建一个窗口Graphics Context</h2>

<p>在Mac OS X中绘制时，我们需要创建一个窗口Graphics Context。Quartz 2D API 没有提供函数来获取窗口Graphics Context。取而代之的是用Cocoa框架来获取一个窗口上下文。</p>

<p>我们可以在Cocoa应用程序的drawRect:中获取一个Quartz Graphics Context，如下代码所示：</p>

<pre><code>CGContextRef myContext = [[NSGraphicsContext currentContext] graphicsPort];
</code></pre>

<p>currentContext方法在当前线程中返回NSGraphicsContext实例。graphicsPort方法返回一个低级别、平台相关的Graphics Context(Quartz Graphics Context)。</p>

<p>在获取到Graphics Context后，我们可以在Cocoa应用程序中调用任何Quartz 2D的绘制函数。我们同样可以将Quartz 2D与Cocoa绘制操作混合使用。如图2-1是一个在Cocoa视图中用Quartz 2D绘制的实例。绘图由两个长方形组成(一个不透明的红色长方形和半透明的蓝色长方形)。</p>

<p><strong>Figure 2-1  A view in the Cocoa framework that contains Quartz drawing</strong></p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/cocoa_draw.gif" alt="image" /></p>

<p>为了实现图2-1实例，需要先创建一个Cocoa应用程序。在Interface Builder中，拖动一个Custom View到窗口中，并子类化。然后实现子类视图的，如代码清单2-1所示。视图的drawRect:包含了所有的Quartz绘制代码。</p>

<p><em>注：NSView的drawRect:方法在每次视图需要绘制时自动调用。</em></p>

<p><strong>Listing 2-1  Drawing to a window graphics context</strong></p>

<pre><code>@implementation MyQuartzView
- (id)initWithFrame:(NSRect)frameRect
{
    self = [super initWithFrame:frameRect];
    return self;
}
- (void)drawRect:(NSRect)rec
{
    CGContextRef myContext = [[NSGraphicsContext  currentContext] graphicsPort]; //1
   // ********** Your drawing code here **********       //2
    CGContextSetRGBFillColor (myContext, 1, 0, 0, 1);     //3
    CGContextFillRect (myContext, CGRectMake (0, 0, 200, 100 ));   //4
    CGContextSetRGBFillColor (myContext, 0, 0, 1, .5);     //5
    CGContextFillRect (myContext, CGRectMake (0, 0, 100, 200));   //6
}
@end
</code></pre>

<p>代码说明：</p>

<ol>
<li>为视图获取一个Graphics Context</li>
<li>插入绘图代码的地方。以下四行是使用Quartz 2D函数的例子</li>
<li>设置完全不透明的红色填充色。</li>
<li>填充一个长方形，其原点为(0, 0), 大小为(200, 100)</li>
<li>设置半透明的蓝色填充色。</li>
<li>填充一个长方形，其原点为(0, 0), 大小为(100, 200)</li>
</ol>


<h2>创建一个PDF Graphics Context</h2>

<p>当创建一个PDF Graphics Context并绘制时，Quartz将绘制操作记录为一系列的PDF绘制命令并写入文件中。我们需要提供一个PDF输出的位置及一个默认的media box(用于指定页面边界的长方形)。图2-2显示了在PDF Graphics Context中绘制及在preview打开PDF的结果。</p>

<p><strong>Figure 2-2  A PDF created by using CGPDFContextCreateWithURL</strong></p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/pdf_context_draw.gif" alt="image" /></p>

<p>Quartz 2D API提供了两个函数来创建PDF Graphics Context:</p>

<p>● CGPDFContextCreateWithURL：当你需要用Core Foundation URL指定pdf输出的位置时使用该函数。代码清单2-2显示了该函数的使用方法(代码2-2及后面代码的详细解释略)：</p>

<p><strong>Listing 2-2  Calling CGPDFContextCreateWithURL to create a PDF graphics context</strong></p>

<pre><code>CGContextRef MyPDFContextCreate (const CGRect *inMediaBox, CFStringRef path)
{
    CGContextRef myOutContext = NULL;
    CFURLRef url;
    url = CFURLCreateWithFileSystemPath (NULL, path, kCFURLPOSIXPathStyle, false);
    if (url != NULL) {
        myOutContext = CGPDFContextCreateWithURL (url,  inMediaBox,  NULL);
        CFRelease(url);
    }
    return myOutContext;
}
</code></pre>

<p>● CGPDFContextCreate：当需要将pdf输出发送给数据用户时使用该方法。代码清单2-3显示了该函数的使用方法：</p>

<p><strong>Listing 2-3  Calling CGPDFContextCreate to create a PDF graphics context</strong></p>

<pre><code>CGContextRef MyPDFContextCreate (const CGRect *inMediaBox, CFStringRef path)
{
    CGContextRef        myOutContext = NULL;
    CFURLRef            url;
    CGDataConsumerRef   dataConsumer;
    url = CFURLCreateWithFileSystemPath (NULL,  path, kCFURLPOSIXPathStyle, false);
    if (url != NULL)
    {
        dataConsumer = CGDataConsumerCreateWithURL (url);
        if (dataConsumer != NULL)
        {
            myOutContext = CGPDFContextCreate (dataConsumer, inMediaBox, NULL);
            CGDataConsumerRelease (dataConsumer);
        }
        CFRelease(url);
    }
    return myOutContext;
}
</code></pre>

<p>代码清单2-4显示是如何调用MyPDFContextCreate程序及绘制操作。</p>

<p><strong>Listing 2-4  Drawing to a PDF graphics context</strong></p>

<pre><code>CGRect mediaBox;

mediaBox = CGRectMake (0, 0, myPageWidth, myPageHeight);
myPDFContext = MyPDFContextCreate (&amp;mediaBox, CFSTR("test.pdf"));
CFStringRef myKeys[1];
CFTypeRef myValues[1];
myKeys[0] = kCGPDFContextMediaBox;
myValues[0] = (CFTypeRef) CFDataCreate(NULL,(const UInt8 *)&amp;mediaBox, sizeof (CGRect));
CFDictionaryRef pageDictionary = CFDictionaryCreate(NULL, (const void **) myKeys,
                                                    (const void **) myValues, 1,
                                                    &amp;kCFTypeDictionaryKeyCallBacks,
                                                    &amp; kCFTypeDictionaryValueCallBacks);
CGPDFContextBeginPage(myPDFContext, &amp;pageDictionary);
    // ********** Your drawing code here **********
    CGContextSetRGBFillColor (myPDFContext, 1, 0, 0, 1);
    CGContextFillRect (myPDFContext, CGRectMake (0, 0, 200, 100 ));
    CGContextSetRGBFillColor (myPDFContext, 0, 0, 1, .5);
    CGContextFillRect (myPDFContext, CGRectMake (0, 0, 100, 200 ));
CGPDFContextEndPage(myPDFContext);
CFRelease(pageDictionary);
CFRelease(myValues[0]);
CGContextRelease(myPDFContext);
</code></pre>

<p>我们可以将任何内容(图片，文本，绘制路径)绘制到pdf中，并能添加链接及加密。</p>

<h2>创建位图Graphics Context</h2>

<p>一个位图Graphics Context接受一个指向内存缓存(包含位图存储空间)的指针，当我们绘制一个位图Graphics Context时，该缓存被更新。在释放Graphics Context后，我们将得到一个我们指定像素格式的全新的位图。</p>

<p><em>注：位图Graphics Context有时用于后台绘制。CGLayer对象优化了后台绘制，因为Quartz在显卡上缓存了层。</em></p>

<pre><code>iOS提示：iOS应用程序使用了UIGraphicsBeginImageContextWithOptions取代Quartz低层函数。如果使用Quartz创建一下后台bitmap，bitmap Graphics Context使用的坐标系统是Quartz默认的坐标系统。而使用UIGraphicsBeginImageContextWithOptions创建图形上下文，UIKit将会对坐标系统使用与UIView对象的图形上下文一样的转换。这允许应用程序使用相同的绘制代码而不需要担心坐标系统问题。虽然我们的应用程序可以手动调整CTM达到相同的效果，但这种做没有任何好处。
</code></pre>

<p>我们使用CGBitmapContextCreate来创建位图Graphics Context，该函数有如下参数：</p>

<p>● data：一个指向内存目标的指针，该内存用于存储需要渲染的图形数据。内存块的大小至少需要(bytePerRow * height)字节。</p>

<p>● width：指定位图的宽度，单位是像素(pixel)。</p>

<p>● height：指定位图的高度， 单位是像素(pixel)。</p>

<p>● bitsPerComponent：指定内存中一个像素的每个组件使用的位数。例如，一个32位的像素格式和一个rgb颜色空间，我们可以指定每个组件为8位。</p>

<p>● bytesPerRow：指定位图每行的字节数。</p>

<p>● colorspace：颜色空间用于位图上下文。在创建位图Graphics Context时，我们可以使用灰度(gray), RGB, CMYK, NULL颜色空间。</p>

<p>● bitmapInfo：位图的信息，这些信息用于指定位图是否需要包含alpha组件，像素中alpha组件的相对位置(如果有的话)，alpha组件是否是预乘的，及颜色组件是整型值还是浮点值。</p>

<p>代码清单2-5显示了如何创建位图Graphics Context。当向位图Graphics Context绘图时，Quartz将绘图记录到内存中指定的块中。</p>

<p><strong>Listing 2-5  Creating a bitmap graphics context</strong></p>

<pre><code>CGContextRef MyCreateBitmapContext (int pixelsWide, int pixelsHigh)
{
    CGContextRef    context = NULL;
    CGColorSpaceRef colorSpace;
    void *          bitmapData;
    int             bitmapByteCount;
    int             bitmapBytesPerRow;
    bitmapBytesPerRow   = (pixelsWide * 4);
    bitmapByteCount     = (bitmapBytesPerRow * pixelsHigh);
    colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
    bitmapData = calloc( bitmapByteCount );
    if (bitmapData == NULL)
    {
        fprintf (stderr, "Memory not allocated!");
        return NULL;
    }
    context = CGBitmapContextCreate (bitmapData, pixelsWide, pixelsHigh, 8, bitmapBytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast);
    if (context== NULL)
    {
        free (bitmapData);
        fprintf (stderr, "Context not created!");
        return NULL;
    }
    CGColorSpaceRelease( colorSpace );
    return context;
}
</code></pre>

<p>代码清单2-6显示了调用MyCreateBitmapContext 创建一个位图Graphics Context，使用位图Graphics Context来创建CGImage对象，然后将图片绘制到窗口Graphics Context中。绘制结果如图2-3所示：</p>

<p><strong>Listing 2-6  Drawing to a bitmap graphics context</strong></p>

<pre><code>CGRect myBoundingBox;
myBoundingBox = CGRectMake (0, 0, myWidth, myHeight);
myBitmapContext = MyCreateBitmapContext (400, 300);
// ********** Your drawing code here ********** 
CGContextSetRGBFillColor (myBitmapContext, 1, 0, 0, 1);
CGContextFillRect (myBitmapContext, CGRectMake (0, 0, 200, 100 ));
CGContextSetRGBFillColor (myBitmapContext, 0, 0, 1, .5);
CGContextFillRect (myBitmapContext, CGRectMake (0, 0, 100, 200 ));
myImage = CGBitmapContextCreateImage (myBitmapContext);
CGContextDrawImage(myContext, myBoundingBox, myImage);
char *bitmapData = CGBitmapContextGetData(myBitmapContext); 
CGContextRelease (myBitmapContext);
if (bitmapData) free(bitmapData); 
CGImageRelease(myImage);
</code></pre>

<p><strong>Figure 2-3  An image created from a bitmap graphics context and drawn to a window graphics context</strong></p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/cocoa_draw.gif" alt="image" /></p>

<h2>支持的像素格式</h2>

<p>表2-1总结了位图Graphics Context支持的像素格式，相关的颜色空间及像素格式支持的Mac OS X最早版本。像素格式用bpp(每像素的位数)和bpc(每个组件的位数)来表示。表格同时也包含与像素格式相关的位图信息常量。</p>

<p>表2-1：位图Graphics Context支持的像素格式</p>

<p><img src="http://a1.qpic.cn/psb?/V130i6W71atwfr/yA.HJQ2EPTcENE9.Nk8Ql81JN5yDO08pmocm2G.CZ2g!/b/dPvSQHSSIAAA&amp;bo=DwOAAgAAAAADB6w!&amp;rf=viewer_4" alt="image" /></p>

<h2>反锯齿</h2>

<p>位图Graphics Context支持反锯齿，这一操作是人为的较正在位图中绘制文本或形状时产生的锯齿边缘。当位图的分辩率明显低于人眼的分辩率时就会产生锯齿。为了使位图中的对象显得平滑，Quartz使用不同的颜色来填充形状周边的像素。通过这种方式来混合颜色，使形状看起来更平滑。如图2-4显示的效果。我们可以通过调用CGContextSetShouldAntialias来关闭位图Graphics Context的反锯齿效果。反锯齿设置是图形状态的一部分。</p>

<p>可以调用函数CGContextSetAllowsAntialiasing来控制一个特定Graphics Context是否支持反锯齿；false表示不支持。该设置不是图形状态的一部分。当上下文及图形状态设置为true时，Quartz执行反锯齿。</p>

<p><strong>Figure 2-4  A comparison of aliased and anti-aliasing drawing</strong></p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/antialias.jpg" alt="image" /></p>

<h2>获取打印的Graphics Context</h2>

<p>Mac OS X中的Cocoa应用程序通过自定义的NSView子类来实现打印。一个视图通过调用print:方法来进行打印。然后视图以打印机为目标创建一个Graphics Context，并调用drawRect:方法。应用程序使用与在屏幕进行绘制相同的绘制代码。我们同样可以自定义drawRect: 方法将图形绘制到打印机。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/10/quartz-2dbian-cheng-zhi-nan-zhi-%5B%3F%5D-:gai-lan/">Quartz 2D编程指南之一：概览</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-10T22:02:30+08:00" pubdate data-updated="true">Nov 10<sup>th</sup>, 2014</time>
        
        
           | <a href="/blog/2014/11/10/quartz-2dbian-cheng-zhi-nan-zhi-%5B%3F%5D-:gai-lan/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><em>注：这一系列文章是《Quartz 2D Programming Guide》译文，三年前翻译的，放在cocoachina上面(账号名：德鲁伊)。觉得cocoachina文章的排版还不尽人意，所以现在把它们整理到这里来，也顺便温习一下。</em></p>

<h2>前言</h2>

<p>Quartz 2D是一个二维图形绘制引擎，支持iOS环境和Mac OS X环境。我们可以使用Quartz 2D API来实现许多功能，如基本路径的绘制、透明度、描影、绘制阴影、透明层、颜色管理、反锯齿、PDF文档生成和PDF元数据访问。在需要的时候，Quartz 2D还可以借助图形硬件的功能。</p>

<p>在Mac OS X中，Quartz 2D可以与其它图形图像技术混合使用，如Core Image、Core Video、OpenGL、QuickTime。例如，通过使用 QuickTime的GraphicsImportCreateCGImage函数，可以用 Quartz从一个 QuickTime图形导入器中创建一个图像。</p>

<h2>Page</h2>

<p>Quartz 2D在图像中使用了<strong>绘画者模型</strong>(painter&rsquo;s model)。在绘画者模型中，每个连续的绘制操作都是将一个绘制层(a layer of &lsquo;paint&rsquo;)放置于一个画布(&lsquo;canvas&rsquo;)，我们通常称这个画布为Page。 Page上的绘图可以通过额外的绘制操作来叠加更多的绘图。Page上的图形对象只能通过叠加更多的绘图来改变。这个模型允许我们使用小的图元来构建复杂的图形。</p>

<p>图1-1展示了绘画者模型如何工作。从图中可以看出不同的绘制顺序所产生的效果不一样。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/painters_model.gif" alt="image" /></p>

<p>Page可以是一张纸(如果输出设备是打印机)，也可以是虚拟的纸张(如果输出设备是PDF文件)，还可以是bitmap图像。这根据实际使用的graphics context而定。</p>

<h2>绘制目标：Graphics Context</h2>

<p>Graphics Context是一个数据类型(CGContextRef)，用于封装Quartz绘制图像到输出设备的信息。设备可以是PDF文件、bitmap或者显示器的窗口上。Graphics Context中的信息包括在Page中的图像的图形绘制参数和设备相关的表现形式。Quartz中所有的对象都是绘制到一个Graphics Context中。</p>

<p>我们可以将Graphics Context想像成绘制目标，如图1-2所示。当用Quartz绘图时，所有设备相关的特性都包含在我们所使用的Graphics Context中。换句话说，我们可以简单地给Quartz绘图序列指定不同的Graphics Context，就可将相同的图像绘制到不同的设备上。我们不需要处理任何设备相关的计算；这些都由Quartz替我们完成。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/draw_destinations.gif" alt="image" /></p>

<p>Quartz提供了以下几种类型的Graphics Context，详细的介绍将在后续章节说明。</p>

<ol>
<li>Bitmap Graphics Context</li>
<li>PDF Graphics Context</li>
<li>Window Graphics Context</li>
<li>Layer Context</li>
<li>Post Graphics Context</li>
</ol>


<h2>Quartz 2D 数据类型</h2>

<p>除了 Graphics Context 之外，Quartz 2D API还定义一些数据类型。由于这些API就Core Graphics框架的一部分，所以这些数据类型都是以CG开头的。</p>

<p>Quartz 2D使用这些数据类型来创建对象，通过操作这些对象来获取特定的图形。图1-3例举了三个使用Quartz 2D的绘制操作所获得的图像。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/drawing_primitives.gif" alt="image" /></p>

<p>下面列出了Quartz 2D包含的数据类型：</p>

<ol>
<li>CGPathRef：用于向量图，可创建路径，并进行填充或描画(stroke)</li>
<li>CGImageRef：用于表示bitmap图像和基于采样数据的bitmap图像遮罩。</li>
<li>CGLayerRef：用于表示可用于重复绘制(如背景)和幕后(offscreen)绘制的绘画层</li>
<li>CGPatternRef：用于重绘图</li>
<li>CGShadingRef、CGGradientRef：用于绘制渐变</li>
<li>CGFunctionRef：用于定义回调函数，该函数包含一个随机的浮点值参数。当为阴影创建渐变时使用该类型</li>
<li>CGColorRef, CGColorSpaceRef：用于告诉Quartz如何解释颜色</li>
<li>CGImageSourceRef,CGImageDestinationRef：用于在Quartz中移入移出数据</li>
<li>CGFontRef：用于绘制文本</li>
<li>CGPDFDictionaryRef, CGPDFObjectRef, CGPDFPageRef, CGPDFStream, CGPDFStringRef, and CGPDFArrayRef：用于访问PDF的元数据</li>
<li>CGPDFScannerRef, CGPDFContentStreamRef：用于解析PDF元数据</li>
<li>CGPSConverterRef：用于将PostScript转化成PDF。在iOS中不能使用。</li>
</ol>


<h2>图形状态</h2>

<p>Quartz通过修改当前图形状态(current graphics state)来修改绘制操作的结果。图形状态包含用于绘制程序的参数。绘制程序根据这些绘图状态来决定如何渲染结果。例如，当你调用设置填充颜色的函数时，你将改变存储在当前绘图状态中的颜色值。</p>

<p>Graphics Context包含一个<strong>绘图状态栈</strong>。当Quartz创建一个Graphics Context时，栈为空。当保存图形状态时，Quartz将当前图形状态的一个副本压入栈中。当还原图形状态时，Quartz将栈顶的图形状态出栈。出栈的状态成为当前图形状态。</p>

<p>可使用函数CGContextSaveGState来保存图形状态，CGContextRestoreGState来还原图形状态。</p>

<p>注意：并不是当前绘制环境的所有属性都是图形状态的元素。如，图形状态不包含当前路径(current path)。下面列出了图形状态相关的参数：</p>

<p><img src="http://a3.qpic.cn/psb?/V130i6W71atwfr/PQrRj6T.J63Q5vpnXXmsn*SQu2eYI*V3vJy7Ju7kex8!/b/dCbEpnPCHwAA&amp;bo=9gK1AQAAAAADB2I!&amp;rf=viewer_4" alt="image" /></p>

<h2>Quartz 2D 坐标系统</h2>

<p>坐标系统定义是被绘制到Page上的对象的位置及大小范围，如图1-4所示。我们在<strong>用户空间坐标系统</strong>(user-space coordination system，简称用户空间)中指定图形的位置及大小。坐标值是用浮点数来定义的。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/quartz_coordinates.gif" alt="image" /></p>

<p>由于不同的设备有不同的图形功能，所以图像的位置及大小依赖于设备。例如，一个显示设备可能每英寸只能显示少于96个像素，而打印机可能每英寸能显示300个像素。如果在设备级别上定义坐标系统，则在一个设备上绘制的图形无法在其它设备上正常显示。</p>

<p>Quartz通过使用<strong>当前转换矩阵</strong>(current transformation matrix， CTM)将一个独立的坐标系统(user space)映射到输出设备的坐标系统(device space)，以此来解决设备依赖问题。 CTM是一种特殊类型的矩阵(affine transform, 仿射矩阵)，通过平移(translation)、旋转(rotation)、缩放(scale)操作将点从一个坐标空间映射到另外一个坐标空间。</p>

<p>CTM还有另外一个目的：允许你通过转换来决定对象如何被绘制。例如，为了绘制一个旋转了45度的盒子，我们可以在绘制盒子之前旋转Page的坐标系统。Quartz使用旋转过的坐标系统来将盒子绘制到输出设备中。</p>

<p>用户空间的点用坐标对(x, y)来表示，(0, 0)表示坐标原点。Quartz中默认的坐标系统是：沿着x轴从左到右坐标值逐渐增大；沿着y轴从下到上坐标值逐渐增大。</p>

<p>有一些技术在设置它们的graphics context时使用了不同于Quartz的默认坐标系统。相对于Quartz来说，这些坐标系统是修改的坐标系统(modified coordinate system)，当在这些坐标系统中显示Quartz绘制的图形时，必须进行转换。最常见的一种修改的坐标系统是原点位于左上角，而沿着y轴从上到下坐标值逐渐增大。我们可以在如下一些地方见到这种坐标系统：</p>

<ol>
<li>在Mac OS X中，重写过isFlipped方法以返回yes的NSView类的子类</li>
<li>在iOS中，由UIView返回的绘图上下文</li>
<li>在iOS中，通过调用UIGraphicsBeginImageContextWithOptions函数返回的绘图上下文</li>
</ol>


<p>如果应用程序想以相同的绘制程序在一个UIView对象和PDF Graphics Context上进行绘制，需要做一个变换以使PDF Graphics Context使用与UIView相同的坐标系。要达到这一目的，只需要对PDF的上下文的原点做一个平移(移到左上角)和用-1对y坐标值进行缩放。图1-5显示了这种变换操作：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/flipped_coordinates.jpg" alt="image" /></p>

<p>我们的应用程序负责调整Quartz调用以确保有一个转换应用到上下文中。例如，如果你想要一个图片或PDF正确的绘制到一个Graphics Context中，你的应用程序可能需要临时调整Graphics Context的CTM。在iOS中，如果使用UIImage对象来包裹创建的CGImage对象，可以不需要修改CTM。UIImage将自动进行补偿以适用UIKit的坐标系统。</p>

<p><em>重要：如果你打算在iOS上开发与Quartz相关的程序，了解以上所讨论的是很有用的，但不是必须的。在iOS 3.2及后续的版本中，当UIKit为你的应用程序创建一个绘图上下文时，也对上下文进行了额外的修改以匹配UIKit的约定。特别的，patterns和shadows(不被CTM影响)单独进行调整以匹配UIKit坐标系统。在这种情况下，没有一个等价的机制让CTM来转换Quartz和UIKit的上下文。我们必须认识到在什么样的上下文中进行绘制，并调整行为以匹配上下文的预期。</em></p>

<h2>内存管理：对象所有权</h2>

<p>Quartz使用Core Foundation内存管理模型(引用计数)。所以，对象的创建与销毁与通常的方式是一样的。在Quartz中，需要记住如下一些规则：</p>

<ol>
<li>如果创建或拷贝一个对象，你将拥有它，因此你必须释放它。通常，如果使用含有”Create”或“Copy”单词的函数获取一个对象，当使用完后必须释放，否则将导致内存泄露。</li>
<li>如果使用不含有”Create”或“Copy”单词的函数获取一个对象，你将不会拥有对象的引用，不需要释放它。</li>
<li>如果你不拥有一个对象而打算保持它，则必须retain它并且在不需要时release掉。可以使用Quartz 2D的函数来指定retain和release一个对象。例如，如果创建了一个CGColorspace对象，则使用函数CGColorSpaceRetain和CGColorSpaceRelease来retain和release对象。同样，可以使用Core Foundation的CFRetain和CFRelease，但是注意不能传递NULL值给这些函数。</li>
</ol>


<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_overview/dq_overview.html#//apple_ref/doc/uid/TP30001066-CH202-TPXREF101">Quartz 2D Programming Guide</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/09/objective-c-runtime-yun-xing-shi-zhi-liu-:shi-yi/">Objective-C Runtime 运行时之六：拾遗</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-09T14:44:53+08:00" pubdate data-updated="true">Nov 9<sup>th</sup>, 2014</time>
        
        
           | <a href="/blog/2014/11/09/objective-c-runtime-yun-xing-shi-zhi-liu-:shi-yi/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前面几篇基本介绍了runtime中的大部分功能，包括对类与对象、成员变量与属性、方法与消息、分类与协议的处理。runtime大部分的功能都是围绕这几点来实现的。</p>

<p>本章的内容并不算重点，主要针对前文中对Objective-C Runtime Reference内容遗漏的地方做些补充。当然这并不能包含所有的内容。runtime还有许多内容，需要读者去研究发现。</p>

<h2>super</h2>

<p>在Objective-C中，如果我们需要在类的方法中调用父类的方法时，通常都会用到super，如下所示：</p>

<pre><code>@interface MyViewController: UIViewController

@end

@implementation MyViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    // do something
    ...
}

@end
</code></pre>

<p>如何使用super我们都知道。现在的问题是，它是如何工作的呢？</p>

<p>首先我们需要知道的是super与self不同。self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而super并不是隐藏参数，它实际上只是一个&#8221;编译器标示符&#8221;，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与self指向的是相同的消息接收者。为了理解这一点，我们先来看看super的定义：</p>

<pre><code>struct objc_super { id receiver; Class superClass; };
</code></pre>

<p>这个结构体有两个成员：</p>

<ol>
<li>receiver：即消息的实际接收者</li>
<li>superClass：指针当前类的父类</li>
</ol>


<p>当我们使用super来接收消息时，编译器会生成一个objc_super结构体。就上面的例子而言，这个结构体的receiver就是MyViewController对象，与self相同；superClass指向MyViewController的父类UIViewController。</p>

<p>接下来，发送消息时，不是调用objc_msgSend函数，而是调用objc_msgSendSuper函数，其声明如下：</p>

<pre><code>id objc_msgSendSuper ( struct objc_super *super, SEL op, ... );
</code></pre>

<p>该函数第一个参数即为前面生成的objc_super结构体，第二个参数是方法的selector。该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找viewDidLoad的selector，找到后以objc->receiver去调用这个selector，而此时的操作流程就是如下方式了</p>

<pre><code>objc_msgSend(objc_super-&gt;receiver, @selector(viewDidLoad))
</code></pre>

<p>由于objc_super->receiver就是self本身，所以该方法实际与下面这个调用是相同的：</p>

<pre><code>objc_msgSend(self, @selector(viewDidLoad))
</code></pre>

<p>为了便于理解，我们看以下实例：</p>

<pre><code>@interface MyClass : NSObject

@end

@implementation MyClass

- (void)test {
    NSLog(@"self class: %@", self.class);
    NSLog(@"super class: %@", super.class);
}

@end
</code></pre>

<p>调用MyClass的test方法后，其输出是：</p>

<pre><code>2014-11-08 15:55:03.256 [824:209297] self class: MyClass
2014-11-08 15:55:03.256 [824:209297] super class: MyClass
</code></pre>

<p>从上例中可以看到，两者的输出都是MyClass。大家可以自行用上面介绍的内容来梳理一下。</p>

<h2>库相关操作</h2>

<p>库相关的操作主要是用于获取由系统提供的库相关的信息，主要包含以下函数：</p>

<pre><code>// 获取所有加载的Objective-C框架和动态库的名称
const char ** objc_copyImageNames ( unsigned int *outCount );

// 获取指定类所在动态库
const char * class_getImageName ( Class cls );

// 获取指定库或框架中所有类的类名
const char ** objc_copyClassNamesForImage ( const char *image, unsigned int *outCount );
</code></pre>

<p>通过这几个函数，我们可以了解到某个类所有的库，以及某个库中包含哪些类。如下代码所示：</p>

<pre><code>NSLog(@"获取指定类所在动态库");

NSLog(@"UIView's Framework: %s", class_getImageName(NSClassFromString(@"UIView")));

NSLog(@"获取指定库或框架中所有类的类名");
const char ** classes = objc_copyClassNamesForImage(class_getImageName(NSClassFromString(@"UIView")), &amp;outCount);
for (int i = 0; i &lt; outCount; i++) {
    NSLog(@"class name: %s", classes[i]);
}
</code></pre>

<p>其输出结果如下：</p>

<pre><code>2014-11-08 12:57:32.689 [747:184013] 获取指定类所在动态库
2014-11-08 12:57:32.690 [747:184013] UIView's Framework: /System/Library/Frameworks/UIKit.framework/UIKit
2014-11-08 12:57:32.690 [747:184013] 获取指定库或框架中所有类的类名
2014-11-08 12:57:32.691 [747:184013] class name: UIKeyboardPredictiveSettings
2014-11-08 12:57:32.691 [747:184013] class name: _UIPickerViewTopFrame
2014-11-08 12:57:32.691 [747:184013] class name: _UIOnePartImageView
2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewSelectionBar
2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerWheelView
2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewTestParameters
......
</code></pre>

<h2>块操作</h2>

<p>我们都知道block给我们带到极大的方便，苹果也不断提供一些使用block的新的API。同时，苹果在runtime中也提供了一些函数来支持针对block的操作，这些函数包括：</p>

<pre><code>// 创建一个指针函数的指针，该函数调用时会调用特定的block
IMP imp_implementationWithBlock ( id block );

// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block
id imp_getBlock ( IMP anImp );

// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝
BOOL imp_removeBlock ( IMP anImp );
</code></pre>

<p>● imp_implementationWithBlock函数：参数block的签名必须是method_return_type ^(id self, method_args …)形式的。该方法能让我们使用block作为IMP。如下代码所示：</p>

<pre><code>@interface MyRuntimeBlock : NSObject

@end

@implementation MyRuntimeBlock

@end

// 测试代码
IMP imp = imp_implementationWithBlock(^(id obj, NSString *str) {
    NSLog(@"%@", str);
});

class_addMethod(MyRuntimeBlock.class, @selector(testBlock:), imp, "v@:@");

MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];
[runtime performSelector:@selector(testBlock:) withObject:@"hello world!"];
</code></pre>

<p>输出结果是</p>

<pre><code>2014-11-09 14:03:19.779 [1172:395446] hello world!
</code></pre>

<h2>弱引用操作</h2>

<pre><code>// 加载弱引用指针引用的对象并返回
id objc_loadWeak ( id *location );

// 存储__weak变量的新值
id objc_storeWeak ( id *location, id obj );
</code></pre>

<p>● objc_loadWeak函数：该函数加载一个弱指针引用的对象，并在对其做retain和autoreleasing操作后返回它。这样，对象就可以在调用者使用它时保持足够长的生命周期。该函数典型的用法是在任何有使用__weak变量的表达式中使用。</p>

<p>● objc_storeWeak函数：该函数的典型用法是用于__weak变量做为赋值对象时。</p>

<p>这两个函数的具体实施在此不举例，有兴趣的小伙伴可以参考《Objective-C高级编程：iOS与OS X多线程和内存管理》中对__weak实现的介绍。</p>

<h2>宏定义</h2>

<p>在runtime中，还定义了一些宏定义供我们使用，有些值我们会经常用到，如表示BOOL值的YES/NO；而有些值不常用，如OBJC_ROOT_CLASS。在此我们做一个简单的介绍。</p>

<h3>布尔值</h3>

<pre><code>#define YES  (BOOL)1
#define NO   (BOOL)0
</code></pre>

<p>这两个宏定义定义了表示布尔值的常量，需要注意的是YES的值是1，而不是非0值。</p>

<h3>空值</h3>

<pre><code>#define nil  __DARWIN_NULL
#define Nil  __DARWIN_NULL
</code></pre>

<p>其中nil用于空的实例对象，而Nil用于空类对象。</p>

<h3>分发函数原型</h3>

<pre><code>#define OBJC_OLD_DISPATCH_PROTOTYPES  1
</code></pre>

<p>该宏指明分发函数是否必须转换为合适的函数指针类型。当值为0时，必须进行转换</p>

<h3>Objective-C根类</h3>

<pre><code>#define OBJC_ROOT_CLASS 
</code></pre>

<p>如果我们定义了一个Objective-C根类，则编译器会报错，指明我们定义的类没有指定一个基类。这种情况下，我们就可以使用这个宏定义来避过这个编译错误。该宏在iOS 7.0后可用。</p>

<p>其实在NSObject的声明中，我们就可以看到这个宏的身影，如下所示：</p>

<pre><code>__OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
OBJC_ROOT_CLASS
OBJC_EXPORT
@interface NSObject &lt;NSObject&gt; {
    Class isa  OBJC_ISA_AVAILABILITY;
}
</code></pre>

<p>我们可以参考这种方式来定义我们自己的根类。</p>

<h3>局部变量存储时长</h3>

<pre><code>#define NS_VALID_UNTIL_END_OF_SCOPE 
</code></pre>

<p>该宏表明存储在某些局部变量中的值在优化时不应该被编译器强制释放。</p>

<p>我们将局部变量标记为id类型或者是指向ObjC对象类型的指针，以便存储在这些局部变量中的值在优化时不会被编译器强制释放。相反，这些值会在变量再次被赋值之前或者局部变量的作用域结束之前都会被保存。</p>

<h3>关联对象行为</h3>

<pre><code>enum {
   OBJC_ASSOCIATION_ASSIGN  = 0,
   OBJC_ASSOCIATION_RETAIN_NONATOMIC  = 1,
   OBJC_ASSOCIATION_COPY_NONATOMIC  = 3,
   OBJC_ASSOCIATION_RETAIN  = 01401,
   OBJC_ASSOCIATION_COPY  = 01403
};
</code></pre>

<p>这几个值在前面已介绍过，在此不再重复。</p>

<h2>总结</h2>

<p>至此，本系列对runtime的整理已完结。当然这只是对runtime的一些基础知识的归纳，力图起个抛砖引玉的作用。还有许多关于runtime有意思东西还需要读者自己去探索发现。</p>

<p><strong><em>注：如有不对之处，还请指正，欢迎加QQ好友：1318202110(南峰子)</em></strong></p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/">Objective-C Runtime Reference</a></li>
<li><a href="http://blog.csdn.net/itianyi/article/details/8678452">iOS:Objective-C中Self和Super详解</a></li>
<li><a href="http://www.cocoachina.com/industry/20130819/6824.html">Objective-C的动态特性</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/08/objective-c-runtime-yun-xing-shi-zhi-wu-:xie-yi-yu-fen-lei/">Objective-C Runtime 运行时之五：协议与分类</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-08T21:22:33+08:00" pubdate data-updated="true">Nov 8<sup>th</sup>, 2014</time>
        
        
           | <a href="/blog/2014/11/08/objective-c-runtime-yun-xing-shi-zhi-wu-:xie-yi-yu-fen-lei/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Objective-C中的分类允许我们通过给一个类添加方法来扩充它（但是通过category不能添加新的实例变量），并且我们不需要访问类中的代码就可以做到。</p>

<p>Objective-C中的协议是普遍存在的接口定义方式，即在一个类中通过@protocol定义接口，在另外类中实现接口，这种接口定义方式也成为“delegation”模式，@protocol声明了可以呗其他任何方法类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。</p>

<p>在本章中，我们来看看runtime对分类与协议的支持。</p>

<h2>基础数据类型</h2>

<h3>Category</h3>

<p>Category是表示一个指向分类的结构体的指针，其定义如下：</p>

<pre><code>typedef struct objc_category *Category;

struct objc_category {
    char *category_name                          OBJC2_UNAVAILABLE; // 分类名
    char *class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名
    struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表
    struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; // 类方法列表
    struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表
}  
</code></pre>

<p>这个结构体主要包含了分类定义的实例方法与类方法，其中instance_methods列表是objc_class中方法列表的一个子集，而class_methods列表是元类方法列表的一个子集。</p>

<h3>Protocol</h3>

<p>Protocol的定义如下：</p>

<pre><code>typedef struct objc_object Protocol;
</code></pre>

<p>我们可以看到，Protocol其中实就是一个对象结构体。</p>

<h2>操作函数</h2>

<p>Runtime并没有在&lt;objc/runtime.h>头文件中提供针对分类的操作函数。因为这些分类中的信息都包含在objc_class中，我们可以通过针对objc_class的操作函数来获取分类的信息。如下例所示：</p>

<pre><code>@interface RuntimeCategoryClass : NSObject
- (void)method1;
@end

@interface RuntimeCategoryClass (Category)
- (void)method2;
@end

@implementation RuntimeCategoryClass

- (void)method1 {

}

@end

@implementation RuntimeCategoryClass (Category)

- (void)method2 {

}

@end

#pragma mark -

NSLog(@"测试objc_class中的方法列表是否包含分类中的方法");
unsigned int outCount = 0;
Method *methodList = class_copyMethodList(RuntimeCategoryClass.class, &amp;outCount);

for (int i = 0; i &lt; outCount; i++) {
    Method method = methodList[i];

    const char *name = sel_getName(method_getName(method));

    NSLog(@"RuntimeCategoryClass's method: %s", name);

    if (strcmp(name, sel_getName(@selector(method2)))) {
        NSLog(@"分类方法method2在objc_class的方法列表中");
    }
}
</code></pre>

<p>其输出是：</p>

<pre><code>2014-11-08 10:36:39.213 [561:151847] 测试objc_class中的方法列表是否包含分类中的方法
2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass's method: method2
2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass's method: method1
2014-11-08 10:36:39.215 [561:151847] 分类方法method2在objc_class的方法列表中
</code></pre>

<p>而对于Protocol，runtime提供了一系列函数来对其进行操作，这些函数包括：</p>

<pre><code>// 返回指定的协议
Protocol * objc_getProtocol ( const char *name );

// 获取运行时所知道的所有协议的数组
Protocol ** objc_copyProtocolList ( unsigned int *outCount );

// 创建新的协议实例
Protocol * objc_allocateProtocol ( const char *name );

// 在运行时中注册新创建的协议
void objc_registerProtocol ( Protocol *proto );

// 为协议添加方法
void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );

// 添加一个已注册的协议到协议中
void protocol_addProtocol ( Protocol *proto, Protocol *addition );

// 为协议添加属性
void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );

// 返回协议名
const char * protocol_getName ( Protocol *p );

// 测试两个协议是否相等
BOOL protocol_isEqual ( Protocol *proto, Protocol *other );

// 获取协议中指定条件的方法的方法描述数组
struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );

// 获取协议中指定方法的方法描述
struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );

// 获取协议中的属性列表
objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );

// 获取协议的指定属性
objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );

// 获取协议采用的协议
Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );

// 查看协议是否采用了另一个协议
BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );
</code></pre>

<p>● objc_getProtocol函数，需要注意的是如果仅仅是声明了一个协议，而未在任何类中实现这个协议，则该函数返回的是nil。</p>

<p>● objc_copyProtocolList函数，获取到的数组需要使用free来释放</p>

<p>● objc_allocateProtocol函数，如果同名的协议已经存在，则返回nil</p>

<p>● objc_registerProtocol函数，创建一个新的协议后，必须调用该函数以在运行时中注册新的协议。协议注册后便可以使用，但不能再做修改，即注册完后不能再向协议添加方法或协议</p>

<p>需要强调的是，协议一旦注册后就不可再修改，即无法再通过调用protocol_addMethodDescription、protocol_addProtocol和protocol_addProperty往协议中添加方法等。</p>

<h2>小结</h2>

<p>Runtime并没有提供过多的函数来处理分类。对于协议，我们可以动态地创建协议，并向其添加方法、属性及继承的协议，并在运行时动态地获取这些信息。</p>

<p><strong><em>注：如有不对之处，还请指正，欢迎加QQ好友：1318202110(南峰子)</em></strong></p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/">Objective-C Runtime Reference</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/06/objective-c-runtime-yun-xing-shi-zhi-si-:method-swizzling/">Objective-C Runtime 运行时之四：Method Swizzling</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-06T21:36:17+08:00" pubdate data-updated="true">Nov 6<sup>th</sup>, 2014</time>
        
        
           | <a href="/blog/2014/11/06/objective-c-runtime-yun-xing-shi-zhi-si-:method-swizzling/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>理解Method Swizzling是学习runtime机制的一个很好的机会。在此不多做整理，仅翻译由Mattt Thompson发表于nshipster的<a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>一文。</p>

<p>Method Swizzling是改变一个selector的实际实现的技术。通过这一技术，我们可以在运行时通过修改类的分发表中selector对应的函数，来修改方法的实现。</p>

<p>例如，我们想跟踪在程序中每一个view controller展示给用户的次数：当然，我们可以在每个view controller的viewDidAppear中添加跟踪代码；但是这太过麻烦，需要在每个view controller中写重复的代码。创建一个子类可能是一种实现方式，但需要同时创建UIViewController, UITableViewController, UINavigationController及其它UIKit中view controller的子类，这同样会产生许多重复的代码。</p>

<p>这种情况下，我们就可以使用Method Swizzling，如在代码所示：</p>

<pre><code>#import &lt;objc/runtime.h&gt;

@implementation UIViewController (Tracking)

+ (void)load {
        static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        Class class = [self class];         
        // When swizzling a class method, use the following:
                    // Class class = object_getClass((id)self);

        SEL originalSelector = @selector(viewWillAppear:);
                    SEL swizzledSelector = @selector(xxx_viewWillAppear:);

        Method originalMethod = class_getInstanceMethod(class, originalSelector);
                    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);

        BOOL didAddMethod =
                        class_addMethod(class,
                originalSelector,
                method_getImplementation(swizzledMethod),
                method_getTypeEncoding(swizzledMethod));

        if (didAddMethod) {
                        class_replaceMethod(class,
                swizzledSelector,
                method_getImplementation(originalMethod),
                method_getTypeEncoding(originalMethod));
        } else {
            method_exchangeImplementations(originalMethod, swizzledMethod);
        }
    });
}

#pragma mark - Method Swizzling

- (void)xxx_viewWillAppear:(BOOL)animated {
        [self xxx_viewWillAppear:animated];
    NSLog(@"viewWillAppear: %@", self);
}

@end
</code></pre>

<p>在这里，我们通过method swizzling修改了UIViewController的@selector(viewWillAppear:)对应的函数指针，使其实现指向了我们自定义的xxx_viewWillAppear的实现。这样，当UIViewController及其子类的对象调用viewWillAppear时，都会打印一条日志信息。</p>

<p>上面的例子很好地展示了使用method swizzling来一个类中注入一些我们新的操作。当然，还有许多场景可以使用method swizzling，在此不多举例。在此我们说说使用method swizzling需要注意的一些问题：</p>

<h2>Swizzling应该总是在+load中执行</h2>

<p>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证&mdash;事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>

<h2>Swizzling应该总是在dispatch_once中执行</h2>

<p>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。</p>

<h2>选择器、方法与实现</h2>

<p>在Objective-C中，选择器(selector)、方法(method)和实现(implementation)是运行时中一个特殊点，虽然在一般情况下，这些术语更多的是用在消息发送的过程描述中。</p>

<p>以下是Objective-C Runtime Reference中的对这几个术语一些描述：</p>

<ol>
<li>Selector(typedef struct objc_selector *SEL)：用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。</li>
<li>Method(typedef struct objc_method *Method)：在类定义中表示方法的类型</li>
<li>Implementation(typedef id (*IMP)(id, SEL, &hellip;))：这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。每一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。</li>
</ol>


<p>理解这几个术语之间的关系最好的方式是：一个类维护一个运行时可接收的消息分发表；分发表中的每个入口是一个方法(Method)，其中key是一个特定名称，即选择器(SEL)，其对应一个实现(IMP)，即指向底层C函数的指针。</p>

<p>为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。</p>

<h2>调用_cmd</h2>

<p>我们回过头来看看前面新的方法的实现代码：</p>

<pre><code>- (void)xxx_viewWillAppear:(BOOL)animated {
    [self xxx_viewWillAppear:animated];
    NSLog(@"viewWillAppear: %@", NSStringFromClass([self class]));
}
</code></pre>

<p>咋看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中。在这种情况下，不会产生无限循环。不过如果我们调用的是[self viewWillAppear:animated]，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为xxx_viewWillAppear:了。</p>

<h2>注意事项</h2>

<p>Swizzling通常被称作是一种黑魔法，容易产生不可预知的行为和无法预见的后果。虽然它不是最安全的，但如果遵从以下几点预防措施的话，还是比较安全的：</p>

<ol>
<li>总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。</li>
<li>避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。</li>
<li>明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读Objective-C Runtime Reference和查看&lt;objc/runtime.h>头文件以了解事件是如何发生的。</li>
<li>小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。</li>
</ol>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/6">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/4">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
<section>
<h1>分类</h1>
<ul>
  <li><a href='/blog/categories/ios'>ios (59)</a></li>
  <li><a href='/blog/categories/network'>network (3)</a></li>
  <li><a href='/blog/categories/reactivecocoa'>reactivecocoa (3)</a></li>
  <li><a href='/blog/categories/swift'>swift (7)</a></li>
  <li><a href='/blog/categories/system'>system (1)</a></li>
  <li><a href='/blog/categories/网络'>网络 (8)</a></li>
</ul>
</section>

<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/03/07/uiresponder/">UIResponder</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/">翻译篇：iOS 8 Handoff Tutorial</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/11/nscache/">NSCache</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/07/yuan-ma-pian-:sdwebimage/">源码篇：SDWebImage</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/31/nsobjectzhi-er/">NSObject之二</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/31/nsobjectzhi-%5B%3F%5D/">NSObject之一</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/25/gong-ju-pian-:lldbdiao-shi-qi/">工具篇：LLDB调试器</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/11/yuan-ma-pian-:mantle/">源码篇：Mantle</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/11/gong-ju-pian-:mantle/">工具篇：Mantle</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/08/quartz-2dbian-cheng-zhi-nan-zhi-shi-san-:pdfwen-dang-de-chuang-jian-,-xian-shi-ji-zhuan-huan/">Quartz 2D编程指南之十三：PDF文档的创建、显示及转换</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 南峰子 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  











</body>
</html>
